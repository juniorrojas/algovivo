/**
 * algovivo
 * (c) 2023 Junior Rojas
 * License: MIT
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).algovivo=e()}(this,(function(){"use strict";function t(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}class e{constructor(t,e){this.list=t,this.data=e,this.next=null,this.prev=null}append(t){const s=new e(this.list,t);return this.list.last==this&&(this.list.last=s),s.next=this.next,s.prev=this,null!=this.next&&(this.next.prev=s),this.next=s,this.list.size++,s}prepend(t){const s=new e(this.list,t);return this.list.first==this&&(this.list.first=s),s.next=this,s.prev=this.prev,null!=this.prev&&(this.prev.next=s),this.prev=s,this.list.size++,s}remove(){null!=this.prev&&(this.prev.next=this.next),null!=this.next&&(this.next.prev=this.prev),this.list.first==this&&(this.list.first=this.next),this.list.last==this&&(this.list.last=this.prev),this.list.size--,this.next=null,this.prev=null}}var s=e;const r=s;class n{constructor(t){this.list=t,this.nextNode=this.list.first}next(){if(null==this.nextNode)return{done:!0};{const t={done:!1,value:this.nextNode.data};return this.nextNode=this.nextNode.next,t}}}class i{constructor(){this.first=null,this.last=null,this.size=0}isEmpty(){if(null==this.first&&null!=this.last||null!=this.first&&null==this.last)throw Error("inconsistent first last state");return null==this.first}append(t){return this.isEmpty()?this.setSingleton(t):this.last.append(t)}prepend(t){return this.isEmpty()?this.setSingleton(t):this.first.prepend(t)}setSingleton(t){const e=new r(this,t);return this.first=e,this.last=e,this.size=1,e}iter(){return new n(this)}*[Symbol.iterator](){const t=this.iter();let e=t.next();for(;!e.done;)yield e.value,e=t.next()}}var o,l,h,a,u,c,d={List:i,Node:s};function p(){if(l)return o;l=1;const t=m();return o=class extends t{constructor(t={}){super(t)}isFree(){return!1}free(){let t=this.appendFree(this.ptr,this.size);this.remove();const e=t.prev(),s=t.next();return null!=e&&e.isFree()&&(t=e.merge(t)),null!=s&&s.isFree()&&(t=t.merge(s)),t}}}function m(){if(a)return h;a=1;return h=class{constructor(t={}){this.manager=t.manager,this.ptr=t.ptr,this.size=t.size,this.node=t.node}numBytes(){return this.size}prev(){const t=this.node.prev;return null!=t?t.data:null}next(){const t=this.node.next;return null!=t?t.data:null}appendReserved(t,e){const s=p(),r=this.node.append(null),n=new s({manager:this.manager,ptr:t,size:e,node:r});return r.data=n,this.manager._addReservedSlot(n),n}appendFree(t,e){const s=f(),r=this.node.append(null),n=new s({manager:this.manager,ptr:t,size:e,node:r});return r.data=n,this.manager._addFreeSlot(n),n}remove(){this.node.remove(),this.node.data=null,this.node=null,this.isFree()?this.manager._removeFreeSlot(this):this.manager._removeReservedSlot(this)}toTypedArray(t){const e=this.size,s=t.BYTES_PER_ELEMENT;if(e%s!=0)throw new Error(`size in bytes must be a multiple of ${s}, found ${e}`);const r=this.ptr;return new t(this.manager.array,r,e/s)}f32(){return this.toTypedArray(Float32Array)}u32(){return this.toTypedArray(Uint32Array)}},h}function f(){if(c)return u;c=1;const t=m();return u=class extends t{constructor(t={}){super(t)}isFree(){return!0}reserve(t){const e=this.numBytes();if(t>e)throw new Error(`cannot reserve ${t} bytes, only ${e} bytes are available`);const s=this.appendReserved(this.ptr,t);return s.appendFree(this.ptr+t,e-t),this.remove(),s}merge(t){if(!this.isFree()||!t.isFree())throw new Error("only free slots can be merged");if(this.next()!=t)throw new Error("only adjacent slots can be merged");const e=t.appendFree(this.ptr,this.size+t.size);return this.remove(),t.remove(),e}}}const g=d,w=f();var y={linked:d,MemoryManager:class{constructor(t,e){this.array=t,null==e&&(e=0),this.ptrToSlot=new Map,this.slots=new g.List,this.freeSlots=new g.List,this.reservedSlots=new g.List;const s=new w({manager:this,ptr:e,size:t.byteLength-e}),r=this.slots.append();r.data=s,s.node=r;const n=this.freeSlots.append();n.data=s,s.freeNode=n}numReservedSlots(){return this.reservedSlots.size}numFreeSlots(){return this.freeSlots.size}numFreeBytes(){let t=0;const e=this.freeSlots.iter();let s=e.next();for(;!s.done;){t+=s.value.size,s=e.next()}return t}numReservedBytes(){let t=0;const e=this.reservedSlots.iter();let s=e.next();for(;!s.done;){t+=s.value.size,s=e.next()}return t}mallocBytes(t){return this._malloc(t)}malloc32(t){return this.mallocBytes(4*t)}_addReservedSlot(t){const e=this.reservedSlots.append(t);t.reservedNode=e}_removeReservedSlot(t){if(null==t.reservedNode)throw new Error("reservedNode cannot be null");t.reservedNode.remove()}_addFreeSlot(t){const e=this.freeSlots.append(t);t.freeNode=e}_removeFreeSlot(t){if(null==t.freeNode)throw new Error("freeNode cannot be null");t.freeNode.remove()}_malloc(t){if(!Number.isInteger(t))throw new Error(`expected integer, found ${t}`);let e=null;const s=this.freeSlots.iter();let r=s.next();for(;!r.done;){const n=r.value;if(n.size>=t){e=n;break}r=s.next()}if(null==e)throw new Error("no valid free slot available");return e.reserve(t)}malloc(t){const e=this._malloc(t);return this.ptrToSlot.set(e.ptr,e),e.ptr}free(t){this.ptrToSlot.get(t).free()}},FreeSlot:f(),ReservedSlot:p()};class x{constructor(t={}){const e=t.engine;if(null==e)throw new Error("engine required to create IntTuple");this.engine=e;const s=t.slot;if(null==s)throw new Error("slot required to create IntTuple");this.slot=s,this.ptr=s.ptr,this.length=t.length}forEach(t){for(let e=0;e<this.length;e++)t(this.get(e),e)}equal(t){if(t instanceof x){for(let e=0;e<this.length;e++){if(this.get(e)!=t.get(e))return!1}return!0}if(Array.isArray(t)){for(let e=0;e<this.length;e++){if(this.get(e)!=t[e])return!1}return!0}return!1}toString(){return this.slot.u32().toString()}toArray(){const t=[];return this.forEach((e=>{t.push(e)})),t}typedArray(){return this.slot.u32()}set(t,e){this.typedArray()[t]=e}get(t){return this.typedArray()[t]}dispose(){this.slot.free()}}var v=x;function E(t,e,s,r){if(e==s.length-1)for(let n=0;n<s[e];n++)t.push(r);else for(let n=0;n<s[e];n++){const n=[];t.push(n),E(n,e+1,s,r)}}var S={inferShape:function(t){const e=[];let s=t;for(;Array.isArray(s);)e.push(s.length),s=s[0];return e},makeNdArray:function(t,e){let s=t;t instanceof v&&(s=t.toArray());const r=[];return E(r,0,s,e),r},numelOfShape:function(t){let e=1;return t.forEach((t=>{e*=t})),e},getArrElem:function t(e,s){if(!Array.isArray(s))throw new Error(`expected array, found ${typeof s}: ${s}`);return 0==s.length?e:t(e[s[0]],s.slice(1))},setArrElem:function t(e,s,r){if(!Array.isArray(s))throw new Error(`expected array, found ${typeof s}: ${s}`);if(1!=s.length)return t(e[s[0]],s.slice(1),r);e[s]=r}};const b=v;class C{constructor(t){if(null==t)throw new Error("shape required");if(!(t instanceof b))throw new Error(`IntTuple shape expected, found ${typeof t}: shape`);this.shape=t,this.done=!1,this.idx=[],t.forEach((t=>{this.idx.push(0)}))}next(){const t=this.shape;for(let e=0;e<t.length;e++){const s=t.length-1-e;if(this.idx[s]<t.get(s)-1)return void this.idx[s]++;if(0==s)return void(this.done=!0);this.idx[s]=0}}static shapeForEach(t,e){const s=new C(t);for(;!s.done;)e(s.idx),s.next()}}const I=S,A=C,T=v;class M{constructor(t={}){const e=t.engine;if(null==e)throw new Error("engine required to create tensor");this.engine=e;const s=t.shape;if(null==s)throw new Error("shape required to create tensor");if(s instanceof T)this.shape=s;else{if(!Array.isArray(s))throw new Error(`invalid shape type ${typeof s}: ${s}`);this.shape=e.intTuple(s)}this.order=this.shape.length;const r=I.numelOfShape(this.shape);this.numel=r;const n=t.slot;if(r>0&&null==n)throw new Error("memory slot required to create tensor");this.slot=t.slot,this.ptr=this.slot.ptr;const i=t.stride;if(null!=i){if(!(i instanceof T))throw new Error(`expected IntTuple stride, found ${typeof i}: ${i}`);this.stride=i}else this.setDefaultStride()}get wasmInstance(){return this.engine.wasmInstance}isScalar(){return 0==this.order}fill_(t){this.wasmInstance.exports.fill_(this.numel,this.ptr,t)}clamp_(t={}){const e=t.min,s=t.max;this.wasmInstance.exports.clamp(this.numel,this.ptr,this.ptr,e,s,null!=e,null!=s)}zero_(){this.fill_(0)}flattenIdx(t){let e,s,r=!1;if(Array.isArray(t)&&(e=this.engine.intTuple(t),r=!0),!(e instanceof T))throw new Error(`cannot handle ${typeof e}: ${e}`);return s=this.engine.wasmInstance.exports.flatten_idx(this.order,e.slot.ptr,this.stride.slot.ptr),r&&e.dispose(),s}typedArray(){return this.slot.f32()}toArray(){if(0==this.numel)return[];const t=I.makeNdArray(this.shape,0);return this.forEach((e=>{const s=this.get(e);I.setArrElem(t,e,s)})),t}get(t){const e=this.flattenIdx(t);return this.typedArray()[e]}item(){if(!this.isScalar())throw new Error(`item() only works for scalars, found tensor with shape ${this.shape}`);return this.get([0])}setDefaultStride(){let t=1;const e=this.order,s=[];for(let t=0;t<e;t++)s.push(0);for(let r=0;r<e;r++){const n=e-1-r;s[n]=t,t*=this.shape.get(n)}this.stride=this.engine.intTuple(s)}setFromArray(t){if(0==this.numel)return;if(this.isScalar()){if("number"!=typeof t)throw new Error(`expected number, found ${typeof t}: ${t}`);this.set([0],t)}else{if(!Array.isArray(t))throw new Error(`expected array, found ${typeof t}: ${t}`);const e=I.inferShape(t);if(!this.shape.equal(e))throw new Error(`inconsistent shapes ${e} != ${this.shape}`);this.forEach((e=>{const s=I.getArrElem(t,e);this.set(e,s)}))}}set(t,e){if(null==e&&Array.isArray(t))this.setFromArray(t);else{const s=this.flattenIdx(t);this.typedArray()[s]=e}}forEach(t){A.shapeForEach(this.shape,t)}squeeze(t){-1==t&&(t=this.shape.length-1);const e=this.shape.get(t);if(1!=e)throw new Error(`cannot squeeze a dimension that is not equal to 1, shape[${t}] = ${e}`);const s=[];for(let e=0;e<this.order;e++)t!=e&&s.push(this.shape.get(e));return new M({engine:this.engine,shape:s,slot:this.slot})}unsqueeze(t){-1==t&&(t=this.shape.length-1);const e=[];for(let s=0;s<this.order;s++)e.push(this.shape.get(s)),t==s&&e.push(1);return new M({engine:this.engine,shape:e,slot:this.slot})}add(t,e){this.engine.functional.add(this,t,e)}sum(t){this.engine.wasmInstance.exports.sum(this.numel,this.slot.ptr,t.slot.ptr)}dispose(){this.slot.free(),this.shape.dispose(),this.stride.dispose()}}var z=M;var _=class{constructor(t={}){const e=this.engine=t.engine;this.wasmInstance=e.wasmInstance}matvec(t,e,s){const r=t.shape.get(0),n=t.shape.get(1),i=e.shape.get(0),o=s.shape.get(0);if(r!=o)throw new Error(`inconsistent output size ${r} != ${o}`);if(n!=i)throw new Error(`inconsistent input size ${n} != ${i}`);this.wasmInstance.exports.matvec(r,n,t.stride.ptr,t.ptr,e.stride.ptr,e.ptr,s.stride.ptr,s.ptr)}mm(t,e,s){const r=t.shape.get(0),n=t.shape.get(1),i=e.shape.get(1);this.wasmInstance.exports.mm(r,n,i,t.stride.ptr,t.ptr,e.stride.ptr,e.ptr,s.stride.ptr,s.ptr)}relu(t,e){this.wasmInstance.exports.relu(t.numel,t.ptr,e.ptr)}tanh(t,e){const s=t.numel,r=t.typedArray(),n=e.typedArray();for(let t=0;t<s;t++)n[t]=Math.tanh(r[t])}add(t,e,s){this.wasmInstance.exports.add(t.numel,t.ptr,e.ptr,s.ptr)}sum(t,e){this.wasmInstance.exports.sum(t.numel,t.ptr,e.ptr)}sumBackward(t,e,s,r){this.wasmInstance.exports.sum_backward(t.numel,t.ptr,e.ptr,s.ptr,r.ptr)}};var V=class{constructor(){}};const k=V;var $=class extends k{constructor(t,e){super(),this.nn=t,this.layers=e}forward(t){let e=t;return this.layers.forEach((t=>{e=t.forward(e)})),e}dispose(){this.layers.forEach((t=>{t.dispose()}))}};const L=V;var W=class extends L{constructor(t,e,s){super(),this.nn=t,this.inputSize=e,this.outputSize=s;const r=this.nn.engine;this.weight=r.zeros([s,e]),this.bias=r.zeros([s]),this.output=r.zeros([s])}forward(t){const e=this.nn.engine.functional;return e.matvec(this.weight,t,this.output),e.add(this.output,this.bias,this.output),this.output}dispose(){this.weight.dispose(),this.bias.dispose(),this.output.dispose()}};const D=V;var P=class extends D{constructor(t){super(),this.nn=t,this.output=null}forward(t){const e=this.nn.engine;return null==this.output&&(this.output=e.zerosLike(t)),e.functional.relu(t,this.output),this.output}dispose(){null!=this.output&&this.output.dispose()}};const F=V;var q=class extends F{constructor(t){super(),this.nn=t,this.output=null}forward(t){const e=this.nn.engine;return null==this.output&&(this.output=e.zerosLike(t)),e.functional.tanh(t,this.output),this.output}dispose(){null!=this.output&&this.output.dispose()}};const B=$,N=W,R=P,O=q;var X=class{constructor(t={}){this.engine=t.engine}Linear(t,e){return new N(this,t,e)}ReLU(){return new R(this)}Tanh(){return new O(this)}Sequential(){const t=Array.from(arguments);return new B(this,t)}};const U=y,G=S,H=z,j=v,Y=_,J=X;const K=class{constructor(t={}){null!=t.wasmInstance&&this.init(t),this.env={}}init(t={}){if(null==t.wasmInstance)throw new Error("wasmInstance required");this.wasmInstance=t.wasmInstance;const e=t.wasmInstance.exports.memory.buffer,s=new U.MemoryManager(e,t.wasmInstance.exports.__heap_base);this.mgr=s,this.functional=this.F=new Y({engine:this}),this.nn=new J({engine:this}),this._mergeF()}_mergeF(){Object.getOwnPropertyNames(Object.getPrototypeOf(this.F)).forEach((t=>{"constructor"!=t&&(this[t]=this.F[t])}))}tensor(t){const e=G.inferShape(t),s=this.intTuple(e),r=G.numelOfShape(e),n=this.mgr.malloc32(r),i=new H({engine:this,shape:s,slot:n});return i.setFromArray(t),i}intTuple(t){if(!Array.isArray(t))throw new Error(`expected array, found ${typeof t}: ${t}`);const e=t.length,s=this.mgr.malloc32(e),r=new j({engine:this,length:e,slot:s});for(let s=0;s<e;s++)r.set(s,t[s]);return r}zerosLike(t){if(!(t instanceof H))throw new Error(`expected tensor, found ${typeof t}: ${t}`);return this.zeros(t.shape.toArray())}empty(t){let e;if(t instanceof j)e=t;else{if(!Array.isArray(t))throw new Error(`expected array, found ${typeof t}: ${t}`);e=this.intTuple(t)}const s=G.numelOfShape(e),r=this.mgr.malloc32(s);return new H({engine:this,shape:e,slot:r})}zeros(t){const e=this.empty(t);return e.zero_(),e}ones(t){const e=this.empty(t);return e.fill_(1),e}};var Q={engine:function(t={}){return new K({wasmInstance:t.wasmInstance})},Engine:K,Tensor:z,mmgr:y,utils:S};const Z=Q;var tt=class{constructor(t={}){let e;if(null==t.ten){const s=t.wasmInstance;if(null==s)throw new Error("wasmInstance required");this.wasmInstance=s,e=new Z.Engine({wasmInstance:t.wasmInstance}),this.ten=e}else e=t.ten,this.wasmInstance=e.wasmInstance,this.ten=e;const s=e.wasmInstance,r=e.mgr;this.wasmInstance=s,this.memoryManager=r,this.fixedVertexId=-1,this.vertexMass=t.vertexMass??6.0714287757873535,this.k=90,this.h=.033,this.spaceDim=2}get pos(){return this.pos0}get vel(){return this.vel0}get numVertices(){return null==this.pos0?0:this.pos0.shape.get(0)}get numTriangles(){return null==this.triangles?0:this.triangles.u32().length/3}get numMuscles(){return null==this.muscles?0:this.muscles.u32().length/2}setVertices(t){const e=this.ten,s=this.spaceDim;if(null==t)throw new Error("pos required");const r=t.length,n=e.tensor(t);null!=this.pos0&&this.pos0.dispose(),this.pos0=n;const i=e.zeros([r,s]);null!=this.pos1&&this.pos1.dispose(),this.pos1=i;const o=e.zeros([r,s]);null!=this.vel0&&this.vel0.dispose(),this.vel0=o;const l=e.zeros([r,s]);null!=this.vel1&&this.vel1.dispose(),this.vel1=l,this.updateTmpBuffers()}setMuscles(t={}){if(null==t.indices)throw new Error("indices required");const e=t.indices,s=e.length,r=this.numMuscles,n=this.memoryManager,i=this.ten;null!=t.k&&(this.k=t.k);const o=n.malloc32(2*s);null!=this.muscles&&this.muscles.free(),this.muscles=o;const l=o.u32();if(e.forEach(((t,e)=>{const s=2*e;l[s]=t[0],l[s+1]=t[1]})),null!=this.l0&&this.l0.dispose(),this.l0=null,0!=s){const e=i.zeros([s]);this.l0=e,null==t.l0?this.wasmInstance.exports.l0_of_pos(this.numVertices,this.pos0.ptr,s,this.muscles.ptr,this.l0.ptr):this.l0.set(t.l0)}const h=t.keepA??!1;if(s!=r){if(h)throw new Error(`keepA can only be true when the number of muscles is the same (${s} != ${r})`);if(null!=this.a&&this.a.dispose(),0!=s){const t=i.zeros([s]);this.a=t,t.fill_(1)}}else 0==s?(null!=this.a&&this.a.dispose(),this.a=null):h||this.a.fill_(1)}setTriangles(t={}){const e=t.indices,s=t.rsi,r=e?e.length:this.numTriangles;if(null==e&&(!s||s.length!==r))throw new Error("rsi is not consistent with the number of indices");const n=this.memoryManager,i=this.ten,o=e?n.malloc32(3*r):this.triangles;if(e&&null!=this.triangles&&this.triangles.free(),this.triangles=o,null!=e){const t=o.u32();e.forEach(((e,s)=>{const r=3*s;t[r]=e[0],t[r+1]=e[1],t[r+2]=e[2]}))}null!=this.rsi&&this.rsi.dispose(),this.rsi=i.zeros([r,2,2]),null==s?this.wasmInstance.exports.rsi_of_pos(this.numVertices,this.pos0.ptr,r,this.triangles.ptr,this.rsi.ptr):this.rsi.set(s)}set(t){this.setVertices(t.pos),this.setMuscles({indices:t.muscles??[],l0:t.musclesL0,k:t.musclesK}),this.setTriangles({indices:t.triangles??[],rsi:t.trianglesRsi})}updateTmpBuffers(){if(null==this.pos0)throw new Error("pos0 required");const t=this.numVertices,e=this.spaceDim,s=this.ten,r=s.zeros([t,e]);null!=this.posGrad&&this.posGrad.dispose(),this.posGrad=r;const n=s.zeros([t,e]);null!=this.posTmp&&this.posTmp.dispose(),this.posTmp=n}step(){const t=this.numVertices,e=this.numMuscles,s=this.numTriangles,r=this.fixedVertexId,n=this.vertexMass;this.wasmInstance.exports.backward_euler_update(t,0==t?0:this.pos1.ptr,0==t?0:this.posGrad.ptr,0==t?0:this.posTmp.ptr,0==t?0:this.pos0.ptr,0==t?0:this.vel0.ptr,0==t?0:this.vel1.ptr,this.h,0,e,0==e?0:this.muscles.ptr,s,0==s?0:this.triangles.ptr,0==s?0:this.rsi.ptr,0==e?0:this.a.ptr,0==e?0:this.l0.ptr,this.k,r,n),0!=t&&(this.pos0.slot.f32().set(this.pos1.slot.f32()),this.vel0.slot.f32().set(this.vel1.slot.f32()))}dispose(){null!=this.pos0&&(this.pos0.dispose(),this.pos0=null),null!=this.pos1&&(this.pos1.dispose(),this.pos1=null),null!=this.posGrad&&(this.posGrad.dispose(),this.posGrad=null),null!=this.posTmp&&(this.posTmp.dispose(),this.posTmp=null),null!=this.vel0&&(this.vel0.dispose(),this.vel0=null),null!=this.vel1&&(this.vel1.dispose(),this.vel1=null),null!=this.triangles&&(this.triangles.free(),this.triangles=null),null!=this.rsi&&(this.rsi.dispose(),this.rsi=null),null!=this.muscles&&(this.muscles.free(),this.muscles=null),null!=this.l0&&(this.l0.dispose(),this.l0=null),null!=this.a&&(this.a.dispose(),this.a=null)}};function et(t){return[t[0],t[1]]}function st(t,e){t[0]*=e,t[1]*=e}function rt(t,e){const s=et(t);return st(s,e),s}function nt(t){return t[0]*t[0]+t[1]*t[1]}function it(t){return Math.sqrt(nt(t))}var ot={clone:et,add:function(t,e){return[t[0]+e[0],t[1]+e[1]]},add_:function(t,e){t[0]+=e[0],t[1]+=e[1]},mulScalar_:st,mulScalar:rt,sub:function(t,e){return[t[0]-e[0],t[1]-e[1]]},quadrance:nt,norm:it,normalize:function(t){return rt(t,1/it(t))},dot:function(t,e){return t[0]*e[0]+t[1]*e[1]}};class lt{constructor(t,e,s,r){this.m00=t,this.m01=e,this.m10=s,this.m11=r}get(t,e){return this[`m${t}${e}`]}set(t,e,s,r){this.m00=t,this.m01=e,this.m10=s,this.m11=r}toArray(){return[[this.m00,this.m01],[this.m10,this.m11]]}negate(){return new lt(-this.m00,-this.m01,-this.m10,-this.m11)}apply(t){return[this.m00*t[0]+this.m01*t[1],this.m10*t[0]+this.m11*t[1]]}det(){return this.m00*this.m11-this.m10*this.m01}inv(){const t=this.det();return new lt(this.m11/t,-this.m01/t,-this.m10/t,this.m00/t)}mm(t){const e=this.m00,s=this.m01,r=this.m10,n=this.m11,i=t.m00,o=t.m01,l=t.m10,h=t.m11;return new lt(e*i+s*l,e*o+s*h,r*i+n*l,r*o+n*h)}t(){return new lt(this.m00,this.m10,this.m01,this.m11)}static fromArray(t){return new lt(t[0][0],t[0][1],t[1][0],t[1][1])}}var ht=lt;const at=ht,ut=ot;class ct{constructor(){this.translation=[0,0],this.linear=new at(1,0,0,1)}inferScale(){return this.linear.m00}apply(t){return ut.add(this.linear.apply(t),this.translation)}inv(){const t=new ct;return t.linear=this.linear.inv(),t.translation=t.linear.negate().apply(this.translation),t}toColumnMajorArray(){return[this.linear.get(0,0),this.linear.get(1,0),this.linear.get(0,1),this.linear.get(1,1),this.translation[0],this.translation[1]]}}var dt=ct;var pt={Vec2:ot,Matrix2x2:ht,Transform2d:dt,AABB:class{constructor(t={}){if(null==t.x0)throw new Error("x0 required");if(null==t.y0)throw new Error("y0 required");this._x0=t.x0,this._y0=t.y0;let e=null;if(null!=t.width)e=this._x0+t.width;else{if(null==t.x1)throw new Error("x1 required");e=t.x1}this._x1=e;let s=null;if(null!=t.height)s=this._y0+t.height;else{if(null==t.y1)throw new Error("y1 required");s=t.y1}this._y1=s}get x0(){return this._x0}get x1(){return this._x1}get y0(){return this._y0}get y1(){return this._y1}get width(){return this._x1-this._x0}get height(){return this._y1-this._y0}get center(){return[.5*(this.x0+this.x1),.5*(this.y0+this.y1)]}}};const mt=pt;var ft=class{constructor(){this.transform=new mt.Transform2d}domToWorldSpace(t){if(!Array.isArray(t))throw new Error("array expected, found "+typeof t);if(2!=t.length)throw new Error(`array with 2 elements expected, found ${t.length}`);return this.transform.inv().apply(t)}inferScale(){return this.transform.inferScale()}center(t={}){let e=t.viewportWidth,s=t.viewportHeight;const r=t.renderer;if((null==e||null==s)&&null==r)throw new Error("renderer required");if(null!=r&&(e=r.width,s=r.height),null==e)throw new Error("viewportWidth required");if(null==s)throw new Error("viewportHeight required");let n,i=t.zoom??1;if(null!=t.worldWidth&&(i=e/t.worldWidth),this.transform.linear=new mt.Matrix2x2(i,0,0,-i),null!=t.worldCenter){const r=t.worldCenter;n=[.5*e-r[0]*i,.5*s+r[1]*i]}else n=[.5*e,.5*s];this.transform.translation=n}};var gt=class{constructor(){}renderPoint(t={}){const e=t.ctx,s=t.p;e.beginPath(),e.arc(s[0],s[1],3,0,2*Math.PI),e.fill()}};var wt=class{constructor(){}renderLine(t={}){const e=t.ctx,s=t.a,r=t.b;e.beginPath(),e.strokeStyle="red",e.lineWidth=5,e.moveTo(s[0],s[1]),e.lineTo(r[0],r[1]),e.closePath(),e.stroke()}};var yt={PointShader:gt,LineShader:wt,TriangleShader:class{constructor(){}renderTriangle(t={}){const e=t.ctx,s=t.a,r=t.b,n=t.c;e.save(),e.beginPath(),e.strokeStyle="black",e.moveTo(s[0],s[1]),e.lineTo(r[0],r[1]),e.lineTo(n[0],n[1]),e.closePath(),e.stroke(),e.restore()}}};const xt=pt,vt=yt;var Et=class{constructor(t={}){this.scene=t.scene,this.id=t.id,this.x=[],this.triangles=[],this.lines=[],this.pointShader=new vt.PointShader({}),this.lineShader=new vt.LineShader({}),this.triangleShader=new vt.TriangleShader({}),this.customAttributes={}}get pos(){return this.x}set pos(t){this.x=t}numVertices(){return this.pos.length}numTriangles(){return this.triangles.length}numLines(){return this.lines.length}setCustomAttribute(t,e){this.customAttributes[t]=e}getCustomAttribute(t){return this.customAttributes[t]}computeAABB(){let t=null,e=null,s=null,r=null;return this.pos.forEach((n=>{const i=n[0],o=n[1];(null==t||i<t)&&(t=i),(null==e||i>e)&&(e=i),(null==s||o<s)&&(s=o),(null==r||o>r)&&(r=o)})),new xt.AABB({x0:t,y0:s,x1:e,y1:r})}computeCenter(){let t=[0,0];const e=this.pos.length;for(let s=0;s<e;s++){const e=this.pos[s];xt.Vec2.add_(t,e)}return xt.Vec2.mulScalar_(t,1/e),t}};const St=Et;var bt=class{constructor(t={}){const e=t.headless??!1;if(this.headless=e,!e){const t=document.createElement("canvas");this.domElement=t,this.ctx=t.getContext("2d")}this.setSize({width:200,height:200})}setSize(t){const e=t.width;if(null==e)throw new Error("width required to setSize");const s=t.height;if(null==s)throw new Error("height required to setSize");let r=t.viewportWidth;null==r&&(r=e);let n=t.viewportHeight;if(null==n&&(n=s),this.width=e,this.height=s,this.viewportWidth=r,this.viewportHeight=n,!this.headless){const t=this.domElement;t.width=r,t.height=n,t.style.width=`${e}px`,t.style.height=`${s}px`}}renderPoint(t,e,s,r,n){const i=this.ctx;let o;if(!(e instanceof St))throw new Error("invalid mesh");o=e.pos[r];const l=s.transform.apply(o);i.save(),e.pointShader.renderPoint({ctx:i,renderer:t,mesh:e,camera:s,id:r,p:l,custom:n}),i.restore()}renderLine(t,e,s,r,n){const i=this.ctx,o=e.lines[r],l=s.transform.apply(e.pos[o[0]]),h=s.transform.apply(e.pos[o[1]]);i.save(),e.lineShader.renderLine({ctx:i,renderer:t,mesh:e,camera:s,id:r,a:l,b:h,custom:n}),i.restore()}renderTriangle(t,e,s,r,n){const i=this.ctx,o=e.triangles[r],l=o[0],h=o[1],a=o[2];let u,c,d;if(e.pos instanceof Float32Array){const t=2;u=[e.pos[l*t],e.pos[l*t+1]],c=[e.pos[h*t],e.pos[h*t+1]],d=[e.pos[a*t],e.pos[a*t+1]]}else u=e.pos[l],c=e.pos[h],d=e.pos[a];const p=s.transform.apply(u),m=s.transform.apply(c),f=s.transform.apply(d);i.save(),e.triangleShader.renderTriangle({ctx:i,renderer:t,mesh:e,camera:s,id:r,a:p,b:m,c:f,custom:n}),i.restore()}renderMesh(t,e,s,r={}){const n=e.sortedElements;if(null==n){for(let n=0;n<e.triangles.length;n++)this.renderTriangle(t,e,s,n,r);for(let n=0;n<e.lines.length;n++)this.renderLine(t,e,s,n,r);for(let n=0;n<e.pos.length;n++)this.renderPoint(t,e,s,n,r)}else n.forEach((n=>{if(null==n.order)throw new Error(`invalid element, order not defined ${n}`);if(1==n.order)this.renderPoint(t,e,s,n.id,r);else if(2==n.order)this.renderLine(t,e,s,n.id,r);else{if(3!=n.order)throw new Error(`invalid element ${n}`);this.renderTriangle(t,e,s,n.id,r)}}))}render(t,e,s={}){this.ctx.clearRect(0,0,this.viewportWidth,this.viewportHeight),t.meshes.forEach((t=>{this.renderMesh(this,t,e,s)}))}};const Ct=Et;var It={Camera:ft,Mesh:Et,Renderer:bt,Scene:class{constructor(){this.meshes=new Map}clean(){this.meshes=new Map}numMeshes(){return this.meshes.size}addMesh(){const t=this.meshes.size,e=new Ct({scene:this,id:t});return this.meshes.set(t,e),e}}};var At={computeDomCursor:function(t,e){let s,r;if(null==t.touches)s=t.clientX,r=t.clientY;else{if(0==t.touches.length)return null;const e=t.touches[0];s=e.clientX,r=e.clientY}let n=new DOMMatrix,i=e;for(;null!=i;){const t=window.getComputedStyle(i);n=new DOMMatrix(t.transform).multiply(n),i=i.parentElement}const o=n.inverse(),l=new DOMPointReadOnly(s,r).matrixTransform(o),h=e.getBoundingClientRect(),a=new DOMPointReadOnly(h.left,h.top).matrixTransform(o);return[l.x-a.x,l.y-a.y]}};const Tt=At;var Mt={cursorUtils:At,DragBehavior:class{constructor(t={}){this._dragging=!1,this.onDomCursorDown=t.onDomCursorDown,this.onDragProgress=t.onDragProgress,this.onDomCursorUp=t.onDomCursorUp,this.domElement=null}beginDrag(){this._dragging=!0}endDrag(){this._dragging=!1}dragging(){return this._dragging}domCursorDown(t,e){null!=this.onDomCursorDown&&this.onDomCursorDown(t,e)}domCursorMove(t,e){this.dragging()&&null!=this.onDragProgress&&this.onDragProgress(t,e)}domCursorUp(t,e){this.endDrag(),null!=this.onDomCursorUp&&this.onDomCursorUp(t,e)}linkToDom(t,e=null){if(null!=this.domElement)throw new Error("already linked to DOM");this.domElement=t;const s=e=>{e.preventDefault();const s=Tt.computeDomCursor(e,t);this.domCursorDown(s,e)};t.addEventListener("mousedown",s,{passive:!1}),t.addEventListener("touchstart",s,{passive:!1});const r=e=>{const s=Tt.computeDomCursor(e,t);this.domCursorMove(s,e)};null==e&&(e=t),e.addEventListener("mousemove",r,{passive:!1}),e.addEventListener("touchmove",r,{passive:!1});const n=e=>{const s=Tt.computeDomCursor(e,t);this.domCursorUp(s,e)};window.addEventListener("mouseup",n),window.addEventListener("touchend",n),window.addEventListener("touchcancel",n)}}};class zt{constructor(t={}){if(null==t.scene)throw new Error("scene required");const e=null==t.color?"rgba(0, 0, 0, 0.30)":t.color,s=this.mesh=t.scene.addMesh();this.set(t),s.setCustomAttribute("translation",[0,0]),s.pointShader.renderPoint=()=>{},s.lineShader.renderLine=zt.makeGridLineShader({color:e})}get numVertices(){return this.mesh.x.length}get numLines(){return this.mesh.lines.length}set(t={}){const e=null==t.cellSize?1:t.cellSize,s=null==t.innerCells?3:t.innerCells,r=null==t.rows?3:t.rows,n=null==t.cols?4:t.cols,i=null==t.x0?-2:t.x0,o=null==t.y0?0:t.y0,l=null==t.primaryLineWidth?.03:t.primaryLineWidth,h=null==t.secondaryLineWidth?.008:t.secondaryLineWidth,a=this.mesh,{x:u,lineIndices:c,lineWidths:d}=function(t={}){const e=null==t.cellSize?1:t.cellSize,s=null==t.innerCells?3:t.innerCells,r=null==t.rows?3:t.rows,n=null==t.cols?4:t.cols,i=null==t.x0?-2:t.x0,o=null==t.y0?0:t.y0,l=null==t.primaryLineWidth?.022:t.primaryLineWidth,h=null==t.secondaryLineWidth?.008:t.secondaryLineWidth,a=[],u=[],c=[],d=o+r*e,p=i+n*e;function m(t,e){for(let r=0;r<t+1;r++){const n=r==t?1:s;for(let t=0;t<n;t++){const s=2*u.length;e(r,t,n,a),u.push([s,s+1]),0==t?c.push(l):c.push(h)}}}return m(r,((t,s,r,n)=>{const l=s/r,h=(o+t*e)*(1-l)+(o+(t+1)*e)*l;n.push([i,h]),n.push([p,h])})),m(n,((t,s,r,n)=>{const l=s/r,h=(i+t*e)*(1-l)+(i+(t+1)*e)*l;n.push([h,o]),n.push([h,d])})),{x:a,lineIndices:u,lineWidths:c}}({cellSize:e,innerCells:s,rows:r,cols:n,x0:i,y0:o,primaryLineWidth:l,secondaryLineWidth:h});a.pos=u,a.lines=c,a.setCustomAttribute("lineWidths",d)}static makeGridLineShader(t={}){const e=null==t.color?"black":t.color;return t=>{const s=t.ctx,r=t.a,n=t.b,i=t.camera,o=t.mesh,l=i.inferScale();s.beginPath(),s.strokeStyle=e;const h=o.getCustomAttribute("lineWidths");if(null==h)throw new Error("custom attribute lineWidths missing");const a=h[t.id],u=o.getCustomAttribute("translation"),c=[l*u[0],l*u[1]];s.lineWidth=a*l,s.moveTo(r[0]+c[0],r[1]+c[1]),s.lineTo(n[0]+c[0],n[1]+c[1]),s.closePath(),s.stroke()}}}var _t=zt;var Vt={Grid:_t,Background:class{constructor(t={}){if(null==t.scene)throw new Error("scene required");const e=this.mesh=t.scene.addMesh();e.pos=[[0,0]];const s=null==t.color1?"#fcfcfc":t.color1,r=null==t.color2?"#d7d8d8":t.color2;e.pointShader.renderPoint=(t={})=>{const e=t.renderer.width,n=t.renderer.height,i=t.ctx,o=i.createRadialGradient(.5*e,.5*n,.05*e,.5*e,.5*n,.5*e);o.addColorStop(0,s),o.addColorStop(1,r),i.fillStyle=o,i.fillRect(0,0,e,n)}}}};var kt=class{constructor(t,e){if(null==t)throw new Error("id required to create simplex");this.order=e.length,this.id=t,this.vertexIds=e}};const $t=kt;function Lt(t){return t.sort(),t.join("_")}var Wt=class{constructor(t={}){if(null==t.order)throw new Error("order required");this.order=t.order,this.simplicesByHash=new Map}forEach(t){this.simplicesByHash.forEach(t)}size(){return this.simplicesByHash.size}has(t){return this.simplicesByHash.has(Lt(t.vertexIds))}add(t,e){let s=null;if(Array.isArray(t)){if(null==e)throw new Error("id required");s=t,t=new $t(e,s)}else{if(s=t.vertexIds,null==s)throw new Error(`vertexIds required ${t}`);e=t.id}if(s.length!=this.order)throw new Error(`expected ${this.order} vertices, found ${s.length}`);const r=Lt(s);return this.simplicesByHash.set(r,t),t}};const Dt=Wt;const Pt=Wt,Ft=class{constructor(t){this.id=t,this.edges=new Dt({order:2}),this.triangles=new Dt({order:3})}addTriangle(t,e){this.triangles.add(t,e)}addEdge(t,e){this.edges.add(t,e)}};var qt=class{constructor(t={}){this.vertices=new Map,this.edges=new Pt({order:2}),this.triangles=new Pt({order:3});(t.edges??[]).forEach(((t,e)=>{this.addEdge(e,t)}));(t.triangles??[]).forEach(((t,e)=>{this.addTriangle(e,t)}))}numVertices(){return this.vertices.size}numEdges(){return this.edges.size()}numTriangles(){return this.triangles.size()}getVertexById(t,e=!1){let s=this.vertices.get(t);return null==s&&e&&(s=new Ft(t),this.vertices.set(t,s)),s}addEdge(t,e){const s=this.edges.add(e,t);return e.forEach((t=>{this.getVertexById(t,!0).addEdge(s)})),s}addTriangle(t,e){const s=this.triangles.add(e,t);return e.forEach((t=>{this.getVertexById(t,!0).addTriangle(s)})),s}};const Bt=qt,Nt=Wt;var Rt={math:pt,ui:Mt,shaders:yt,background:Vt,sorted:{makeSortedElements:function(t={}){if(null==t.sortedVertexIds)throw new Error("sortedVertexIds required");if(null==t.triangles)throw new Error("triangles required");if(null==t.edges)throw new Error("edges required");const e=t.sortedVertexIds,s=new Map;e.forEach(((t,e)=>{s.set(t,e)}));const r=new Bt({triangles:t.triangles}),n=new Bt({edges:t.edges}),i=[],o=new Nt({order:3}),l=new Nt({order:2});return e.forEach((t=>{const e=r.getVertexById(t,!0).triangles,h=n.getVertexById(t,!0).edges,a=[];e.forEach((t=>{a.push(t)})),h.forEach((t=>{a.push(t)})),a.sort(((t,e)=>{const r=t.vertexIds.map((t=>s.get(t))),n=e.vertexIds.map((t=>s.get(t))),i=Math.max(...r),o=Math.max(...n);return i<o?1:i==o?0:-1})),a.forEach((t=>{if(2==t.order){const e=t;l.has(e)||(i.push(e),l.add(e))}else{const e=t;o.has(e)||(i.push(e),o.add(e))}})),i.push({order:1,id:t})})),i},MeshTopology:qt,Simplex:kt,Simplices:Wt},core:It,Renderer:It.Renderer,Camera:It.Camera,Scene:It.Scene};var Ot=class{constructor(t={}){this.targetCenterX=null,this.currentCenterX=null,this.active=!0,this.visibleWorldWidth=t.visibleWorldWidth??3.8,this.targetCenterY=t.targetCenterY??1,this.offsetX=t.offsetX??0}step(t={}){if(!this.active)return;const e=t.renderer,s=t.camera,r=t.mesh,n=t.floor,i=t.grid,o=r.computeCenter()[0]+this.offsetX;isNaN(o)||(this.targetCenterX=o),null==this.currentCenterX?this.currentCenterX=this.targetCenterX:this.currentCenterX+=.5*(this.targetCenterX-this.currentCenterX);const l=[this.currentCenterX,this.targetCenterY];s.center({worldCenter:l,worldWidth:this.visibleWorldWidth,viewportWidth:e.width,viewportHeight:e.height});const h=s.domToWorldSpace([e.width,0]),a=s.domToWorldSpace([0,e.height]),[u,c]=a,d=Math.floor(u)-1;let p=Math.floor(c);p<0&&(p=0);const[m,f]=h,g=m,w=g-d,y=f-p,x=Math.ceil(y)+1,v=Math.ceil(w)+1;i.set({x0:d,y0:p,rows:x,cols:v,innerCells:i.innerCells,primaryLineWidth:i.primaryLineWidth,secondaryLineWidth:i.secondaryLineWidth}),n.mesh.x=[[d,0],[g,0]]}};class Xt{constructor(t={}){if(null==t.scene)throw new Error("scene required");const e=this.scene=t.scene,s=this.mesh=e.addMesh();s.pos=[[-10,0],[10,0]],s.lines=[[0,1]],s.lineShader.renderLine=Xt.makeFloorLineShaderFunction({width:t.width,color:t.color}),s.pointShader.renderPoint=()=>{},s.setCustomAttribute("translation",[0,0])}static makeFloorLineShaderFunction(t={}){const e=t.width??.055,s=t.color??"black";return t=>{const r=t.ctx,n=t.a,i=t.b,o=t.camera,l=t.mesh,h=o.inferScale(),a=l.getCustomAttribute("translation"),u=[h*a[0],h*a[1]];r.strokeStyle=s,r.lineWidth=h*e,r.beginPath(),r.moveTo(n[0]+u[0],n[1]+u[1]),r.lineTo(i[0]+u[0],i[1]+u[1]),r.stroke()}}}const Ut=Rt,Gt=Ot,Ht=Xt;function jt(t){return t.sort(),t.join("_")}function Yt(t){if(7!=t.length)throw new Error(`invalid hex string ${t}`);if("#"!=t[0])throw new Error(`invalid hex string ${t}, expected #, found ${t[0]}`);t=t.substring(1);return[parseInt(t.substring(0,2),16),parseInt(t.substring(2,4),16),parseInt(t.substring(4,6),16)]}var Jt=class{constructor(t={}){if(null==t.system)throw new Error("system required");this.system=t.system;const e=t.sortedVertexIds;this.sortedVertexIds=e,null!=t.vertexDepths&&this.setSortedVertexIdsFromVertexDepths(t.vertexDepths);const s=t.headless??!1,r=new Ut.Renderer({headless:s});this.renderer=r,this.domElement=r.domElement,this.setSize({width:t.width??400,height:t.height??400});const n=new Ut.Scene;this.scene=n;const i=new Ut.Camera;this.camera=i;const o=t.borderColor??"black",l=o,h=t.fillColor??"white",a=t.gridColor??"#acadad";let u,c,d=t.activeMuscleColor??[255,0,0],p=t.inactiveMuscleColor??[250,190,190];"string"==typeof d&&(d=Yt(d)),"string"==typeof p&&(p=Yt(p)),null!=t.backgroundColor?(u=t.backgroundColor,c=t.backgroundColor):(u=t.backgroundCenterColor??"#fcfcfc",c=t.backgroundOuterColor??"#d7d8d8"),new Ut.background.Background({scene:n,color1:u,color2:c});const m=this.grid=new Ut.background.Grid({scene:n,x0:-3,y0:0,rows:4,cols:10,innerCells:2,primaryLineWidth:.022,secondaryLineWidth:.005,color:a});m.innerCells=2,m.primaryLineWidth=.022,m.secondaryLineWidth=.005,this.floor=new Ht({scene:n,color:l});const f=n.addMesh();this.mesh=f,f.pointShader.renderPoint=function(t={}){const e=t.radius??.028,s=t.borderColor??"black",r=t.fillColor??"white",n=t.borderWidth??.023;return t=>{const i=t.ctx,o=t.p,l=t.camera.inferScale(),h=(e+n)*l;i.fillStyle=s,i.beginPath(),i.arc(o[0],o[1],h,0,2*Math.PI),i.fill();const a=e*l;i.fillStyle=r,i.beginPath(),i.arc(o[0],o[1],a,0,2*Math.PI),i.fill()}}({borderColor:o,fillColor:h}),f.triangleShader.renderTriangle=(t={})=>{const e=t.ctx,s=t.a,r=t.b,n=t.c;e.beginPath(),e.fillStyle=h,e.moveTo(...s),e.lineTo(...r),e.lineTo(...n),e.closePath(),e.fill()},f.lineShader.renderLine=(t={})=>{const e=t.ctx,s=t.a,r=t.b,n=t.camera.inferScale(),i=t.mesh.getCustomAttribute("lineIdToMuscleId")[t.id];if(null==i){const t=.029;e.beginPath(),e.lineJoin="round",e.lineCap="round",e.strokeStyle=o,e.lineWidth=t*n,e.moveTo(s[0],s[1]),e.lineTo(r[0],r[1]),e.closePath(),e.stroke()}else{const t=d,l=p,h=.065,a=.017,u="butt",c="muscleIntensity";e.beginPath(),e.lineCap=u,e.strokeStyle=o,e.lineWidth=(h+2*a)*n,e.moveTo(s[0],s[1]),e.lineTo(r[0],r[1]),e.stroke(),e.beginPath();const m=f.getCustomAttribute(c);if(null==m)throw new Error(`muscle intensity attribute (${c}) not found, call setCustomAttribute("${c}", value) before rendering.`);if(!Array.isArray(m))throw new Error("muscle intensity attribute must be an array with values for each fiber, found "+typeof m);const g=m[i],w=(1-g)*t[0]+g*l[0],y=(1-g)*t[1]+g*l[1],x=(1-g)*t[2]+g*l[2];e.strokeStyle=`rgb(${w}, ${y}, ${x})`,e.lineCap=u,e.lineWidth=h*n,e.moveTo(s[0],s[1]),e.lineTo(r[0],r[1]),e.stroke()}};if(t.draggable??!0){const e=this.dragBehavior=new Ut.ui.DragBehavior({onDomCursorDown:(t,s)=>{if("button"in s&&0!=s.button)return;const r=this.system,n=i.domToWorldSpace(t),o=this.hitTestVertex(n);null!=o&&(this.fixVertex(o),e.beginDrag(),this.setVertexPos(r.fixedVertexId,[n[0],Math.max(0,n[1])]))},onDragProgress:t=>{const e=this.system,s=i.domToWorldSpace(t);this.setVertexPos(e.fixedVertexId,[s[0],Math.max(0,s[1])])},onDomCursorUp:()=>{this.freeVertex()}});if(!s){const s=t.domElementForMoveEvents??null;e.linkToDom(r.domElement,s)}}this.tracker=new Gt}setSortedVertexIdsFromVertexDepths(t){if(t.length!=this.system.numVertices)throw new Error(`invalid size for depths, found ${t.length}, expected ${this.system.numVertices}`);const e=t.map(((t,e)=>({depth:t,index:e})));e.sort(((t,e)=>e.depth-t.depth));const s=e.map((t=>t.index));this.sortedVertexIds=s}setSize(t={}){this.renderer.setSize({width:t.width,height:t.height})}render(){if(null==this.needsMeshUpdate||this.needsMeshUpdate){const t=[];if(null!=this.system.triangles){const e=this.system.triangles.u32();for(let s=0;s<this.system.numTriangles;s++){const r=3*s;t.push([e[r],e[r+1],e[r+2]])}}const e=[];if(null!=this.system.muscles){const t=this.system.muscles.u32();for(let s=0;s<this.system.numMuscles;s++){const r=2*s;e.push([t[r],t[r+1]])}}this._updateMesh({triangles:t,muscles:e}),this.needsMeshUpdate=!1}const t=this.renderer,e=this.scene,s=this.camera,r=this.mesh;this._updateFromSystem(),null!=this.dragBehavior&&this.dragBehavior.dragging()||this.tracker.step({mesh:r,camera:s,floor:this.floor,grid:this.grid,renderer:this.renderer}),t.render(e,s)}_updateMesh(t){const e=this.mesh;null!=t.pos&&(e.pos=t.pos),e.triangles=t.triangles,e.lines=function(t){const e=new Map;function s(t,s){const r=jt([t,s]);e.set(r,[t,s])}return t.forEach((t=>{s(t[0],t[1]),s(t[1],t[2]),s(t[0],t[2])})),Array.from(e.values())}(t.triangles),Array.prototype.push.apply(e.lines,t.muscles);const s=new Map;if(null!=this.system.muscles){const t=this.system.muscles.u32();for(let e=0;e<this.system.numMuscles;e++){const r=2*e,n=[t[r],t[r+1]];s.set(jt(n),e)}}const r=[];e.setCustomAttribute("lineIdToMuscleId",r),e.lines.forEach((t=>{const e=jt(t),n=s.get(e);r.push(n)}));let n=this.sortedVertexIds;if(null==n){n=[];for(let t=0;t<this.system.numVertices;t++)n.push(t)}if(n.length!=this.system.numVertices)throw new Error(`invalid size for sortedVertexIds, found ${n.length}, expected ${this.system.numVertices}`);e.sortedElements=Ut.sorted.makeSortedElements({sortedVertexIds:n,triangles:e.triangles,edges:e.lines});const i=[],o=this.system.numMuscles;for(let t=0;t<o;t++)i.push(1);e.setCustomAttribute("muscleIntensity",i)}_updateFromSystem(){this._updateVertexPositionsFromSystem(),this._updateMuscleIntensityFromSystem()}_updateVertexPositionsFromSystem(){const t=this.mesh,e=this.system;if(0==e.numVertices)t.pos=[];else{const s=e.pos.toArray();t.pos=s}}_updateMuscleIntensityFromSystem(){const t=this.mesh,e=this.system,s=[],r=e.numMuscles;if(r>0){const t=e.a.slot.f32();for(let e=0;e<r;e++)s.push(t[e])}t.setCustomAttribute("muscleIntensity",s)}hitTestVertex(t,e=.31){const s=this.system.numVertices;if(0==s)return null;const r=this.system.pos.slot.f32();let n=null,i=1/0;const o=e*e;for(let e=0;e<s;e++){const s=2*e,l=[r[s],r[s+1]],h=Ut.math.Vec2.sub(l,t),a=Ut.math.Vec2.quadrance(h);a<o&&a<i&&(n=e,i=a)}return n}setVertexPos(t,e){const s=this.system.pos.slot.f32(),r=2*t;s[r]=e[0],s[r+1]=e[1]}setVertexVel(t,e){const s=this.system.vel.slot.f32(),r=2*t;s[r]=e[0],s[r+1]=e[1]}fixVertex(t){const e=this.system;this.setVertexVel(t,[0,0]),null==t&&(t=-1),e.fixedVertexId=t}freeVertex(){this.system.fixedVertexId=-1}};return t({System:tt,mmgrten:Q,SystemViewport:{SystemViewport:Jt}.SystemViewport,mm2d:Rt})}));
