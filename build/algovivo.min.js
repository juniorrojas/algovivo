/**
 * algovivo
 * (c) 2023 Junior Rojas
 * License: MIT
 */
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?module.exports=e():"function"==typeof define&&define.amd?define(e):(t="undefined"!=typeof globalThis?globalThis:t||self).algovivo=e()}(this,(function(){"use strict";function t(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}class e{constructor(t,e){this.list=t,this.data=e,this.next=null,this.prev=null}append(t){const s=new e(this.list,t);return this.list.last==this&&(this.list.last=s),s.next=this.next,s.prev=this,null!=this.next&&(this.next.prev=s),this.next=s,this.list.size++,s}prepend(t){const s=new e(this.list,t);return this.list.first==this&&(this.list.first=s),s.next=this,s.prev=this.prev,null!=this.prev&&(this.prev.next=s),this.prev=s,this.list.size++,s}remove(){null!=this.prev&&(this.prev.next=this.next),null!=this.next&&(this.next.prev=this.prev),this.list.first==this&&(this.list.first=this.next),this.list.last==this&&(this.list.last=this.prev),this.list.size--,this.next=null,this.prev=null}}var s=e;const r=s;class n{constructor(t){this.list=t,this.nextNode=this.list.first}next(){if(null==this.nextNode)return{done:!0};{const t={done:!1,value:this.nextNode.data};return this.nextNode=this.nextNode.next,t}}}class i{constructor(){this.first=null,this.last=null,this.size=0}isEmpty(){if(null==this.first&&null!=this.last||null!=this.first&&null==this.last)throw Error("inconsistent first last state");return null==this.first}append(t){return this.isEmpty()?this.setSingleton(t):this.last.append(t)}prepend(t){return this.isEmpty()?this.setSingleton(t):this.first.prepend(t)}setSingleton(t){const e=new r(this,t);return this.first=e,this.last=e,this.size=1,e}iter(){return new n(this)}*[Symbol.iterator](){const t=this.iter();let e=t.next();for(;!e.done;)yield e.value,e=t.next()}}var o,h,l,a,u,c;function d(){if(h)return o;h=1;const t=p();return o=class extends t{constructor(t={}){super(t)}isFree(){return!1}free(){let t=this.appendFree(this.ptr,this.size);this.remove();const e=t.prev(),s=t.next();return null!=e&&e.isFree()&&(t=e.merge(t)),null!=s&&s.isFree()&&(t=t.merge(s)),t}}}function p(){if(a)return l;a=1;return l=class{constructor(t={}){this.manager=t.manager,this.ptr=t.ptr,this.size=t.size,this.node=t.node}numBytes(){return this.size}prev(){const t=this.node.prev;return null!=t?t.data:null}next(){const t=this.node.next;return null!=t?t.data:null}appendReserved(t,e){const s=d(),r=this.node.append(null),n=new s({manager:this.manager,ptr:t,size:e,node:r});return r.data=n,this.manager._addReservedSlot(n),n}appendFree(t,e){const s=m(),r=this.node.append(null),n=new s({manager:this.manager,ptr:t,size:e,node:r});return r.data=n,this.manager._addFreeSlot(n),n}remove(){this.node.remove(),this.node.data=null,this.node=null,this.isFree()?this.manager._removeFreeSlot(this):this.manager._removeReservedSlot(this)}toTypedArray(t){const e=this.size,s=t.BYTES_PER_ELEMENT;if(e%s!=0)throw new Error(`size in bytes must be a multiple of ${s}, found ${e}`);const r=this.ptr;return new t(this.manager.array,r,e/s)}f32(){return this.toTypedArray(Float32Array)}u32(){return this.toTypedArray(Uint32Array)}},l}function m(){if(c)return u;c=1;const t=p();return u=class extends t{constructor(t={}){super(t)}isFree(){return!0}reserve(t){const e=this.numBytes();if(t>e)throw new Error(`cannot reserve ${t} bytes, only ${e} bytes are available`);const s=this.appendReserved(this.ptr,t);return s.appendFree(this.ptr+t,e-t),this.remove(),s}merge(t){if(!this.isFree()||!t.isFree())throw new Error("only free slots can be merged");if(this.next()!=t)throw new Error("only adjacent slots can be merged");const e=t.appendFree(this.ptr,this.size+t.size);return this.remove(),t.remove(),e}}}const f={List:i,Node:s},g=m();var w={MemoryManager:class{constructor(t,e){this.array=t,null==e&&(e=0),this.ptrToSlot=new Map,this.slots=new f.List,this.freeSlots=new f.List,this.reservedSlots=new f.List;const s=new g({manager:this,ptr:e,size:t.byteLength-e}),r=this.slots.append();r.data=s,s.node=r;const n=this.freeSlots.append();n.data=s,s.freeNode=n}numReservedSlots(){return this.reservedSlots.size}numFreeSlots(){return this.freeSlots.size}numFreeBytes(){let t=0;const e=this.freeSlots.iter();let s=e.next();for(;!s.done;){t+=s.value.size,s=e.next()}return t}numReservedBytes(){let t=0;const e=this.reservedSlots.iter();let s=e.next();for(;!s.done;){t+=s.value.size,s=e.next()}return t}mallocBytes(t){return this._malloc(t)}malloc32(t){return this.mallocBytes(4*t)}_addReservedSlot(t){const e=this.reservedSlots.append(t);t.reservedNode=e}_removeReservedSlot(t){if(null==t.reservedNode)throw new Error("reservedNode cannot be null");t.reservedNode.remove()}_addFreeSlot(t){const e=this.freeSlots.append(t);t.freeNode=e}_removeFreeSlot(t){if(null==t.freeNode)throw new Error("freeNode cannot be null");t.freeNode.remove()}_malloc(t){if(!Number.isInteger(t))throw new Error(`expected integer, found ${t}`);let e=null;const s=this.freeSlots.iter();let r=s.next();for(;!r.done;){const n=r.value;if(n.size>=t){e=n;break}r=s.next()}if(null==e)throw new Error("no valid free slot available");return e.reserve(t)}malloc(t){const e=this._malloc(t);return this.ptrToSlot.set(e.ptr,e),e.ptr}free(t){this.ptrToSlot.get(t).free()}},FreeSlot:m(),ReservedSlot:d()};class x{constructor(t={}){const e=t.engine;if(null==e)throw new Error("engine required to create IntTuple");this.engine=e;const s=t.slot;if(null==s)throw new Error("slot required to create IntTuple");this.slot=s,this.ptr=s.ptr,this.length=t.length}forEach(t){for(let e=0;e<this.length;e++)t(this.get(e),e)}equal(t){if(t instanceof x){for(let e=0;e<this.length;e++){if(this.get(e)!=t.get(e))return!1}return!0}if(Array.isArray(t)){for(let e=0;e<this.length;e++){if(this.get(e)!=t[e])return!1}return!0}return!1}toString(){return this.slot.u32().toString()}toArray(){const t=[];return this.forEach((e=>{t.push(e)})),t}typedArray(){return this.slot.u32()}set(t,e){this.typedArray()[t]=e}get(t){return this.typedArray()[t]}dispose(){this.slot.free()}}var y=x;function v(t,e,s,r){if(e==s.length-1)for(let n=0;n<s[e];n++)t.push(r);else for(let n=0;n<s[e];n++){const n=[];t.push(n),v(n,e+1,s,r)}}var S={inferShape:function(t){const e=[];let s=t;for(;Array.isArray(s);)e.push(s.length),s=s[0];return e},makeNdArray:function(t,e){let s=t;t instanceof y&&(s=t.toArray());const r=[];return v(r,0,s,e),r},numelOfShape:function(t){let e=1;return t.forEach((t=>{e*=t})),e},getArrElem:function t(e,s){if(!Array.isArray(s))throw new Error(`expected array, found ${typeof s}: ${s}`);return 0==s.length?e:t(e[s[0]],s.slice(1))},setArrElem:function t(e,s,r){if(!Array.isArray(s))throw new Error(`expected array, found ${typeof s}: ${s}`);if(1!=s.length)return t(e[s[0]],s.slice(1),r);e[s]=r}};const E=y;class b{constructor(t){if(null==t)throw new Error("shape required");if(!(t instanceof E))throw new Error(`IntTuple shape expected, found ${typeof t}: shape`);this.shape=t,this.done=!1,this.idx=[],t.forEach((t=>{this.idx.push(0)}))}next(){const t=this.shape;for(let e=0;e<t.length;e++){const s=t.length-1-e;if(this.idx[s]<t.get(s)-1)return void this.idx[s]++;if(0==s)return void(this.done=!0);this.idx[s]=0}}static shapeForEach(t,e){const s=new b(t);for(;!s.done;)e(s.idx),s.next()}}const C=S,A=b,T=y;class I{constructor(t={}){const e=t.engine;if(null==e)throw new Error("engine required to create tensor");this.engine=e;const s=t.shape;if(null==s)throw new Error("shape required to create tensor");if(s instanceof T)this.shape=s;else{if(!Array.isArray(s))throw new Error(`invalid shape type ${typeof s}: ${s}`);this.shape=e.intTuple(s)}this.order=this.shape.length;const r=C.numelOfShape(this.shape);this.numel=r;const n=t.slot;if(r>0&&null==n)throw new Error("memory slot required to create tensor");this.slot=t.slot,this.ptr=this.slot.ptr;const i=t.stride;if(null!=i){if(!(i instanceof T))throw new Error(`expected IntTuple stride, found ${typeof i}: ${i}`);this.stride=i}else this.setDefaultStride()}get wasmInstance(){return this.engine.wasmInstance}isScalar(){return 0==this.order}fill_(t){this.wasmInstance.exports.fill_(this.numel,this.ptr,t)}clamp_(t={}){const e=t.min,s=t.max;this.wasmInstance.exports.clamp(this.numel,this.ptr,this.ptr,e,s,null!=e,null!=s)}zero_(){this.fill_(0)}flattenIdx(t){let e,s,r=!1;if(Array.isArray(t)&&(e=this.engine.intTuple(t),r=!0),!(e instanceof T))throw new Error(`cannot handle ${typeof e}: ${e}`);return s=this.engine.wasmInstance.exports.flatten_idx(this.order,e.slot.ptr,this.stride.slot.ptr),r&&e.dispose(),s}typedArray(){return this.slot.f32()}toArray(){if(0==this.numel)return[];const t=C.makeNdArray(this.shape,0);return this.forEach((e=>{const s=this.get(e);C.setArrElem(t,e,s)})),t}get(t){const e=this.flattenIdx(t);return this.typedArray()[e]}item(){if(!this.isScalar())throw new Error(`item() only works for scalars, found tensor with shape ${this.shape}`);return this.get([0])}setDefaultStride(){let t=1;const e=this.order,s=[];for(let t=0;t<e;t++)s.push(0);for(let r=0;r<e;r++){const n=e-1-r;s[n]=t,t*=this.shape.get(n)}this.stride=this.engine.intTuple(s)}setFromArray(t){if(0==this.numel)return;if(this.isScalar()){if("number"!=typeof t)throw new Error(`expected number, found ${typeof t}: ${t}`);this.set([0],t)}else{if(!Array.isArray(t))throw new Error(`expected array, found ${typeof t}: ${t}`);const e=C.inferShape(t);if(!this.shape.equal(e))throw new Error(`inconsistent shapes ${e} != ${this.shape}`);this.forEach((e=>{const s=C.getArrElem(t,e);this.set(e,s)}))}}set(t,e){if(null==e&&Array.isArray(t))this.setFromArray(t);else{const s=this.flattenIdx(t);this.typedArray()[s]=e}}forEach(t){A.shapeForEach(this.shape,t)}squeeze(t){-1==t&&(t=this.shape.length-1);const e=this.shape.get(t);if(1!=e)throw new Error(`cannot squeeze a dimension that is not equal to 1, shape[${t}] = ${e}`);const s=[];for(let e=0;e<this.order;e++)t!=e&&s.push(this.shape.get(e));return new I({engine:this.engine,shape:s,slot:this.slot})}unsqueeze(t){-1==t&&(t=this.shape.length-1);const e=[];for(let s=0;s<this.order;s++)e.push(this.shape.get(s)),t==s&&e.push(1);return new I({engine:this.engine,shape:e,slot:this.slot})}add(t,e){this.engine.functional.add(this,t,e)}sum(t){this.engine.wasmInstance.exports.sum(this.numel,this.slot.ptr,t.slot.ptr)}dispose(){this.slot.free(),this.shape.dispose(),this.stride.dispose()}}var z=I;var _=class{constructor(t={}){const e=this.engine=t.engine;this.wasmInstance=e.wasmInstance}matvec(t,e,s){const r=t.shape.get(0),n=t.shape.get(1),i=e.shape.get(0),o=s.shape.get(0);if(r!=o)throw new Error(`inconsistent output size ${r} != ${o}`);if(n!=i)throw new Error(`inconsistent input size ${n} != ${i}`);this.wasmInstance.exports.matvec(r,n,t.stride.ptr,t.ptr,e.stride.ptr,e.ptr,s.stride.ptr,s.ptr)}mm(t,e,s){const r=t.shape.get(0),n=t.shape.get(1),i=e.shape.get(1);this.wasmInstance.exports.mm(r,n,i,t.stride.ptr,t.ptr,e.stride.ptr,e.ptr,s.stride.ptr,s.ptr)}relu(t,e){this.wasmInstance.exports.relu(t.numel,t.ptr,e.ptr)}tanh(t,e){const s=t.numel,r=t.typedArray(),n=e.typedArray();for(let t=0;t<s;t++)n[t]=Math.tanh(r[t])}add(t,e,s){this.wasmInstance.exports.add(t.numel,t.ptr,e.ptr,s.ptr)}sum(t,e){this.wasmInstance.exports.sum(t.numel,t.ptr,e.ptr)}sumBackward(t,e,s,r){this.wasmInstance.exports.sum_backward(t.numel,t.ptr,e.ptr,s.ptr,r.ptr)}};var M=class{constructor(){}};const $=M;var V=class extends ${constructor(t,e){super(),this.nn=t,this.layers=e}forward(t){let e=t;return this.layers.forEach((t=>{e=t.forward(e)})),e}dispose(){this.layers.forEach((t=>{t.dispose()}))}};const L=M;var k=class extends L{constructor(t,e,s){super(),this.nn=t,this.inputSize=e,this.outputSize=s;const r=this.nn.engine;this.weight=r.zeros([s,e]),this.bias=r.zeros([s]),this.output=r.zeros([s])}forward(t){const e=this.nn.engine.functional;return e.matvec(this.weight,t,this.output),e.add(this.output,this.bias,this.output),this.output}dispose(){this.weight.dispose(),this.bias.dispose(),this.output.dispose()}};const W=M;var P=class extends W{constructor(t){super(),this.nn=t,this.output=null}forward(t){const e=this.nn.engine;return null==this.output&&(this.output=e.zerosLike(t)),e.functional.relu(t,this.output),this.output}dispose(){null!=this.output&&this.output.dispose()}};const D=M;var F=class extends D{constructor(t){super(),this.nn=t,this.output=null}forward(t){const e=this.nn.engine;return null==this.output&&(this.output=e.zerosLike(t)),e.functional.tanh(t,this.output),this.output}dispose(){null!=this.output&&this.output.dispose()}};const q=V,B=k,N=P,R=F;var X=class{constructor(t={}){this.engine=t.engine}Linear(t,e){return new B(this,t,e)}ReLU(){return new N(this)}Tanh(){return new R(this)}Sequential(){const t=Array.from(arguments);return new q(this,t)}};const U=w,G=S,O=z,H=y,j=_,Y=X;const J=class{constructor(t={}){if(null==t.wasmInstance)throw new Error("wasmInstance required");this.wasmInstance=t.wasmInstance;const e=t.wasmInstance.exports.memory.buffer,s=new U.MemoryManager(e,t.wasmInstance.exports.__heap_base);this.mgr=s,this.functional=this.F=new j({engine:this}),this.nn=new Y({engine:this}),this._mergeF()}_mergeF(){Object.getOwnPropertyNames(Object.getPrototypeOf(this.F)).forEach((t=>{"constructor"!=t&&(this[t]=this.F[t])}))}tensor(t){const e=G.inferShape(t),s=this.intTuple(e),r=G.numelOfShape(e),n=this.mgr.malloc32(r),i=new O({engine:this,shape:s,slot:n});return i.setFromArray(t),i}intTuple(t){if(!Array.isArray(t))throw new Error(`expected array, found ${typeof t}: ${t}`);const e=t.length,s=this.mgr.malloc32(e),r=new H({engine:this,length:e,slot:s});for(let s=0;s<e;s++)r.set(s,t[s]);return r}zerosLike(t){if(!(t instanceof O))throw new Error(`expected tensor, found ${typeof t}: ${t}`);return this.zeros(t.shape.toArray())}empty(t){let e;if(t instanceof H)e=t;else{if(!Array.isArray(t))throw new Error(`expected array, found ${typeof t}: ${t}`);e=this.intTuple(t)}const s=G.numelOfShape(e),r=this.mgr.malloc32(s);return new O({engine:this,shape:e,slot:r})}zeros(t){const e=this.empty(t);return e.zero_(),e}ones(t){const e=this.empty(t);return e.fill_(1),e}};var K={engine:function(t={}){return new J({wasmInstance:t.wasmInstance})},Engine:J,Tensor:z,mmgr:w,utils:S};const Q=K;var Z=class{constructor(t={}){if(null==t.wasmInstance)throw new Error("wasmInstance required");const e=new Q.Engine({wasmInstance:t.wasmInstance});this.ten=e;const s=e.wasmInstance,r=e.mgr;this.wasmInstance=s,this.memoryManager=r,this.fixedVertexId=-1,this.vertexMass=t.vertexMass??6.0714287757873535;this.h=.033,this.spaceDim=2}numVertices(){return null==this.x0?0:this.x0.shape.get(0)}numTriangles(){return null==this.triangles?0:this.triangles.u32().length/3}numSprings(){return null==this.springs?0:this.springs.u32().length/2}setX(t){const e=this.ten,s=this.spaceDim,r=t.length,n=e.tensor(t);null!=this.x0&&this.x0.dispose(),this.x0=n;const i=e.zeros([r,s]);null!=this.x1&&this.x1.dispose(),this.x1=i;const o=e.zeros([r,s]);null!=this.v0&&this.v0.dispose(),this.v0=o;const h=e.zeros([r,s]);null!=this.v1&&this.v1.dispose(),this.v1=h,this.updateTmpBuffers()}setSprings(t={}){if(null==t.indices)throw new Error("indices required");const e=t.indices,s=e.length,r=this.numSprings(),n=this.memoryManager,i=this.ten,o=n.malloc32(2*s);null!=this.springs&&this.springs.free(),this.springs=o;const h=o.u32();if(e.forEach(((t,e)=>{const s=2*e;h[s]=t[0],h[s+1]=t[1]})),null!=this.l0&&this.l0.dispose(),this.l0=null,0!=s){const e=i.zeros([s]);this.l0=e,null==t.l0?this.wasmInstance.exports.l0_of_x(this.numVertices(),this.x0.ptr,s,this.springs.ptr,this.l0.ptr):this.l0.set(t.l0)}const l=t.keepA??!1;if(s!=r){if(l)throw new Error(`keepA can only be true when the number of springs is the same (${s} != ${r})`);if(null!=this.a&&this.a.dispose(),0!=s){const t=i.zeros([s]);this.a=t,t.fill_(1)}}else 0==s?(null!=this.a&&this.a.dispose(),this.a=null):l||this.a.fill_(1)}setTriangles(t={}){if(null==t.indices)throw new Error("indices required");const e=t.indices,s=e.length,r=this.memoryManager,n=this.ten,i=r.malloc32(3*s);null!=this.triangles&&this.triangles.free(),this.triangles=i;const o=i.u32();e.forEach(((t,e)=>{const s=3*e;o[s]=t[0],o[s+1]=t[1],o[s+2]=t[2]}));const h=n.zeros([s,2,2]);null!=this.rsi&&this.rsi.dispose(),this.rsi=h,null==t.rsi?this.wasmInstance.exports.rsi_of_x(this.numVertices(),this.x0.ptr,s,this.triangles.ptr,this.rsi.ptr):this.rsi.set(t.rsi)}set(t){this.setX(t.x),this.r=null,this.setSprings({indices:t.springs??[],l0:t.springsL0}),this.setTriangles({indices:t.triangles??[],rsi:t.trianglesRsi})}updateTmpBuffers(){if(null==this.x0)throw new Error("x0 required");const t=this.numVertices(),e=this.spaceDim,s=this.ten,r=s.zeros([t,e]);null!=this.xGrad&&this.xGrad.dispose(),this.xGrad=r;const n=s.zeros([t,e]);null!=this.xTmp&&this.xTmp.dispose(),this.xTmp=n}step(){const t=this.numVertices(),e=this.numSprings(),s=this.numTriangles(),r=this.fixedVertexId,n=this.vertexMass;this.wasmInstance.exports.backward_euler_update(t,0==t?0:this.x1.ptr,0==t?0:this.xGrad.ptr,0==t?0:this.xTmp.ptr,0==t?0:this.x0.ptr,0==t?0:this.v0.ptr,0==t?0:this.v1.ptr,this.h,0,e,0==e?0:this.springs.ptr,s,0==s?0:this.triangles.ptr,0==s?0:this.rsi.ptr,0==e?0:this.a.ptr,0==e?0:this.l0.ptr,r,n),0!=t&&(this.x0.slot.f32().set(this.x1.slot.f32()),this.v0.slot.f32().set(this.v1.slot.f32()))}dispose(){null!=this.x0&&(this.x0.dispose(),this.x0=null),null!=this.x1&&(this.x1.dispose(),this.x1=null),null!=this.xGrad&&(this.xGrad.dispose(),this.xGrad=null),null!=this.xTmp&&(this.xTmp.dispose(),this.xTmp=null),null!=this.v0&&(this.v0.dispose(),this.v0=null),null!=this.v1&&(this.v1.dispose(),this.v1=null),null!=this.triangles&&(this.triangles.free(),this.triangles=null),null!=this.rsi&&(this.rsi.dispose(),this.rsi=null),null!=this.springs&&(this.springs.free(),this.springs=null),null!=this.l0&&(this.l0.dispose(),this.l0=null),null!=this.a&&(this.a.dispose(),this.a=null)}};var tt=class{constructor(t={}){this.targetCenterX=null,this.currentCenterX=null,this.active=!0,this.visibleWorldWidth=t.visibleWorldWidth??3.8}step(t={}){if(!this.active)return;const e=t.renderer,s=t.camera,r=t.mesh,n=t.floor,i=t.grid,o=r.computeCenter()[0];isNaN(o)||(this.targetCenterX=o),null==this.currentCenterX?this.currentCenterX=this.targetCenterX:this.currentCenterX+=.5*(this.targetCenterX-this.currentCenterX);const h=[this.currentCenterX,1];s.center({worldCenter:h,worldWidth:this.visibleWorldWidth,viewportWidth:e.width,viewportHeight:e.height});const l=s.domToWorldSpace([e.width,0]),a=s.domToWorldSpace([0,e.height]),[u,c]=a,d=Math.floor(u)-1;let p=Math.floor(c);p<0&&(p=0);const[m,f]=l,g=m,w=g-d,x=f-p,y=Math.ceil(x)+1,v=Math.ceil(w)+1;i.set({x0:d,y0:p,rows:y,cols:v,innerCells:i.innerCells,primaryLineWidth:i.primaryLineWidth,secondaryLineWidth:i.secondaryLineWidth}),n.mesh.x=[[d,0],[g,0]]}};function et(t){return[t[0],t[1]]}function st(t,e){t[0]*=e,t[1]*=e}function rt(t,e){const s=et(t);return st(s,e),s}function nt(t){return t[0]*t[0]+t[1]*t[1]}function it(t){return Math.sqrt(nt(t))}var ot={clone:et,add:function(t,e){return[t[0]+e[0],t[1]+e[1]]},add_:function(t,e){t[0]+=e[0],t[1]+=e[1]},mulScalar_:st,mulScalar:rt,sub:function(t,e){return[t[0]-e[0],t[1]-e[1]]},quadrance:nt,norm:it,normalize:function(t){return rt(t,1/it(t))},dot:function(t,e){return t[0]*e[0]+t[1]*e[1]}};class ht{constructor(t,e,s,r){this.m00=t,this.m01=e,this.m10=s,this.m11=r}get(t,e){return this[`m${t}${e}`]}set(t,e,s,r){this.m00=t,this.m01=e,this.m10=s,this.m11=r}toArray(){return[[this.m00,this.m01],[this.m10,this.m11]]}negate(){return new ht(-this.m00,-this.m01,-this.m10,-this.m11)}apply(t){return[this.m00*t[0]+this.m01*t[1],this.m10*t[0]+this.m11*t[1]]}det(){return this.m00*this.m11-this.m10*this.m01}inv(){const t=this.det();return new ht(this.m11/t,-this.m01/t,-this.m10/t,this.m00/t)}mm(t){const e=this.m00,s=this.m01,r=this.m10,n=this.m11,i=t.m00,o=t.m01,h=t.m10,l=t.m11;return new ht(e*i+s*h,e*o+s*l,r*i+n*h,r*o+n*l)}t(){return new ht(this.m00,this.m10,this.m01,this.m11)}static fromArray(t){return new ht(t[0][0],t[0][1],t[1][0],t[1][1])}}var lt=ht;const at=lt,ut=ot;class ct{constructor(){this.translation=[0,0],this.linear=new at(1,0,0,1)}inferScale(){return this.linear.m00}apply(t){return ut.add(this.linear.apply(t),this.translation)}inv(){const t=new ct;return t.linear=this.linear.inv(),t.translation=t.linear.negate().apply(this.translation),t}toColumnMajorArray(){return[this.linear.get(0,0),this.linear.get(1,0),this.linear.get(0,1),this.linear.get(1,1),this.translation[0],this.translation[1]]}}var dt=ct;var pt={Vec2:ot,Matrix2x2:lt,Transform2d:dt,AABB:class{constructor(t={}){if(null==t.x0)throw new Error("x0 required");if(null==t.y0)throw new Error("y0 required");this._x0=t.x0,this._y0=t.y0;let e=null;if(null!=t.width)e=this._x0+t.width;else{if(null==t.x1)throw new Error("x1 required");e=t.x1}this._x1=e;let s=null;if(null!=t.height)s=this._y0+t.height;else{if(null==t.y1)throw new Error("y1 required");s=t.y1}this._y1=s}get x0(){return this._x0}get x1(){return this._x1}get y0(){return this._y0}get y1(){return this._y1}get width(){return this._x1-this._x0}get height(){return this._y1-this._y0}get center(){return[.5*(this.x0+this.x1),.5*(this.y0+this.y1)]}}};const mt=pt;var ft=class{constructor(){this.transform=new mt.Transform2d}domToWorldSpace(t){if(!Array.isArray(t))throw new Error("array expected, found "+typeof t);if(2!=t.length)throw new Error(`array with 2 elements expected, found ${t.length}`);return this.transform.inv().apply(t)}inferScale(){return this.transform.inferScale()}center(t){let e,s=t.zoom?t.zoom:1,r=t.viewportWidth,n=t.viewportHeight;if(null!=t.renderer&&(r=t.renderer.width,n=t.renderer.height),null!=t.worldWidth){if(null==r)throw new Error("viewportWidth required");s=r/t.worldWidth}if(this.transform.linear=new mt.Matrix2x2(s,0,0,-s),null!=t.worldCenter){const i=t.worldCenter;e=[.5*r-i[0]*s,.5*n+i[1]*s]}else e=[.5*r,.5*n];this.transform.translation=e}};var gt=class{constructor(){}renderPoint(t={}){const e=t.ctx,s=t.p;e.beginPath(),e.arc(s[0],s[1],3,0,2*Math.PI),e.fill()}};var wt=class{constructor(){}renderLine(t={}){const e=t.ctx,s=t.a,r=t.b;e.beginPath(),e.strokeStyle="red",e.lineWidth=5,e.moveTo(s[0],s[1]),e.lineTo(r[0],r[1]),e.closePath(),e.stroke()}};var xt={PointShader:gt,LineShader:wt,TriangleShader:class{constructor(){}renderTriangle(t={}){const e=t.ctx,s=t.a,r=t.b,n=t.c;e.save(),e.beginPath(),e.strokeStyle="black",e.moveTo(s[0],s[1]),e.lineTo(r[0],r[1]),e.lineTo(n[0],n[1]),e.closePath(),e.stroke(),e.restore()}}};const yt=pt,vt=xt;var St=class{constructor(t={}){this.scene=t.scene,this.id=t.id,this.x=[],this.triangles=[],this.lines=[],this.pointShader=new vt.PointShader({}),this.lineShader=new vt.LineShader({}),this.triangleShader=new vt.TriangleShader({}),this.customAttributes={}}numVertices(){return this.x.length}numTriangles(){return this.triangles.length}numLines(){return this.lines.length}setCustomAttribute(t,e){this.customAttributes[t]=e}getCustomAttribute(t){return this.customAttributes[t]}computeAABB(){let t=null,e=null,s=null,r=null;return this.x.forEach((n=>{const i=n[0],o=n[1];(null==t||i<t)&&(t=i),(null==e||i>e)&&(e=i),(null==s||o<s)&&(s=o),(null==r||o>r)&&(r=o)})),new yt.AABB({x0:t,y0:s,x1:e,y1:r})}computeCenter(){let t=[0,0];const e=this.x.length;for(let s=0;s<e;s++){const e=this.x[s];yt.Vec2.add_(t,e)}return yt.Vec2.mulScalar_(t,1/e),t}};const Et=St;var bt=class{constructor(t={}){const e=t.headless??!1;if(this.headless=e,!e){const t=document.createElement("canvas");this.domElement=t,this.ctx=t.getContext("2d")}this.setSize({width:200,height:200})}setSize(t){const e=t.width;if(null==e)throw new Error("width required to setSize");const s=t.height;if(null==s)throw new Error("height required to setSize");let r=t.viewportWidth;null==r&&(r=e);let n=t.viewportHeight;if(null==n&&(n=s),this.width=e,this.height=s,this.viewportWidth=r,this.viewportHeight=n,!this.headless){const t=this.domElement;t.width=r,t.height=n,t.style.width=`${e}px`,t.style.height=`${s}px`}}renderPoint(t,e,s,r,n){const i=this.ctx;let o;if(!(e instanceof Et))throw new Error("invalid mesh");o=e.x[r];const h=s.transform.apply(o);i.save(),e.pointShader.renderPoint({ctx:i,renderer:t,mesh:e,camera:s,id:r,p:h,custom:n}),i.restore()}renderLine(t,e,s,r,n){const i=this.ctx,o=e.lines[r],h=s.transform.apply(e.x[o[0]]),l=s.transform.apply(e.x[o[1]]);i.save(),e.lineShader.renderLine({ctx:i,renderer:t,mesh:e,camera:s,id:r,a:h,b:l,custom:n}),i.restore()}renderTriangle(t,e,s,r,n){const i=this.ctx,o=e.triangles[r],h=o[0],l=o[1],a=o[2];let u,c,d;if(e.x instanceof Float32Array){const t=2;u=[e.x[h*t],e.x[h*t+1]],c=[e.x[l*t],e.x[l*t+1]],d=[e.x[a*t],e.x[a*t+1]]}else u=e.x[h],c=e.x[l],d=e.x[a];const p=s.transform.apply(u),m=s.transform.apply(c),f=s.transform.apply(d);i.save(),e.triangleShader.renderTriangle({ctx:i,renderer:t,mesh:e,camera:s,id:r,a:p,b:m,c:f,custom:n}),i.restore()}renderMesh(t,e,s,r={}){const n=e.sortedElements;if(null==n){for(let n=0;n<e.triangles.length;n++)this.renderTriangle(t,e,s,n,r);for(let n=0;n<e.lines.length;n++)this.renderLine(t,e,s,n,r);for(let n=0;n<e.x.length;n++)this.renderPoint(t,e,s,n,r)}else n.forEach((n=>{if(null==n.order)throw new Error(`invalid element, order not defined ${n}`);if(1==n.order)this.renderPoint(t,e,s,n.id,r);else if(2==n.order)this.renderLine(t,e,s,n.id,r);else{if(3!=n.order)throw new Error(`invalid element ${n}`);this.renderTriangle(t,e,s,n.id,r)}}))}render(t,e,s={}){this.ctx.clearRect(0,0,this.viewportWidth,this.viewportHeight),t.meshes.forEach((t=>{this.renderMesh(this,t,e,s)}))}};const Ct=St;var At={Camera:ft,Mesh:St,Renderer:bt,Scene:class{constructor(){this.meshes=new Map}clean(){this.meshes=new Map}numMeshes(){return this.meshes.size}addMesh(){const t=this.meshes.size,e=new Ct({scene:this,id:t});return this.meshes.set(t,e),e}}};var Tt={computeDomCursor:function(t,e){const s=e.getBoundingClientRect();let r,n;if(null==t.touches)r=t.clientX,n=t.clientY;else{if(0==t.touches.length)return null;const e=t.touches[0];r=e.clientX,n=e.clientY}return[r-s.left,n-s.top]}};const It=Tt;var zt={cursorUtils:Tt,DragBehavior:class{constructor(t={}){this._dragging=!1,this.onDomCursorDown=t.onDomCursorDown,this.onDragProgress=t.onDragProgress,this.onDomCursorUp=t.onDomCursorUp,this.domElement=null}beginDrag(){this._dragging=!0}endDrag(){this._dragging=!1}dragging(){return this._dragging}domCursorDown(t,e){null!=this.onDomCursorDown&&this.onDomCursorDown(t,e)}domCursorMove(t,e){this.dragging()&&null!=this.onDragProgress&&this.onDragProgress(t,e)}domCursorUp(t,e){this.endDrag(),null!=this.onDomCursorUp&&this.onDomCursorUp(t,e)}linkToDom(t){if(null!=this.domElement)throw new Error("already linked to DOM");this.domElement=t;const e=e=>{e.preventDefault();const s=It.computeDomCursor(e,t);this.domCursorDown(s,e)};t.addEventListener("mousedown",e,{passive:!1}),t.addEventListener("touchstart",e,{passive:!1});const s=e=>{const s=It.computeDomCursor(e,t);this.domCursorMove(s,e)};t.addEventListener("mousemove",s,{passive:!1}),t.addEventListener("touchmove",s,{passive:!1});const r=e=>{const s=It.computeDomCursor(e,t);this.domCursorUp(s,e)};window.addEventListener("mouseup",r),window.addEventListener("touchend",r),window.addEventListener("touchcancel",r)}}};class _t{constructor(t={}){if(null==t.scene)throw new Error("scene required");const e=null==t.color?"rgba(0, 0, 0, 0.30)":t.color,s=this.mesh=t.scene.addMesh();this.set(t),s.setCustomAttribute("translation",[0,0]),s.pointShader.renderPoint=()=>{},s.lineShader.renderLine=_t.makeGridLineShader({color:e})}get numVertices(){return this.mesh.x.length}get numLines(){return this.mesh.lines.length}set(t={}){const e=null==t.cellSize?1:t.cellSize,s=null==t.innerCells?3:t.innerCells,r=null==t.rows?3:t.rows,n=null==t.cols?4:t.cols,i=null==t.x0?-2:t.x0,o=null==t.y0?0:t.y0,h=null==t.primaryLineWidth?.03:t.primaryLineWidth,l=null==t.secondaryLineWidth?.008:t.secondaryLineWidth,a=this.mesh,{x:u,lineIndices:c,lineWidths:d}=function(t={}){const e=null==t.cellSize?1:t.cellSize,s=null==t.innerCells?3:t.innerCells,r=null==t.rows?3:t.rows,n=null==t.cols?4:t.cols,i=null==t.x0?-2:t.x0,o=null==t.y0?0:t.y0,h=null==t.primaryLineWidth?.022:t.primaryLineWidth,l=null==t.secondaryLineWidth?.008:t.secondaryLineWidth,a=[],u=[],c=[],d=o+r*e,p=i+n*e;function m(t,e){for(let r=0;r<t+1;r++){const n=r==t?1:s;for(let t=0;t<n;t++){const s=2*u.length;e(r,t,n,a),u.push([s,s+1]),0==t?c.push(h):c.push(l)}}}return m(r,((t,s,r,n)=>{const h=s/r,l=(o+t*e)*(1-h)+(o+(t+1)*e)*h;n.push([i,l]),n.push([p,l])})),m(n,((t,s,r,n)=>{const h=s/r,l=(i+t*e)*(1-h)+(i+(t+1)*e)*h;n.push([l,o]),n.push([l,d])})),{x:a,lineIndices:u,lineWidths:c}}({cellSize:e,innerCells:s,rows:r,cols:n,x0:i,y0:o,primaryLineWidth:h,secondaryLineWidth:l});a.x=u,a.lines=c,a.setCustomAttribute("lineWidths",d)}static makeGridLineShader(t={}){const e=null==t.color?"black":t.color;return t=>{const s=t.ctx,r=t.a,n=t.b,i=t.camera,o=t.mesh,h=i.inferScale();s.beginPath(),s.strokeStyle=e;const l=o.getCustomAttribute("lineWidths");if(null==l)throw new Error("custom attribute lineWidths missing");const a=l[t.id],u=o.getCustomAttribute("translation"),c=[h*u[0],h*u[1]];s.lineWidth=a*h,s.moveTo(r[0]+c[0],r[1]+c[1]),s.lineTo(n[0]+c[0],n[1]+c[1]),s.closePath(),s.stroke()}}}var Mt=_t;var $t={Grid:Mt,Background:class{constructor(t={}){if(null==t.scene)throw new Error("scene required");const e=this.mesh=t.scene.addMesh();e.x=[[0,0]];const s=null==t.color1?"#fcfcfc":t.color1,r=null==t.color2?"#d7d8d8":t.color2;e.pointShader.renderPoint=(t={})=>{const e=t.renderer.width,n=t.renderer.height,i=t.ctx,o=i.createRadialGradient(.5*e,.5*n,.05*e,.5*e,.5*n,.5*e);o.addColorStop(0,s),o.addColorStop(1,r),i.fillStyle=o,i.fillRect(0,0,e,n)}}}};var Vt=class{constructor(t,e){if(null==t)throw new Error("id required to create simplex");this.order=e.length,this.id=t,this.vertexIds=e}};const Lt=Vt;function kt(t){return t.sort(),t.join("_")}var Wt=class{constructor(t={}){if(null==t.order)throw new Error("order required");this.order=t.order,this.simplicesByHash=new Map}forEach(t){this.simplicesByHash.forEach(t)}size(){return this.simplicesByHash.size}has(t){return this.simplicesByHash.has(kt(t.vertexIds))}add(t,e){let s=null;if(Array.isArray(t)){if(null==e)throw new Error("id required");s=t,t=new Lt(e,s)}else{if(s=t.vertexIds,null==s)throw new Error(`vertexIds required ${t}`);e=t.id}if(s.length!=this.order)throw new Error(`expected ${this.order} vertices, found ${s.length}`);const r=kt(s);return this.simplicesByHash.set(r,t),t}};const Pt=Wt;const Dt=Wt,Ft=class{constructor(t){this.id=t,this.edges=new Pt({order:2}),this.triangles=new Pt({order:3})}addTriangle(t,e){this.triangles.add(t,e)}addEdge(t,e){this.edges.add(t,e)}};var qt=class{constructor(t={}){this.vertices=new Map,this.edges=new Dt({order:2}),this.triangles=new Dt({order:3});(t.edges??[]).forEach(((t,e)=>{this.addEdge(e,t)}));(t.triangles??[]).forEach(((t,e)=>{this.addTriangle(e,t)}))}numVertices(){return this.vertices.size}numEdges(){return this.edges.size()}numTriangles(){return this.triangles.size()}getVertexById(t,e=!1){let s=this.vertices.get(t);return null==s&&e&&(s=new Ft(t),this.vertices.set(t,s)),s}addEdge(t,e){const s=this.edges.add(e,t);return e.forEach((t=>{this.getVertexById(t,!0).addEdge(s)})),s}addTriangle(t,e){const s=this.triangles.add(e,t);return e.forEach((t=>{this.getVertexById(t,!0).addTriangle(s)})),s}};const Bt=qt,Nt=Wt;var Rt={math:pt,ui:zt,shaders:xt,background:$t,sorted:{makeSortedElements:function(t={}){if(null==t.sortedVertexIds)throw new Error("sortedVertexIds required");if(null==t.triangles)throw new Error("triangles required");if(null==t.edges)throw new Error("edges required");const e=t.sortedVertexIds,s=new Map;e.forEach(((t,e)=>{s.set(t,e)}));const r=new Bt({triangles:t.triangles}),n=new Bt({edges:t.edges}),i=[],o=new Nt({order:3}),h=new Nt({order:2});return e.forEach((t=>{const e=r.getVertexById(t,!0).triangles,l=n.getVertexById(t,!0).edges,a=[];e.forEach((t=>{a.push(t)})),l.forEach((t=>{a.push(t)})),a.sort(((t,e)=>{const r=t.vertexIds.map((t=>s.get(t))),n=e.vertexIds.map((t=>s.get(t))),i=Math.max(...r),o=Math.max(...n);return i<o?1:i==o?0:-1})),a.forEach((t=>{if(2==t.order){const e=t;h.has(e)||(i.push(e),h.add(e))}else{const e=t;o.has(e)||(i.push(e),o.add(e))}})),i.push({order:1,id:t})})),i},MeshTopology:qt,Simplex:Vt,Simplices:Wt},core:At,Renderer:At.Renderer,Camera:At.Camera,Scene:At.Scene};const Xt=tt,Ut=Rt;function Gt(t){return t.sort(),t.join("_")}class Ot{constructor(t={}){if(null==t.scene)throw new Error("scene required");const e=this.scene=t.scene,s=this.mesh=e.addMesh();s.x=[[-10,0],[10,0]],s.lines=[[0,1]],s.lineShader.renderLine=Ot.makeFloorLineShaderFunction({width:t.width,color:t.color}),s.pointShader.renderPoint=()=>{},s.setCustomAttribute("translation",[0,0])}static makeFloorLineShaderFunction(t={}){const e=t.width??.055,s=t.color??"black";return t=>{const r=t.ctx,n=t.a,i=t.b,o=t.camera,h=t.mesh,l=o.inferScale(),a=h.getCustomAttribute("translation"),u=[l*a[0],l*a[1]];r.strokeStyle=s,r.lineWidth=l*e,r.beginPath(),r.moveTo(n[0]+u[0],n[1]+u[1]),r.lineTo(i[0]+u[0],i[1]+u[1]),r.stroke()}}}function Ht(t){if(7!=t.length)throw new Error(`invalid hex string ${t}`);if("#"!=t[0])throw new Error(`invalid hex string ${t}, expected #, found ${t[0]}`);t=t.substring(1);return[parseInt(t.substring(0,2),16),parseInt(t.substring(2,4),16),parseInt(t.substring(4,6),16)]}return t({System:Z,mmgrten:K,SystemViewport:{SystemViewport:class{constructor(t={}){if(null==t.system)throw new Error("system required");this.system=t.system,this.sortedVertexIds=t.sortedVertexIds;const e=t.headless??!1,s=new Ut.Renderer({headless:e});this.renderer=s,this.domElement=s.domElement,this.setSize({width:400,height:400});const r=new Ut.Scene;this.scene=r;const n=new Ut.Camera;this.camera=n;const i=t.borderColor??"black",o=i,h=t.fillColor??"white",l=t.gridColor??"#acadad";let a,u,c=t.activeMuscleColor??[255,0,0],d=t.inactiveMuscleColor??[250,190,190];"string"==typeof c&&(c=Ht(c)),"string"==typeof d&&(d=Ht(d)),null!=t.backgroundColor?(a=t.backgroundColor,u=t.backgroundColor):(a=t.backgroundCenterColor??"#fcfcfc",u=t.backgroundOuterColor??"#d7d8d8"),new Ut.background.Background({scene:r,color1:a,color2:u});const p=this.grid=new Ut.background.Grid({scene:r,x0:-3,y0:0,rows:4,cols:10,innerCells:2,primaryLineWidth:.022,secondaryLineWidth:.005,color:l});p.innerCells=2,p.primaryLineWidth=.022,p.secondaryLineWidth=.005,this.floor=new Ot({scene:r,color:o});const m=r.addMesh();this.mesh=m,m.pointShader.renderPoint=function(t={}){const e=t.radius??.028,s=t.borderColor??"black",r=t.fillColor??"white",n=t.borderWidth??.023;return t=>{const i=t.ctx,o=t.p,h=t.camera.inferScale(),l=(e+n)*h;i.fillStyle=s,i.beginPath(),i.arc(o[0],o[1],l,0,2*Math.PI),i.fill();const a=e*h;i.fillStyle=r,i.beginPath(),i.arc(o[0],o[1],a,0,2*Math.PI),i.fill()}}({borderColor:i,fillColor:h}),m.triangleShader.renderTriangle=(t={})=>{const e=t.ctx,s=t.a,r=t.b,n=t.c;e.beginPath(),e.fillStyle=h,e.moveTo(...s),e.lineTo(...r),e.lineTo(...n),e.closePath(),e.fill()},m.lineShader.renderLine=(t={})=>{const e=t.ctx,s=t.a,r=t.b,n=t.camera.inferScale(),o=t.mesh.getCustomAttribute("lineIdToSpringId")[t.id];if(null==o){const t=.029;e.beginPath(),e.lineJoin="round",e.lineCap="round",e.strokeStyle=i,e.lineWidth=t*n,e.moveTo(s[0],s[1]),e.lineTo(r[0],r[1]),e.closePath(),e.stroke()}else{const t=c,h=d,l=.065,a=.017,u="butt",p="muscleIntensity";e.beginPath(),e.lineCap=u,e.strokeStyle=i,e.lineWidth=(l+2*a)*n,e.moveTo(s[0],s[1]),e.lineTo(r[0],r[1]),e.stroke(),e.beginPath();const f=m.getCustomAttribute(p);if(null==f)throw new Error(`muscle intensity attribute (${p}) not found, call setCustomAttribute("${p}", value) before rendering.`);if(!Array.isArray(f))throw new Error("muscle intensity attribute must be an array with values for each fiber, found "+typeof f);const g=f[o],w=(1-g)*t[0]+g*h[0],x=(1-g)*t[1]+g*h[1],y=(1-g)*t[2]+g*h[2];e.strokeStyle=`rgb(${w}, ${x}, ${y})`,e.lineCap=u,e.lineWidth=l*n,e.moveTo(s[0],s[1]),e.lineTo(r[0],r[1]),e.stroke()}};if(t.draggable??!0){const t=this.dragBehavior=new Ut.ui.DragBehavior({onDomCursorDown:(e,s)=>{if("button"in s&&0!=s.button)return;const r=this.system,i=n.domToWorldSpace(e),o=this.hitTestVertex(i);null!=o&&(this.fixVertex(o),t.beginDrag(),this.setVertexPos(r.fixedVertexId,[i[0],Math.max(0,i[1])]))},onDragProgress:t=>{const e=this.system,s=n.domToWorldSpace(t);this.setVertexPos(e.fixedVertexId,[s[0],Math.max(0,s[1])])},onDomCursorUp:()=>{this.freeVertex()}});e||t.linkToDom(s.domElement)}this.tracker=new Xt}setSize(t={}){this.renderer.setSize({width:t.width,height:t.height})}render(){if(null==this.needsMeshUpdate||this.needsMeshUpdate){const t=[];if(null!=this.system.triangles){const e=this.system.triangles.u32();for(let s=0;s<this.system.numTriangles();s++){const r=3*s;t.push([e[r],e[r+1],e[r+2]])}}const e=[];if(null!=this.system.springs){const t=this.system.springs.u32();for(let s=0;s<this.system.numSprings();s++){const r=2*s;e.push([t[r],t[r+1]])}}this._updateMesh({triangles:t,springs:e}),this.needsMeshUpdate=!1}const t=this.renderer,e=this.scene,s=this.camera,r=this.mesh;this._updateFromSystem(),null!=this.dragBehavior&&this.dragBehavior.dragging()||this.tracker.step({mesh:r,camera:s,floor:this.floor,grid:this.grid,renderer:this.renderer}),t.render(e,s)}_updateMesh(t){const e=this.mesh;null!=t.x&&(e.x=t.x),e.triangles=t.triangles,e.lines=function(t){const e=new Map;function s(t,s){const r=Gt([t,s]);e.set(r,[t,s])}return t.forEach((t=>{s(t[0],t[1]),s(t[1],t[2]),s(t[0],t[2])})),Array.from(e.values())}(t.triangles);const s=new Map;if(null!=this.system.springs){const t=this.system.springs.u32();for(let e=0;e<this.system.numSprings();e++){const r=2*e,n=[t[r],t[r+1]];s.set(Gt(n),e)}}const r=[];e.setCustomAttribute("lineIdToSpringId",r),e.lines.forEach((t=>{const e=Gt(t),n=s.get(e);r.push(n)}));let n=this.sortedVertexIds;if(null==n){n=[];for(let t=0;t<this.system.numVertices();t++)n.push(t)}if(n.length!=this.system.numVertices())throw new Error(`invalid size for sortedVertexIds, found ${n.length}, expected ${this.system.numVertices()}`);e.sortedElements=Ut.sorted.makeSortedElements({sortedVertexIds:n,triangles:e.triangles,edges:e.lines});const i=[],o=this.system.numSprings();for(let t=0;t<o;t++)i.push(1);e.setCustomAttribute("muscleIntensity",i)}_updateFromSystem(){this._updateVertexPositionsFromSystem(),this._updateMuscleIntensityFromSystem()}_updateVertexPositionsFromSystem(){const t=this.mesh,e=this.system;if(0==e.numVertices())t.x=[];else{const s=e.x0.toArray();t.x=s}}_updateMuscleIntensityFromSystem(){const t=this.mesh,e=this.system,s=[],r=e.numSprings();if(r>0){const t=e.a.slot.f32();for(let e=0;e<r;e++)s.push(t[e])}t.setCustomAttribute("muscleIntensity",s)}hitTestVertex(t,e=.31){const s=this.system.numVertices();if(0==s)return null;const r=this.system.x0.slot.f32();let n=null,i=1/0;const o=e*e;for(let e=0;e<s;e++){const s=2*e,h=[r[s],r[s+1]],l=Ut.math.Vec2.sub(h,t),a=Ut.math.Vec2.quadrance(l);a<o&&a<i&&(n=e,i=a)}return n}setVertexPos(t,e){const s=this.system.x0.slot.f32(),r=2*t;s[r]=e[0],s[r+1]=e[1]}setVertexVel(t,e){const s=this.system.v0.slot.f32(),r=2*t;s[r]=e[0],s[r+1]=e[1]}fixVertex(t){const e=this.system;this.setVertexVel(t,[0,0]),null==t&&(t=-1),e.fixedVertexId=t}freeVertex(){this.system.fixedVertexId=-1}}}.SystemViewport,mm2d:Rt})}));
