/**
 * algovivo
 * (c) 2023 Junior Rojas
 * License: MIT
 * 
 * Built from commit 876a7db39ad2917d838a69c2a2ae200216eacd9b
 */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e="undefined"!=typeof globalThis?globalThis:e||self).algovivo=t()}(this,(function(){"use strict";function e(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}class t{constructor(e,t){this.list=e,this.data=t,this.next=null,this.prev=null}append(e){const s=new t(this.list,e);return this.list.last==this&&(this.list.last=s),s.next=this.next,s.prev=this,null!=this.next&&(this.next.prev=s),this.next=s,this.list.size++,s}prepend(e){const s=new t(this.list,e);return this.list.first==this&&(this.list.first=s),s.next=this,s.prev=this.prev,null!=this.prev&&(this.prev.next=s),this.prev=s,this.list.size++,s}remove(){null!=this.prev&&(this.prev.next=this.next),null!=this.next&&(this.next.prev=this.prev),this.list.first==this&&(this.list.first=this.next),this.list.last==this&&(this.list.last=this.prev),this.list.size--,this.next=null,this.prev=null}}var s=t;const r=s;class n{constructor(e){this.list=e,this.nextNode=this.list.first}next(){if(null==this.nextNode)return{done:!0};{const e={done:!1,value:this.nextNode.data};return this.nextNode=this.nextNode.next,e}}}class i{constructor(){this.first=null,this.last=null,this.size=0}isEmpty(){if(null==this.first&&null!=this.last||null!=this.first&&null==this.last)throw Error("inconsistent first last state");return null==this.first}append(e){return this.isEmpty()?this.setSingleton(e):this.last.append(e)}prepend(e){return this.isEmpty()?this.setSingleton(e):this.first.prepend(e)}setSingleton(e){const t=new r(this,e);return this.first=t,this.last=t,this.size=1,t}iter(){return new n(this)}*[Symbol.iterator](){const e=this.iter();let t=e.next();for(;!t.done;)yield t.value,t=e.next()}}var o,l,h,a,u,c,d={List:i,Node:s};function p(){if(l)return o;l=1;const e=m();return o=class extends e{constructor(e={}){super(e)}isFree(){return!1}free(){let e=this.appendFree(this.ptr,this.size);this.remove();const t=e.prev(),s=e.next();return null!=t&&t.isFree()&&(e=t.merge(e)),null!=s&&s.isFree()&&(e=e.merge(s)),e}}}function m(){if(a)return h;a=1;return h=class{constructor(e={}){this.manager=e.manager,this.ptr=e.ptr,this.size=e.size,this.node=e.node}numBytes(){return this.size}prev(){const e=this.node.prev;return null!=e?e.data:null}next(){const e=this.node.next;return null!=e?e.data:null}appendReserved(e,t){const s=p(),r=this.node.append(null),n=new s({manager:this.manager,ptr:e,size:t,node:r});return r.data=n,this.manager._addReservedSlot(n),n}appendFree(e,t){const s=f(),r=this.node.append(null),n=new s({manager:this.manager,ptr:e,size:t,node:r});return r.data=n,this.manager._addFreeSlot(n),n}remove(){this.node.remove(),this.node.data=null,this.node=null,this.isFree()?this.manager._removeFreeSlot(this):this.manager._removeReservedSlot(this)}toTypedArray(e){const t=this.size,s=e.BYTES_PER_ELEMENT;if(t%s!=0)throw new Error(`size in bytes must be a multiple of ${s}, found ${t}`);const r=this.ptr;return new e(this.manager.array,r,t/s)}f32(){return this.toTypedArray(Float32Array)}u32(){return this.toTypedArray(Uint32Array)}},h}function f(){if(c)return u;c=1;const e=m();return u=class extends e{constructor(e={}){super(e)}isFree(){return!0}reserve(e){const t=this.numBytes();if(e>t)throw new Error(`cannot reserve ${e} bytes, only ${t} bytes are available`);const s=this.appendReserved(this.ptr,e);return s.appendFree(this.ptr+e,t-e),this.remove(),s}merge(e){if(!this.isFree()||!e.isFree())throw new Error("only free slots can be merged");if(this.next()!=e)throw new Error("only adjacent slots can be merged");const t=e.appendFree(this.ptr,this.size+e.size);return this.remove(),e.remove(),t}}}const g=d,w=f();var y={linked:d,MemoryManager:class{constructor(e,t){this.array=e,null==t&&(t=0),this.ptrToSlot=new Map,this.slots=new g.List,this.freeSlots=new g.List,this.reservedSlots=new g.List;const s=new w({manager:this,ptr:t,size:e.byteLength-t}),r=this.slots.append();r.data=s,s.node=r;const n=this.freeSlots.append();n.data=s,s.freeNode=n}numReservedSlots(){return this.reservedSlots.size}numFreeSlots(){return this.freeSlots.size}numFreeBytes(){let e=0;const t=this.freeSlots.iter();let s=t.next();for(;!s.done;){e+=s.value.size,s=t.next()}return e}numReservedBytes(){let e=0;const t=this.reservedSlots.iter();let s=t.next();for(;!s.done;){e+=s.value.size,s=t.next()}return e}mallocBytes(e){return this._malloc(e)}malloc32(e){return this.mallocBytes(4*e)}_addReservedSlot(e){const t=this.reservedSlots.append(e);e.reservedNode=t}_removeReservedSlot(e){if(null==e.reservedNode)throw new Error("reservedNode cannot be null");e.reservedNode.remove()}_addFreeSlot(e){const t=this.freeSlots.append(e);e.freeNode=t}_removeFreeSlot(e){if(null==e.freeNode)throw new Error("freeNode cannot be null");e.freeNode.remove()}_malloc(e){if(!Number.isInteger(e))throw new Error(`expected integer, found ${e}`);let t=null;const s=this.freeSlots.iter();let r=s.next();for(;!r.done;){const n=r.value;if(n.size>=e){t=n;break}r=s.next()}if(null==t)throw new Error("no valid free slot available");return t.reserve(e)}malloc(e){const t=this._malloc(e);return this.ptrToSlot.set(t.ptr,t),t.ptr}free(e){this.ptrToSlot.get(e).free()}},FreeSlot:f(),ReservedSlot:p()};class x{constructor(e={}){const t=e.engine;if(null==t)throw new Error("engine required to create IntTuple");this.engine=t;const s=e.slot;if(null==s)throw new Error("slot required to create IntTuple");this.slot=s,this.ptr=s.ptr,this.length=e.length}forEach(e){for(let t=0;t<this.length;t++)e(this.get(t),t)}equal(e){if(e instanceof x){for(let t=0;t<this.length;t++){if(this.get(t)!=e.get(t))return!1}return!0}if(Array.isArray(e)){for(let t=0;t<this.length;t++){if(this.get(t)!=e[t])return!1}return!0}return!1}toString(){return this.slot.u32().toString()}toArray(){const e=[];return this.forEach((t=>{e.push(t)})),e}typedArray(){return this.slot.u32()}set(e,t){this.typedArray()[e]=t}get(e){return this.typedArray()[e]}dispose(){this.slot.free()}}var v=x;function E(e,t,s,r){if(t==s.length-1)for(let n=0;n<s[t];n++)e.push(r);else for(let n=0;n<s[t];n++){const n=[];e.push(n),E(n,t+1,s,r)}}var S={inferShape:function(e){const t=[];let s=e;for(;Array.isArray(s);)t.push(s.length),s=s[0];return t},makeNdArray:function(e,t){let s=e;e instanceof v&&(s=e.toArray());const r=[];return E(r,0,s,t),r},numelOfShape:function(e){let t=1;return e.forEach((e=>{t*=e})),t},getArrElem:function e(t,s){if(!Array.isArray(s))throw new Error(`expected array, found ${typeof s}: ${s}`);return 0==s.length?t:e(t[s[0]],s.slice(1))},setArrElem:function e(t,s,r){if(!Array.isArray(s))throw new Error(`expected array, found ${typeof s}: ${s}`);if(1!=s.length)return e(t[s[0]],s.slice(1),r);t[s]=r}};const b=v;class _{constructor(e){if(null==e)throw new Error("shape required");if(!(e instanceof b))throw new Error(`IntTuple shape expected, found ${typeof e}: shape`);this.shape=e,this.done=!1,this.idx=[],e.forEach((e=>{this.idx.push(0)}))}next(){const e=this.shape;for(let t=0;t<e.length;t++){const s=e.length-1-t;if(this.idx[s]<e.get(s)-1)return void this.idx[s]++;if(0==s)return void(this.done=!0);this.idx[s]=0}}static shapeForEach(e,t){const s=new _(e);for(;!s.done;)t(s.idx),s.next()}}const I=S,V=_,M=v;class C{constructor(e={}){const t=e.engine;if(null==t)throw new Error("engine required to create tensor");this.engine=t;const s=e.shape;if(null==s)throw new Error("shape required to create tensor");if(s instanceof M)this.shape=s;else{if(!Array.isArray(s))throw new Error(`invalid shape type ${typeof s}: ${s}`);this.shape=t.intTuple(s)}this.order=this.shape.length;const r=I.numelOfShape(this.shape);this.numel=r;const n=e.slot;if(r>0&&null==n)throw new Error("memory slot required to create tensor");this.slot=e.slot;const i=e.stride;if(null!=i){if(!(i instanceof M))throw new Error(`expected IntTuple stride, found ${typeof i}: ${i}`);this.stride=i}else this.setDefaultStride()}get ptr(){return this.slot.ptr}get wasmInstance(){return this.engine.wasmInstance}isScalar(){return 0==this.order}fill_(e){this.wasmInstance.exports.fill_(this.numel,this.ptr,e)}clamp_(e={}){const t=e.min,s=e.max;this.wasmInstance.exports.clamp(this.numel,this.ptr,this.ptr,t,s,null!=t,null!=s)}zero_(){this.fill_(0)}flattenIdx(e){let t,s,r=!1;if(Array.isArray(e)&&(t=this.engine.intTuple(e),r=!0),!(t instanceof M))throw new Error(`cannot handle ${typeof t}: ${t}`);return s=this.engine.wasmInstance.exports.flatten_idx(this.order,t.slot.ptr,this.stride.slot.ptr),r&&t.dispose(),s}typedArray(){return this.slot.f32()}toArray(){if(0==this.numel)return[];const e=I.makeNdArray(this.shape,0);return this.forEach((t=>{const s=this.get(t);I.setArrElem(e,t,s)})),e}get(e){const t=this.flattenIdx(e);return this.typedArray()[t]}item(){if(!this.isScalar())throw new Error(`item() only works for scalars, found tensor with shape ${this.shape}`);return this.get([0])}setDefaultStride(){let e=1;const t=this.order,s=[];for(let e=0;e<t;e++)s.push(0);for(let r=0;r<t;r++){const n=t-1-r;s[n]=e,e*=this.shape.get(n)}this.stride=this.engine.intTuple(s)}setFromArray(e){if(0==this.numel)return;if(this.isScalar()){if("number"!=typeof e)throw new Error(`expected number, found ${typeof e}: ${e}`);this.set([0],e)}else{if(!Array.isArray(e))throw new Error(`expected array, found ${typeof e}: ${e}`);const t=I.inferShape(e);if(!this.shape.equal(t))throw new Error(`inconsistent shapes ${t} != ${this.shape}`);this.forEach((t=>{const s=I.getArrElem(e,t);this.set(t,s)}))}}set(e,t){if(null==t&&Array.isArray(e))this.setFromArray(e);else{const s=this.flattenIdx(e);this.typedArray()[s]=t}}forEach(e){V.shapeForEach(this.shape,e)}squeeze(e){-1==e&&(e=this.shape.length-1);const t=this.shape.get(e);if(1!=t)throw new Error(`cannot squeeze a dimension that is not equal to 1, shape[${e}] = ${t}`);const s=[];for(let t=0;t<this.order;t++)e!=t&&s.push(this.shape.get(t));return new C({engine:this.engine,shape:s,slot:this.slot})}unsqueeze(e){-1==e&&(e=this.shape.length-1);const t=[];for(let s=0;s<this.order;s++)t.push(this.shape.get(s)),e==s&&t.push(1);return new C({engine:this.engine,shape:t,slot:this.slot})}add(e,t){this.engine.functional.add(this,e,t)}sum(e){this.engine.wasmInstance.exports.sum(this.numel,this.slot.ptr,e.slot.ptr)}dispose(){if(null==this.slot)throw new Error("tensor already disposed");this.slot.free(),this.slot=null,this.shape.dispose(),this.stride.dispose()}}var T=C;var A=class{constructor(e={}){const t=this.engine=e.engine;this.wasmInstance=t.wasmInstance}matvec(e,t,s){const r=e.shape.get(0),n=e.shape.get(1),i=t.shape.get(0),o=s.shape.get(0);if(r!=o)throw new Error(`inconsistent output size ${r} != ${o}`);if(n!=i)throw new Error(`inconsistent input size ${n} != ${i}`);this.wasmInstance.exports.matvec(r,n,e.stride.ptr,e.ptr,t.stride.ptr,t.ptr,s.stride.ptr,s.ptr)}mm(e,t,s){const r=e.shape.get(0),n=e.shape.get(1),i=t.shape.get(1);this.wasmInstance.exports.mm(r,n,i,e.stride.ptr,e.ptr,t.stride.ptr,t.ptr,s.stride.ptr,s.ptr)}relu(e,t){this.wasmInstance.exports.relu(e.numel,e.ptr,t.ptr)}tanh(e,t){const s=e.numel,r=e.typedArray(),n=t.typedArray();for(let e=0;e<s;e++)n[e]=Math.tanh(r[e])}add(e,t,s){this.wasmInstance.exports.add(e.numel,e.ptr,t.ptr,s.ptr)}sum(e,t){this.wasmInstance.exports.sum(e.numel,e.ptr,t.ptr)}sumBackward(e,t,s,r){this.wasmInstance.exports.sum_backward(e.numel,e.ptr,t.ptr,s.ptr,r.ptr)}};var k=class{constructor(){}};const z=k;var $=class extends z{constructor(e,t){super(),this.nn=e,this.layers=t}forward(e){let t=e;return this.layers.forEach((e=>{t=e.forward(t)})),t}dispose(){this.layers.forEach((e=>{e.dispose()}))}};const D=k;var L=class extends D{constructor(e,t,s){super(),this.nn=e,this.inputSize=t,this.outputSize=s;const r=this.nn.engine;this.weight=r.zeros([s,t]),this.bias=r.zeros([s]),this.output=r.zeros([s])}forward(e){const t=this.nn.engine.functional;return t.matvec(this.weight,e,this.output),t.add(this.output,this.bias,this.output),this.output}dispose(){this.weight.dispose(),this.bias.dispose(),this.output.dispose()}};const P=k;var W=class extends P{constructor(e){super(),this.nn=e,this.output=null}forward(e){const t=this.nn.engine;return null==this.output&&(this.output=t.zerosLike(e)),t.functional.relu(e,this.output),this.output}dispose(){null!=this.output&&this.output.dispose()}};const F=k;var q=class extends F{constructor(e){super(),this.nn=e,this.output=null}forward(e){const t=this.nn.engine;return null==this.output&&(this.output=t.zerosLike(e)),t.functional.tanh(e,this.output),this.output}dispose(){null!=this.output&&this.output.dispose()}};const B=$,N=L,R=W,O=q;var G=class{constructor(e={}){this.engine=e.engine}Linear(e,t){return new N(this,e,t)}ReLU(){return new R(this)}Tanh(){return new O(this)}Sequential(){const e=Array.from(arguments);return new B(this,e)}};const X=y,U=S,H=T,j=v,Y=A,J=G;const K=class{constructor(e={}){null!=e.wasmInstance&&this.init(e),this.env={}}init(e={}){if(null==e.wasmInstance)throw new Error("wasmInstance required");this.wasmInstance=e.wasmInstance;const t=e.wasmInstance.exports.memory.buffer,s=new X.MemoryManager(t,e.wasmInstance.exports.__heap_base);this.mgr=s,this.functional=this.F=new Y({engine:this}),this.nn=new J({engine:this}),this._mergeF()}_mergeF(){Object.getOwnPropertyNames(Object.getPrototypeOf(this.F)).forEach((e=>{"constructor"!=e&&(this[e]=this.F[e])}))}tensor(e){const t=U.inferShape(e),s=this.intTuple(t),r=U.numelOfShape(t),n=this.mgr.malloc32(r),i=new H({engine:this,shape:s,slot:n});return i.setFromArray(e),i}intTuple(e){if(!Array.isArray(e))throw new Error(`expected array, found ${typeof e}: ${e}`);const t=e.length,s=this.mgr.malloc32(t),r=new j({engine:this,length:t,slot:s});for(let s=0;s<t;s++)r.set(s,e[s]);return r}zerosLike(e){if(!(e instanceof H))throw new Error(`expected tensor, found ${typeof e}: ${e}`);return this.zeros(e.shape.toArray())}empty(e){let t;if(e instanceof j)t=e;else{if(!Array.isArray(e))throw new Error(`expected array, found ${typeof e}: ${e}`);t=this.intTuple(e)}const s=U.numelOfShape(t),r=this.mgr.malloc32(s);return new H({engine:this,shape:t,slot:r})}zeros(e){const t=this.empty(e);return t.zero_(),t}ones(e){const t=this.empty(e);return t.fill_(1),t}};var Q={engine:function(e={}){return new K({wasmInstance:e.wasmInstance})},Engine:K,Tensor:T,mmgr:y,utils:S};var Z=class{constructor(e={}){const t=e.ten;if(null==t)throw new Error("ten required");this.ten=t,this.spaceDim=e.spaceDim??2,this.vertexMass=e.vertexMass??6.0714287757873535,this.pos0=null,this.pos1=null,this.vel0=null,this.vel1=null,this.posGrad=null,this.posTmp=null,this._fixedVertexId=-1}getVertexPos(e){const t=[];for(let s=0;s<this.spaceDim;s++)t.push(this.pos.get([e,s]));return t}set fixedVertexId(e){throw new Error("use fixVertex instead")}get fixedVertexId(){return this._fixedVertexId}fixVertex(e){this._fixedVertexId=e}freeVertex(){this._fixedVertexId=-1}get pos(){return this.pos0}get numVertices(){return null==this.pos0?0:this.pos0.shape.get(0)}updateTmpBuffers(){if(null==this.pos0)throw new Error("pos0 required");const e=this.numVertices,t=this.spaceDim,s=this.ten,r=s.zeros([e,t]);null!=this.posGrad&&this.posGrad.dispose(),this.posGrad=r;const n=s.zeros([e,t]);null!=this.posTmp&&this.posTmp.dispose(),this.posTmp=n}get wasmInstance(){return this.ten.wasmInstance}get memoryManager(){return this.ten.mgr}set(e){const t=this.ten,s=this.spaceDim;if(null==e)throw new Error("pos required");const r=e.length,n=t.tensor(e);null!=this.pos0&&this.pos0.dispose(),this.pos0=n;const i=t.zeros([r,s]);null!=this.pos1&&this.pos1.dispose(),this.pos1=i;const o=t.zeros([r,s]);null!=this.vel0&&this.vel0.dispose(),this.vel0=o;const l=t.zeros([r,s]);null!=this.vel1&&this.vel1.dispose(),this.vel1=l,this.updateTmpBuffers()}dispose(){null!=this.pos0&&(this.pos0.dispose(),this.pos0=null),null!=this.pos1&&(this.pos1.dispose(),this.pos1=null),null!=this.posGrad&&(this.posGrad.dispose(),this.posGrad=null),null!=this.posTmp&&(this.posTmp.dispose(),this.posTmp=null),null!=this.vel0&&(this.vel0.dispose(),this.vel0=null),null!=this.vel1&&(this.vel1.dispose(),this.vel1=null)}};var ee=class{constructor(e={}){const t=e.ten;if(null==t)throw new Error("ten required");this.ten=t,this.muscles=null,this.k=Math.fround(90),this.l0=null,this.a=null}get wasmInstance(){return this.ten.wasmInstance}get memoryManager(){return this.ten.mgr}get numMuscles(){return null==this.muscles?0:this.muscles.u32().length/2}set(e={}){if(null==e.indices)throw new Error("indices required");const t=e.indices,s=t.length,r=this.numMuscles,n=this.memoryManager,i=this.ten;null!=e.k&&(this.k=e.k);const o=n.malloc32(2*s);null!=this.muscles&&this.muscles.free(),this.muscles=o;const l=o.u32();if(t.forEach(((e,t)=>{const s=2*t;l[s]=e[0],l[s+1]=e[1]})),null!=this.l0&&this.l0.dispose(),this.l0=null,0!=s){const t=i.zeros([s]);this.l0=t,null==e.l0?this.wasmInstance.exports.l0_of_pos(this.numVertices,e.pos.ptr,s,this.muscles.ptr,this.l0.ptr):this.l0.set(e.l0)}const h=e.keepA??!1;if(s!=r){if(h)throw new Error(`keepA can only be true when the number of muscles is the same (${s} != ${r})`);if(null!=this.a&&(this.a.dispose(),this.a=null),0!=s){const e=i.zeros([s]);this.a=e,e.fill_(1)}}else 0==s?(null!=this.a&&this.a.dispose(),this.a=null):h||this.a.fill_(1)}dispose(){null!=this.muscles&&(this.muscles.free(),this.muscles=null),null!=this.l0&&(this.l0.dispose(),this.l0=null),null!=this.a&&(this.a.dispose(),this.a=null)}};const te=Q,se=Z,re=ee,ne=class{constructor(e={}){const t=e.ten;if(null==t)throw new Error("ten required");this.ten=t,this.triangles=null,this.rsi=null,this.mu=Math.fround(500),this.lambda=Math.fround(50)}get wasmInstance(){return this.ten.wasmInstance}get memoryManager(){return this.ten.mgr}get numTriangles(){return null==this.triangles?0:this.triangles.u32().length/3}set(e={}){const t=e.indices,s=e.rsi,r=t?t.length:this.numTriangles;if(null==t&&(!s||s.length!==r))throw new Error("rsi is not consistent with the number of indices");const n=this.memoryManager,i=this.ten,o=t?n.malloc32(3*r):this.triangles;if(t&&null!=this.triangles&&this.triangles.free(),this.triangles=o,null!=t){const e=o.u32();t.forEach(((t,s)=>{const r=3*s;e[r]=t[0],e[r+1]=t[1],e[r+2]=t[2]}))}if(null!=this.rsi&&this.rsi.dispose(),this.rsi=i.zeros([r,2,2]),null==s){let t=null,s=!1;if(null!=e.pos)if(Array.isArray(e.pos))t=i.tensor(e.pos),s=!0;else if(t=e.pos,null==t.ptr)throw new Error("invalid pos");this.wasmInstance.exports.rsi_of_pos(this.numVertices,t.ptr,r,this.triangles.ptr,this.rsi.ptr),s&&t.dispose()}else this.rsi.set(s)}dispose(){null!=this.triangles&&(this.triangles.free(),this.triangles=null),null!=this.rsi&&(this.rsi.dispose(),this.rsi=null)}};var ie=class{constructor(e={}){let t;if(null==e.ten){if(null==e.wasmInstance)throw new Error("wasmInstance required");t=new te.Engine({wasmInstance:e.wasmInstance}),this.ten=t}else t=e.ten,this.ten=t;this.h=.033,this.g=9.8,this.spaceDim=e.spaceDim??2,this._vertices=new se({ten:this.ten,vertexMass:e.vertexMass,spaceDim:this.spaceDim}),this._muscles=new re({ten:this.ten}),this._triangles=new ne({ten:this.ten}),this.friction={k:Math.fround(300)}}get vertices(){return this._vertices}set fixedVertexId(e){throw new Error("System.fixedVertexId setter is deprecated, use System.vertices.fixedVertexId instead")}get fixedVertexId(){throw new Error("System.fixedVertexId getter is deprecated, use System.vertices.fixedVertexId instead")}get wasmInstance(){return this.ten.wasmInstance}get memoryManager(){return this.ten.mgr}get vertexMass(){return this._vertices.vertexMass}get triangles(){return this._triangles.triangles}set triangles(e){this._triangles.triangles=e}get rsi(){return this._triangles.rsi}set rsi(e){this._triangles.rsi=e}get k(){return this._muscles.k}set k(e){this._muscles.k=e}get pos0(){return this._vertices.pos}get vel0(){return this._vertices.vel0}get pos(){return this.pos0}get vel(){return this.vel0}get numVertices(){return this._vertices.numVertices}get numTriangles(){return this._triangles.numTriangles}get numMuscles(){return this._muscles.numMuscles}get muscles(){return this._muscles.muscles}set muscles(e){this._muscles.muscles=e}get a(){return this._muscles.a}set a(e){this._muscles.a=e}get l0(){return this._muscles.l0}set l0(e){this._muscles.l0=e}setVertices(e){this._vertices.set(e)}setMuscles(e={}){this._muscles.set({...e,pos:e.pos??this.pos0})}setTriangles(e={}){this._triangles.set({...e,pos:e.pos??this.pos0})}getMusclesArray(){if(null==this.muscles)return[];const e=this.numMuscles,t=this.muscles.u32(),s=[];for(let r=0;r<e;r++){const e=2*r;s.push([t[e],t[e+1]])}return s}getTrianglesArray(){if(null==this.triangles)return[];const e=this.numTriangles,t=this.triangles.u32(),s=[];for(let r=0;r<e;r++){const e=3*r;s.push([t[e],t[e+1],t[e+2]])}return s}set(e){this.setVertices(e.pos),this.setMuscles({indices:e.muscles??[],l0:e.musclesL0,k:e.musclesK}),this.setTriangles({indices:e.triangles??[],rsi:e.trianglesRsi})}step(){const e=this.numVertices,t=this.numMuscles,s=this.numTriangles,r=this.vertices._fixedVertexId,n=this.vertexMass;this.wasmInstance.exports.backward_euler_update(this.spaceDim,this.g,this.h,e,0==e?0:this.pos0.ptr,0==e?0:this.vel0.ptr,n,t,0==t?0:this.muscles.ptr,this.k,0==t?0:this.a.ptr,0==t?0:this.l0.ptr,s,0==s?0:this.triangles.ptr,0==s?0:this._triangles.rsi.ptr,this._triangles?.mu,this._triangles?.lambda,this.friction.k,r,0==e?0:this._vertices.pos1.ptr,0==e?0:this._vertices.posGrad.ptr,0==e?0:this._vertices.posTmp.ptr,0==e?0:this._vertices.vel1.ptr),0!=e&&(this._vertices.pos0.slot.f32().set(this._vertices.pos1.slot.f32()),this._vertices.vel0.slot.f32().set(this._vertices.vel1.slot.f32()))}dispose(){this._vertices.dispose(),this._muscles.dispose(),this._triangles.dispose()}};function oe(e){return[e[0],e[1]]}function le(e,t){e[0]*=t,e[1]*=t}function he(e,t){const s=oe(e);return le(s,t),s}function ae(e){return e[0]*e[0]+e[1]*e[1]}function ue(e){return Math.sqrt(ae(e))}var ce={clone:oe,add:function(e,t){return[e[0]+t[0],e[1]+t[1]]},add_:function(e,t){e[0]+=t[0],e[1]+=t[1]},mulScalar_:le,mulScalar:he,sub:function(e,t){return[e[0]-t[0],e[1]-t[1]]},quadrance:ae,norm:ue,normalize:function(e){return he(e,1/ue(e))},dot:function(e,t){return e[0]*t[0]+e[1]*t[1]}};class de{constructor(e,t,s,r){this.m00=e,this.m01=t,this.m10=s,this.m11=r}get(e,t){return this[`m${e}${t}`]}set(e,t,s,r){this.m00=e,this.m01=t,this.m10=s,this.m11=r}toArray(){return[[this.m00,this.m01],[this.m10,this.m11]]}negate(){return new de(-this.m00,-this.m01,-this.m10,-this.m11)}apply(e){return[this.m00*e[0]+this.m01*e[1],this.m10*e[0]+this.m11*e[1]]}det(){return this.m00*this.m11-this.m10*this.m01}inv(){const e=this.det();return new de(this.m11/e,-this.m01/e,-this.m10/e,this.m00/e)}mm(e){const t=this.m00,s=this.m01,r=this.m10,n=this.m11,i=e.m00,o=e.m01,l=e.m10,h=e.m11;return new de(t*i+s*l,t*o+s*h,r*i+n*l,r*o+n*h)}t(){return new de(this.m00,this.m10,this.m01,this.m11)}static fromArray(e){return new de(e[0][0],e[0][1],e[1][0],e[1][1])}}var pe=de;const me=pe,fe=ce;class ge{constructor(){this.translation=[0,0],this.linear=new me(1,0,0,1)}inferScale(){return this.linear.m00}apply(e){return fe.add(this.linear.apply(e),this.translation)}inv(){const e=new ge;return e.linear=this.linear.inv(),e.translation=e.linear.negate().apply(this.translation),e}toColumnMajorArray(){return[this.linear.get(0,0),this.linear.get(1,0),this.linear.get(0,1),this.linear.get(1,1),this.translation[0],this.translation[1]]}}var we=ge;var ye={Vec2:ce,Matrix2x2:pe,Transform2d:we,AABB:class{constructor(e={}){if(null==e.x0)throw new Error("x0 required");if(null==e.y0)throw new Error("y0 required");this._x0=e.x0,this._y0=e.y0;let t=null;if(null!=e.width)t=this._x0+e.width;else{if(null==e.x1)throw new Error("x1 required");t=e.x1}this._x1=t;let s=null;if(null!=e.height)s=this._y0+e.height;else{if(null==e.y1)throw new Error("y1 required");s=e.y1}this._y1=s}get x0(){return this._x0}get x1(){return this._x1}get y0(){return this._y0}get y1(){return this._y1}get width(){return this._x1-this._x0}get height(){return this._y1-this._y0}get center(){return[.5*(this.x0+this.x1),.5*(this.y0+this.y1)]}}};const xe=ye;var ve=class{constructor(){this.transform=new xe.Transform2d}domToWorldSpace(e){if(!Array.isArray(e))throw new Error("array expected, found "+typeof e);if(2!=e.length)throw new Error(`array with 2 elements expected, found ${e.length}`);return this.transform.inv().apply(e)}inferScale(){return this.transform.inferScale()}center(e={}){let t=e.viewportWidth,s=e.viewportHeight;const r=e.renderer;if((null==t||null==s)&&null==r)throw new Error("renderer required");if(null!=r&&(t=r.width,s=r.height),null==t)throw new Error("viewportWidth required");if(null==s)throw new Error("viewportHeight required");let n,i=e.zoom??1;if(null!=e.worldWidth&&(i=t/e.worldWidth),this.transform.linear=new xe.Matrix2x2(i,0,0,-i),null!=e.worldCenter){const r=e.worldCenter;n=[.5*t-r[0]*i,.5*s+r[1]*i]}else n=[.5*t,.5*s];this.transform.translation=n}};var Ee=class{constructor(){}renderPoint(e={}){const t=e.ctx,s=e.p;t.beginPath(),t.arc(s[0],s[1],3,0,2*Math.PI),t.fill()}};var Se=class{constructor(){}renderLine(e={}){const t=e.ctx,s=e.a,r=e.b;t.beginPath(),t.strokeStyle="red",t.lineWidth=5,t.moveTo(s[0],s[1]),t.lineTo(r[0],r[1]),t.closePath(),t.stroke()}};var be={PointShader:Ee,LineShader:Se,TriangleShader:class{constructor(){}renderTriangle(e={}){const t=e.ctx,s=e.a,r=e.b,n=e.c;t.save(),t.beginPath(),t.strokeStyle="black",t.moveTo(s[0],s[1]),t.lineTo(r[0],r[1]),t.lineTo(n[0],n[1]),t.closePath(),t.stroke(),t.restore()}}};const _e=ye,Ie=be;var Ve=class{constructor(e={}){this.scene=e.scene,this.id=e.id,this.x=[],this.triangles=[],this.lines=[],this.pointShader=new Ie.PointShader({}),this.lineShader=new Ie.LineShader({}),this.triangleShader=new Ie.TriangleShader({}),this.customAttributes={}}get pos(){return this.x}set pos(e){this.x=e}numVertices(){return this.pos.length}numTriangles(){return this.triangles.length}numLines(){return this.lines.length}setCustomAttribute(e,t){this.customAttributes[e]=t}getCustomAttribute(e){return this.customAttributes[e]}computeAABB(){let e=null,t=null,s=null,r=null;return this.pos.forEach((n=>{const i=n[0],o=n[1];(null==e||i<e)&&(e=i),(null==t||i>t)&&(t=i),(null==s||o<s)&&(s=o),(null==r||o>r)&&(r=o)})),new _e.AABB({x0:e,y0:s,x1:t,y1:r})}computeCenter(){const e=this.pos.length;if(0==e)throw new Error("no vertices to compute center");let t=[0,0];for(let s=0;s<e;s++){const e=this.pos[s];_e.Vec2.add_(t,e)}return _e.Vec2.mulScalar_(t,1/e),t}};const Me=Ve;var Ce=class{constructor(e={}){const t=e.headless??!1;if(this.headless=t,!t){const e=document.createElement("canvas");this.domElement=e,this.ctx=e.getContext("2d")}this.setSize({width:200,height:200})}setSize(e){const t=e.width;if(null==t)throw new Error("width required to setSize");const s=e.height;if(null==s)throw new Error("height required to setSize");let r=e.viewportWidth;null==r&&(r=t);let n=e.viewportHeight;if(null==n&&(n=s),this.width=t,this.height=s,this.viewportWidth=r,this.viewportHeight=n,!this.headless){const e=this.domElement;e.width=r,e.height=n,e.style.width=`${t}px`,e.style.height=`${s}px`}}renderPoint(e,t,s,r,n){const i=this.ctx;let o;if(!(t instanceof Me))throw new Error("invalid mesh");o=t.pos[r];const l=s.transform.apply(o);i.save(),t.pointShader.renderPoint({ctx:i,renderer:e,mesh:t,camera:s,id:r,p:l,custom:n}),i.restore()}renderLine(e,t,s,r,n){const i=this.ctx,o=t.lines[r],l=s.transform.apply(t.pos[o[0]]),h=s.transform.apply(t.pos[o[1]]);i.save(),t.lineShader.renderLine({ctx:i,renderer:e,mesh:t,camera:s,id:r,a:l,b:h,custom:n}),i.restore()}renderTriangle(e,t,s,r,n){const i=this.ctx,o=t.triangles[r],l=o[0],h=o[1],a=o[2];let u,c,d;if(t.pos instanceof Float32Array){const e=2;u=[t.pos[l*e],t.pos[l*e+1]],c=[t.pos[h*e],t.pos[h*e+1]],d=[t.pos[a*e],t.pos[a*e+1]]}else u=t.pos[l],c=t.pos[h],d=t.pos[a];const p=s.transform.apply(u),m=s.transform.apply(c),f=s.transform.apply(d);i.save(),t.triangleShader.renderTriangle({ctx:i,renderer:e,mesh:t,camera:s,id:r,a:p,b:m,c:f,custom:n}),i.restore()}renderMesh(e,t,s,r={}){const n=t.sortedElements;if(null==n){for(let n=0;n<t.triangles.length;n++)this.renderTriangle(e,t,s,n,r);for(let n=0;n<t.lines.length;n++)this.renderLine(e,t,s,n,r);for(let n=0;n<t.pos.length;n++)this.renderPoint(e,t,s,n,r)}else n.forEach((n=>{if(null==n.order)throw new Error(`invalid element, order not defined ${n}`);if(1==n.order)this.renderPoint(e,t,s,n.id,r);else if(2==n.order)this.renderLine(e,t,s,n.id,r);else{if(3!=n.order)throw new Error(`invalid element ${n}`);this.renderTriangle(e,t,s,n.id,r)}}))}render(e,t,s={}){this.ctx.clearRect(0,0,this.viewportWidth,this.viewportHeight),e.meshes.forEach((e=>{this.renderMesh(this,e,t,s)}))}};const Te=Ve;var Ae={Camera:ve,Mesh:Ve,Renderer:Ce,Scene:class{constructor(){this.meshes=new Map}clean(){this.meshes=new Map}numMeshes(){return this.meshes.size}addMesh(){const e=this.meshes.size,t=new Te({scene:this,id:e});return this.meshes.set(e,t),t}}};var ke={computeDomCursor:function(e,t){let s,r;if(null==e.touches)s=e.clientX,r=e.clientY;else{if(0==e.touches.length)return null;const t=e.touches[0];s=t.clientX,r=t.clientY}let n=new DOMMatrix,i=t;for(;null!=i;){const e=window.getComputedStyle(i);n=new DOMMatrix(e.transform).multiply(n),i=i.parentElement}const o=n.inverse(),l=new DOMPointReadOnly(s,r).matrixTransform(o),h=t.getBoundingClientRect(),a=new DOMPointReadOnly(h.left,h.top).matrixTransform(o);return[l.x-a.x,l.y-a.y]}};const ze=ke;var $e={cursorUtils:ke,DragBehavior:class{constructor(e={}){this._dragging=!1,this.onDomCursorDown=e.onDomCursorDown,this.onDragProgress=e.onDragProgress,this.onDomCursorUp=e.onDomCursorUp,this.domElement=null}beginDrag(){this._dragging=!0}endDrag(){this._dragging=!1}dragging(){return this._dragging}domCursorDown(e,t){null!=this.onDomCursorDown&&this.onDomCursorDown(e,t)}domCursorMove(e,t){this.dragging()&&null!=this.onDragProgress&&this.onDragProgress(e,t)}domCursorUp(e,t){this.endDrag(),null!=this.onDomCursorUp&&this.onDomCursorUp(e,t)}linkToDom(e,t=null){if(null!=this.domElement)throw new Error("already linked to DOM");this.domElement=e;const s=t=>{t.preventDefault();const s=ze.computeDomCursor(t,e);this.domCursorDown(s,t)};e.addEventListener("mousedown",s,{passive:!1}),e.addEventListener("touchstart",s,{passive:!1});const r=t=>{const s=ze.computeDomCursor(t,e);this.domCursorMove(s,t)};null==t&&(t=e),t.addEventListener("mousemove",r,{passive:!1}),t.addEventListener("touchmove",r,{passive:!1});const n=t=>{const s=ze.computeDomCursor(t,e);this.domCursorUp(s,t)};window.addEventListener("mouseup",n),window.addEventListener("touchend",n),window.addEventListener("touchcancel",n)}}};class De{constructor(e={}){if(null==e.scene)throw new Error("scene required");const t=null==e.color?"rgba(0, 0, 0, 0.30)":e.color,s=this.mesh=e.scene.addMesh();this.set(e),s.setCustomAttribute("translation",[0,0]),s.pointShader.renderPoint=()=>{},s.lineShader.renderLine=De.makeGridLineShader({color:t})}get numVertices(){return this.mesh.x.length}get numLines(){return this.mesh.lines.length}set(e={}){const t=null==e.cellSize?1:e.cellSize,s=null==e.innerCells?3:e.innerCells,r=null==e.rows?3:e.rows,n=null==e.cols?4:e.cols,i=null==e.x0?-2:e.x0,o=null==e.y0?0:e.y0,l=null==e.primaryLineWidth?.03:e.primaryLineWidth,h=null==e.secondaryLineWidth?.008:e.secondaryLineWidth,a=this.mesh,{x:u,lineIndices:c,lineWidths:d}=function(e={}){const t=null==e.cellSize?1:e.cellSize,s=null==e.innerCells?3:e.innerCells,r=null==e.rows?3:e.rows,n=null==e.cols?4:e.cols,i=null==e.x0?-2:e.x0,o=null==e.y0?0:e.y0,l=null==e.primaryLineWidth?.022:e.primaryLineWidth,h=null==e.secondaryLineWidth?.008:e.secondaryLineWidth,a=[],u=[],c=[],d=o+r*t,p=i+n*t;function m(e,t){for(let r=0;r<e+1;r++){const n=r==e?1:s;for(let e=0;e<n;e++){const s=2*u.length;t(r,e,n,a),u.push([s,s+1]),0==e?c.push(l):c.push(h)}}}return m(r,((e,s,r,n)=>{const l=s/r,h=(o+e*t)*(1-l)+(o+(e+1)*t)*l;n.push([i,h]),n.push([p,h])})),m(n,((e,s,r,n)=>{const l=s/r,h=(i+e*t)*(1-l)+(i+(e+1)*t)*l;n.push([h,o]),n.push([h,d])})),{x:a,lineIndices:u,lineWidths:c}}({cellSize:t,innerCells:s,rows:r,cols:n,x0:i,y0:o,primaryLineWidth:l,secondaryLineWidth:h});a.pos=u,a.lines=c,a.setCustomAttribute("lineWidths",d)}static makeGridLineShader(e={}){const t=null==e.color?"black":e.color;return e=>{const s=e.ctx,r=e.a,n=e.b,i=e.camera,o=e.mesh,l=i.inferScale();s.beginPath(),s.strokeStyle=t;const h=o.getCustomAttribute("lineWidths");if(null==h)throw new Error("custom attribute lineWidths missing");const a=h[e.id],u=o.getCustomAttribute("translation"),c=[l*u[0],l*u[1]];s.lineWidth=a*l,s.moveTo(r[0]+c[0],r[1]+c[1]),s.lineTo(n[0]+c[0],n[1]+c[1]),s.closePath(),s.stroke()}}}var Le=De;var Pe={Grid:Le,Background:class{constructor(e={}){if(null==e.scene)throw new Error("scene required");const t=this.mesh=e.scene.addMesh();t.pos=[[0,0]];const s=null==e.color1?"#fcfcfc":e.color1,r=null==e.color2?"#d7d8d8":e.color2;t.pointShader.renderPoint=(e={})=>{const t=e.renderer.width,n=e.renderer.height,i=e.ctx,o=i.createRadialGradient(.5*t,.5*n,.05*t,.5*t,.5*n,.5*t);o.addColorStop(0,s),o.addColorStop(1,r),i.fillStyle=o,i.fillRect(0,0,t,n)}}}};var We=class{constructor(e,t){if(null==e)throw new Error("id required to create simplex");this.order=t.length,this.id=e,this.vertexIds=t}};const Fe=We;function qe(e){return e.sort(),e.join("_")}var Be=class{constructor(e={}){if(null==e.order)throw new Error("order required");this.order=e.order,this.simplicesByHash=new Map}forEach(e){this.simplicesByHash.forEach(e)}size(){return this.simplicesByHash.size}has(e){return this.simplicesByHash.has(qe(e.vertexIds))}add(e,t){let s=null;if(Array.isArray(e)){if(null==t)throw new Error("id required");s=e,e=new Fe(t,s)}else{if(s=e.vertexIds,null==s)throw new Error(`vertexIds required ${e}`);t=e.id}if(s.length!=this.order)throw new Error(`expected ${this.order} vertices, found ${s.length}`);const r=qe(s);return this.simplicesByHash.set(r,e),e}};const Ne=Be;const Re=Be,Oe=class{constructor(e){this.id=e,this.edges=new Ne({order:2}),this.triangles=new Ne({order:3})}addTriangle(e,t){this.triangles.add(e,t)}addEdge(e,t){this.edges.add(e,t)}};var Ge=class{constructor(e={}){this.vertices=new Map,this.edges=new Re({order:2}),this.triangles=new Re({order:3});(e.edges??[]).forEach(((e,t)=>{this.addEdge(t,e)}));(e.triangles??[]).forEach(((e,t)=>{this.addTriangle(t,e)}))}numVertices(){return this.vertices.size}numEdges(){return this.edges.size()}numTriangles(){return this.triangles.size()}getVertexById(e,t=!1){let s=this.vertices.get(e);return null==s&&t&&(s=new Oe(e),this.vertices.set(e,s)),s}addEdge(e,t){const s=this.edges.add(t,e);return t.forEach((e=>{this.getVertexById(e,!0).addEdge(s)})),s}addTriangle(e,t){const s=this.triangles.add(t,e);return t.forEach((e=>{this.getVertexById(e,!0).addTriangle(s)})),s}};const Xe=Ge,Ue=Be;var He={math:ye,ui:$e,shaders:be,background:Pe,sorted:{makeSortedElements:function(e={}){if(null==e.sortedVertexIds)throw new Error("sortedVertexIds required");if(null==e.triangles)throw new Error("triangles required");if(null==e.edges)throw new Error("edges required");const t=e.sortedVertexIds,s=new Map;t.forEach(((e,t)=>{s.set(e,t)}));const r=new Xe({triangles:e.triangles}),n=new Xe({edges:e.edges}),i=[],o=new Ue({order:3}),l=new Ue({order:2});return t.forEach((e=>{const t=r.getVertexById(e,!0).triangles,h=n.getVertexById(e,!0).edges,a=[];t.forEach((e=>{a.push(e)})),h.forEach((e=>{a.push(e)})),a.sort(((e,t)=>{const r=e.vertexIds.map((e=>s.get(e))),n=t.vertexIds.map((e=>s.get(e))),i=Math.max(...r),o=Math.max(...n);return i<o?1:i==o?0:-1})),a.forEach((e=>{if(2==e.order){const t=e;l.has(t)||(i.push(t),l.add(t))}else{const t=e;o.has(t)||(i.push(t),o.add(t))}})),i.push({order:1,id:e})})),i},MeshTopology:Ge,Simplex:We,Simplices:Be},core:Ae,Renderer:Ae.Renderer,Camera:Ae.Camera,Scene:Ae.Scene};var je=class{constructor(e={}){this.targetCenterX=null,this.currentCenterX=null,this.active=!0,this.visibleWorldWidth=e.visibleWorldWidth??3.8,this.targetCenterY=e.targetCenterY??1,this.offsetX=e.offsetX??0,this.fullGrid=!1,this.centeringSpeedFactor=.5}step(e={}){if(!this.active)return;const t=e.renderer,s=e.camera,r=e.mesh,n=e.floor,i=e.grid;let o=[0,0];r.pos.length>0&&(o=r.computeCenter());const l=o[0]+this.offsetX;isNaN(l)||(this.targetCenterX=l),null==this.currentCenterX?this.currentCenterX=this.targetCenterX:this.currentCenterX+=(this.targetCenterX-this.currentCenterX)*this.centeringSpeedFactor;const h=[this.currentCenterX,this.targetCenterY];s.center({worldCenter:h,worldWidth:this.visibleWorldWidth,viewportWidth:t.width,viewportHeight:t.height});const a=s.domToWorldSpace([t.width,0]),u=s.domToWorldSpace([0,t.height]),[c,d]=u,p=Math.floor(c)-1;let m=Math.floor(d);this.fullGrid||m<0&&(m=0);const[f,g]=a,w=f,y=w-p,x=g-m,v=Math.ceil(x)+1,E=Math.ceil(y)+1;i.set({x0:p,y0:m,rows:v,cols:E,innerCells:i.innerCells,primaryLineWidth:i.primaryLineWidth,secondaryLineWidth:i.secondaryLineWidth}),n.mesh.pos=[[p,0],[w,0]]}};class Ye{constructor(e={}){if(null==e.scene)throw new Error("scene required");const t=this.scene=e.scene,s=this.mesh=t.addMesh();s.pos=[[-10,0],[10,0]],s.lines=[[0,1]],s.lineShader.renderLine=Ye.makeFloorLineShaderFunction({width:e.width,color:e.color}),s.pointShader.renderPoint=()=>{},s.setCustomAttribute("translation",[0,0])}static makeFloorLineShaderFunction(e={}){const t=e.width??.055,s=e.color??"black";return e=>{const r=e.ctx,n=e.a,i=e.b,o=e.camera,l=e.mesh,h=o.inferScale(),a=l.getCustomAttribute("translation"),u=[h*a[0],h*a[1]];r.strokeStyle=s,r.lineWidth=h*t,r.beginPath(),r.moveTo(n[0]+u[0],n[1]+u[1]),r.lineTo(i[0]+u[0],i[1]+u[1]),r.stroke()}}}var Je=Ye;const Ke=He;var Qe=class{constructor(e={}){this.system=e.system,this.renderVertexIds=e.renderVertexIds??!1}makePointShaderFunction(e={}){const t=e.radius??.028,s=e.borderColor??"black",r=e.fillColor??"white",n=e.borderWidth??.023;return e=>{const i=e.ctx,o=e.p,l=e.camera.inferScale();if(function(e,t,s,r,n,i,o){const l=(r+.5*n)*t;e.fillStyle=o,e.beginPath(),e.arc(s[0],s[1],l,0,2*Math.PI),e.fill(),e.lineWidth=n*t,e.strokeStyle=i,e.stroke()}(i,l,o,t,n,s,r),this.renderVertexIds){i.beginPath(),i.fillStyle="rgba(255, 255, 255, 0.8)",i.arc(o[0],o[1],.1*l,0,2*Math.PI),i.fill();const t=Math.floor(.15*l);i.font=`${t}px monospace`,i.fillStyle="black",i.textAlign="center",i.textBaseline="middle",i.fillText(e.id,o[0],o[1])}}}getVertexPos(e){const t=this.system.pos.slot.f32(),s=e*this.system.spaceDim;return[t[s],t[s+1]]}get numVertices(){return this.system.numVertices}hitTest(e,t=.31){const s=this.numVertices;if(0==s)return null;let r=null,n=1/0;const i=t*t;for(let t=0;t<s;t++){const s=this.getVertexPos(t),o=Ke.math.Vec2.sub(s,e),l=Ke.math.Vec2.quadrance(o);l<i&&l<n&&(r=t,n=l)}return r}setVertexPos(e,t){if(null==e)throw new Error("vertex id required");const s=this.system.pos.slot.f32(),r=2*e;s[r]=t[0],s[r+1]=t[1]}setVertexVel(e,t){const s=this.system.vel.slot.f32(),r=2*e;s[r]=t[0],s[r+1]=t[1]}};const Ze=He,et=je,tt=Je,st=Qe,rt=class{constructor(e={}){this.system=e.system}makeLineShaderFunction(e={}){const t=e.activeMuscleColor??[255,0,0],s=e.inactiveMuscleColor??[0,0,255],r=e.borderColor??"black";return(e={})=>{const n=e.ctx,i=e.a,o=e.b,l=e.camera.inferScale(),h=e.mesh.getCustomAttribute("lineIdToMuscleId")[e.id];if(null==h){!function(e,t,s,r,n,i){e.beginPath(),e.lineJoin="round",e.lineCap="round",e.strokeStyle=i,e.lineWidth=n*t,e.moveTo(s[0],s[1]),e.lineTo(r[0],r[1]),e.closePath(),e.stroke()}(n,l,i,o,.029,r)}else{const a=t,u=s,c=.065,d=.017,p="muscleIntensity",m=e.mesh.getCustomAttribute(p);if(null==m)throw new Error(`muscle intensity attribute (${p}) not found, call setCustomAttribute("${p}", value) before rendering.`);if(!Array.isArray(m))throw new Error("muscle intensity attribute must be an array with values for each fiber, found "+typeof m);!function(e,t,s,r,n,i,o,l,h,a){e.beginPath(),e.lineCap="butt",e.strokeStyle=l,e.lineWidth=(i+2*o)*t,e.moveTo(s[0],s[1]),e.lineTo(r[0],r[1]),e.stroke(),e.beginPath();const u=(1-n)*h[0]+n*a[0],c=(1-n)*h[1]+n*a[1],d=(1-n)*h[2]+n*a[2];e.strokeStyle=`rgb(${u}, ${c}, ${d})`,e.lineWidth=i*t,e.moveTo(s[0],s[1]),e.lineTo(r[0],r[1]),e.stroke()}(n,l,i,o,m[h],c,d,r,a,u)}}}};function nt(e){return e.sort(),e.join("_")}function it(e){if(7!=e.length)throw new Error(`invalid hex string ${e}`);if("#"!=e[0])throw new Error(`invalid hex string ${e}, expected #, found ${e[0]}`);e=e.substring(1);return[parseInt(e.substring(0,2),16),parseInt(e.substring(2,4),16),parseInt(e.substring(4,6),16)]}var ot=class{constructor(e={}){if(null==e.system)throw new Error("system required");this.system=e.system;const t=e.sortedVertexIds;this.sortedVertexIds=t,null!=e.vertexDepths&&this.setSortedVertexIdsFromVertexDepths(e.vertexDepths);const s=e.headless??!1;this.vertices=new st({system:this.system,renderVertexIds:e.renderVertexIds??!1}),this.lines=new rt({system:this.system});const r=new Ze.Renderer({headless:s});this.renderer=r,this.domElement=r.domElement,this.setSize({width:e.width??400,height:e.height??400});const n=new Ze.Scene;this.scene=n;const i=new Ze.Camera;this.camera=i;const o=e.borderColor??"black",l=o,h=e.fillColor??"white",a=e.gridColor??"#acadad";let u,c,d=e.activeMuscleColor??[255,0,0],p=e.inactiveMuscleColor??[250,190,190];"string"==typeof d&&(d=it(d)),"string"==typeof p&&(p=it(p)),null!=e.backgroundColor?(u=e.backgroundColor,c=e.backgroundColor):(u=e.backgroundCenterColor??"#fcfcfc",c=e.backgroundOuterColor??"#d7d8d8"),new Ze.background.Background({scene:n,color1:u,color2:c});const m=this.grid=new Ze.background.Grid({scene:n,x0:-3,y0:0,rows:4,cols:10,innerCells:2,primaryLineWidth:.022,secondaryLineWidth:.005,color:a});m.innerCells=2,m.primaryLineWidth=.022,m.secondaryLineWidth=.005,this.floor=new tt({scene:n,color:l});const f=n.addMesh();this.mesh=f,f.pointShader.renderPoint=this.vertices.makePointShaderFunction({borderColor:o,fillColor:h}),f.triangleShader.renderTriangle=(e={})=>{const t=e.ctx,s=e.a,r=e.b,n=e.c;t.beginPath(),t.fillStyle=h,t.moveTo(...s),t.lineTo(...r),t.lineTo(...n),t.closePath(),t.fill()},f.lineShader.renderLine=this.lines.makeLineShaderFunction({activeMuscleColor:d,inactiveMuscleColor:p,borderColor:o});if(e.draggable??!0){const t=this.dragBehavior=new Ze.ui.DragBehavior({onDomCursorDown:(e,s)=>{if("button"in s&&0!=s.button)return;const r=this.system,n=i.domToWorldSpace(e),o=this.hitTestVertex(n);null!=o&&(this.fixVertex(o),t.beginDrag(),this.setVertexPos(r.vertices.fixedVertexId,[n[0],Math.max(0,n[1])]))},onDragProgress:e=>{const t=this.system,s=i.domToWorldSpace(e);this.setVertexPos(t.vertices.fixedVertexId,[s[0],Math.max(0,s[1])])},onDomCursorUp:()=>{this.freeVertex()}});if(!s){const s=e.domElementForMoveEvents??null;t.linkToDom(r.domElement,s)}}this.tracker=new et}setSortedVertexIdsFromVertexDepths(e){if(e.length!=this.system.numVertices)throw new Error(`invalid size for depths, found ${e.length}, expected ${this.system.numVertices}`);const t=e.map(((e,t)=>({depth:e,index:t})));t.sort(((e,t)=>t.depth-e.depth));const s=t.map((e=>e.index));this.sortedVertexIds=s}setSize(e={}){this.renderer.setSize({width:e.width,height:e.height})}render(){(null==this.needsMeshUpdate||this.needsMeshUpdate)&&(this._updateMesh({triangles:this.system.getTrianglesArray(),muscles:this.system.getMusclesArray()}),this.needsMeshUpdate=!1);const e=this.renderer,t=this.scene,s=this.camera,r=this.mesh;this._updateFromSystem(),null!=this.dragBehavior&&this.dragBehavior.dragging()||this.tracker.step({mesh:r,camera:s,floor:this.floor,grid:this.grid,renderer:this.renderer}),e.render(t,s)}_updateMesh(e){const t=this.mesh,s=this.system.numVertices;if(!Number.isInteger(s)||s<0)throw new Error(`invalid number of vertices ${s}`);null!=e.pos&&(t.pos=e.pos),t.triangles=e.triangles,t.lines=function(e){const t=new Map;function s(e,s){const r=nt([e,s]);t.set(r,[e,s])}return e.forEach((e=>{s(e[0],e[1]),s(e[1],e[2]),s(e[0],e[2])})),Array.from(t.values())}(e.triangles),Array.prototype.push.apply(t.lines,e.muscles);const r=new Map;e.muscles.forEach(((e,t)=>{r.set(nt(e),t)}));const n=[];t.setCustomAttribute("lineIdToMuscleId",n),t.lines.forEach((e=>{const t=nt(e),s=r.get(t);n.push(s)}));let i=this.sortedVertexIds;if(null==i){i=[];for(let e=0;e<s;e++)i.push(e)}if(i.length!=s)throw new Error(`invalid size for sortedVertexIds, found ${i.length}, expected ${s}`);t.sortedElements=Ze.sorted.makeSortedElements({sortedVertexIds:i,triangles:t.triangles,edges:t.lines});const o=[],l=this.system.numMuscles;for(let e=0;e<l;e++)o.push(1);t.setCustomAttribute("muscleIntensity",o)}_updateFromSystem(){this._updateVertexPositionsFromSystem(),this._updateMuscleIntensityFromSystem()}_updateVertexPositionsFromSystem(){const e=this.mesh,t=this.system;if(0==t.numVertices)e.pos=[];else{const s=t.pos.toArray();e.pos=s}}_updateMuscleIntensityFromSystem(){const e=this.mesh,t=this.system,s=t.numMuscles;if(!Number.isInteger(s)||s<0)throw new Error(`invalid number of muscles ${s}`);let r=[];if(s>0)if(t.a){const e=t.a.slot.f32();for(let t=0;t<s;t++)r.push(e[t])}else r=new Array(s).fill(1);e.setCustomAttribute("muscleIntensity",r)}hitTestVertex(e,t=.31){return this.vertices.hitTest(e,t)}setVertexPos(e,t){this.vertices.setVertexPos(e,t)}setVertexVel(e,t){this.vertices.setVertexVel(e,t)}fixVertex(e){const t=this.system;this.setVertexVel(e,[0,0]),null==e&&(e=-1),t.vertices.fixVertex(e)}freeVertex(){this.system.vertices.freeVertex()}},lt={SystemViewport:ot,VertexRenderer:Qe,Tracker:je};return e({System:ie,Vertices:Z,mmgrten:Q,SystemViewport:lt.SystemViewport,mm2d:He,render:lt})}));
