/**
 * algovivo
 * (c) 2023 Junior Rojas
 * License: MIT
 * 
 * Built from commit 5ebdda8f6d42428ff385d709ff45cb0bacc10ffd
 */
function e(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}class t{constructor(e,t){this.list=e,this.data=t,this.next=null,this.prev=null}append(e){const s=new t(this.list,e);return this.list.last==this&&(this.list.last=s),s.next=this.next,s.prev=this,null!=this.next&&(this.next.prev=s),this.next=s,this.list.size++,s}prepend(e){const s=new t(this.list,e);return this.list.first==this&&(this.list.first=s),s.next=this,s.prev=this.prev,null!=this.prev&&(this.prev.next=s),this.prev=s,this.list.size++,s}remove(){null!=this.prev&&(this.prev.next=this.next),null!=this.next&&(this.next.prev=this.prev),this.list.first==this&&(this.list.first=this.next),this.list.last==this&&(this.list.last=this.prev),this.list.size--,this.next=null,this.prev=null}}var s=t;const r=s;class i{constructor(e){this.list=e,this.nextNode=this.list.first}next(){if(null==this.nextNode)return{done:!0};{const e={done:!1,value:this.nextNode.data};return this.nextNode=this.nextNode.next,e}}}class n{constructor(){this.first=null,this.last=null,this.size=0}isEmpty(){if(null==this.first&&null!=this.last||null!=this.first&&null==this.last)throw Error("inconsistent first last state");return null==this.first}append(e){return this.isEmpty()?this.setSingleton(e):this.last.append(e)}prepend(e){return this.isEmpty()?this.setSingleton(e):this.first.prepend(e)}setSingleton(e){const t=new r(this,e);return this.first=t,this.last=t,this.size=1,t}iter(){return new i(this)}*[Symbol.iterator](){const e=this.iter();let t=e.next();for(;!t.done;)yield t.value,t=e.next()}}var o,l,h,a,u,c,d={List:n,Node:s};function p(){if(l)return o;l=1;const e=m();return o=class extends e{constructor(e={}){super(e)}isFree(){return!1}free(){let e=this.appendFree(this.ptr,this.size);this.remove();const t=e.prev(),s=e.next();return null!=t&&t.isFree()&&(e=t.merge(e)),null!=s&&s.isFree()&&(e=e.merge(s)),e}}}function m(){if(a)return h;a=1;return h=class{constructor(e={}){this.manager=e.manager,this.ptr=e.ptr,this.size=e.size,this.node=e.node}numBytes(){return this.size}prev(){const e=this.node.prev;return null!=e?e.data:null}next(){const e=this.node.next;return null!=e?e.data:null}appendReserved(e,t){const s=p(),r=this.node.append(null),i=new s({manager:this.manager,ptr:e,size:t,node:r});return r.data=i,this.manager._addReservedSlot(i),i}appendFree(e,t){const s=f(),r=this.node.append(null),i=new s({manager:this.manager,ptr:e,size:t,node:r});return r.data=i,this.manager._addFreeSlot(i),i}remove(){this.node.remove(),this.node.data=null,this.node=null,this.isFree()?this.manager._removeFreeSlot(this):this.manager._removeReservedSlot(this)}toTypedArray(e){const t=this.size,s=e.BYTES_PER_ELEMENT;if(t%s!=0)throw new Error(`size in bytes must be a multiple of ${s}, found ${t}`);const r=this.ptr;return new e(this.manager.array,r,t/s)}f32(){return this.toTypedArray(Float32Array)}u32(){return this.toTypedArray(Uint32Array)}},h}function f(){if(c)return u;c=1;const e=m();return u=class extends e{constructor(e={}){super(e)}isFree(){return!0}reserve(e){const t=this.numBytes();if(e>t)throw new Error(`cannot reserve ${e} bytes, only ${t} bytes are available`);const s=this.appendReserved(this.ptr,e);return s.appendFree(this.ptr+e,t-e),this.remove(),s}merge(e){if(!this.isFree()||!e.isFree())throw new Error("only free slots can be merged");if(this.next()!=e)throw new Error("only adjacent slots can be merged");const t=e.appendFree(this.ptr,this.size+e.size);return this.remove(),e.remove(),t}}}const g=d,w=f();var y={linked:d,MemoryManager:class{constructor(e,t){this.array=e,null==t&&(t=0),this.ptrToSlot=new Map,this.slots=new g.List,this.freeSlots=new g.List,this.reservedSlots=new g.List;const s=new w({manager:this,ptr:t,size:e.byteLength-t}),r=this.slots.append();r.data=s,s.node=r;const i=this.freeSlots.append();i.data=s,s.freeNode=i}numReservedSlots(){return this.reservedSlots.size}numFreeSlots(){return this.freeSlots.size}numFreeBytes(){let e=0;const t=this.freeSlots.iter();let s=t.next();for(;!s.done;){e+=s.value.size,s=t.next()}return e}numReservedBytes(){let e=0;const t=this.reservedSlots.iter();let s=t.next();for(;!s.done;){e+=s.value.size,s=t.next()}return e}mallocBytes(e){return this._malloc(e)}malloc32(e){return this.mallocBytes(4*e)}_addReservedSlot(e){const t=this.reservedSlots.append(e);e.reservedNode=t}_removeReservedSlot(e){if(null==e.reservedNode)throw new Error("reservedNode cannot be null");e.reservedNode.remove()}_addFreeSlot(e){const t=this.freeSlots.append(e);e.freeNode=t}_removeFreeSlot(e){if(null==e.freeNode)throw new Error("freeNode cannot be null");e.freeNode.remove()}_malloc(e){if(!Number.isInteger(e))throw new Error(`expected integer, found ${e}`);let t=null;const s=this.freeSlots.iter();let r=s.next();for(;!r.done;){const i=r.value;if(i.size>=e){t=i;break}r=s.next()}if(null==t)throw new Error("no valid free slot available");return t.reserve(e)}malloc(e){const t=this._malloc(e);return this.ptrToSlot.set(t.ptr,t),t.ptr}free(e){this.ptrToSlot.get(e).free()}},FreeSlot:f(),ReservedSlot:p()};class x{constructor(e={}){const t=e.engine;if(null==t)throw new Error("engine required to create IntTuple");this.engine=t;const s=e.slot;if(null==s)throw new Error("slot required to create IntTuple");this.slot=s,this.ptr=s.ptr,this.length=e.length}forEach(e){for(let t=0;t<this.length;t++)e(this.get(t),t)}equal(e){if(e instanceof x){for(let t=0;t<this.length;t++){if(this.get(t)!=e.get(t))return!1}return!0}if(Array.isArray(e)){for(let t=0;t<this.length;t++){if(this.get(t)!=e[t])return!1}return!0}return!1}toString(){return this.slot.u32().toString()}toArray(){const e=[];return this.forEach((t=>{e.push(t)})),e}typedArray(){return this.slot.u32()}set(e,t){this.typedArray()[e]=t}get(e){return this.typedArray()[e]}dispose(){this.slot.free()}}var v=x;function E(e,t,s,r){if(t==s.length-1)for(let i=0;i<s[t];i++)e.push(r);else for(let i=0;i<s[t];i++){const i=[];e.push(i),E(i,t+1,s,r)}}var S={inferShape:function(e){const t=[];let s=e;for(;Array.isArray(s);)t.push(s.length),s=s[0];return t},makeNdArray:function(e,t){let s=e;e instanceof v&&(s=e.toArray());const r=[];return E(r,0,s,t),r},numelOfShape:function(e){let t=1;return e.forEach((e=>{t*=e})),t},getArrElem:function e(t,s){if(!Array.isArray(s))throw new Error(`expected array, found ${typeof s}: ${s}`);return 0==s.length?t:e(t[s[0]],s.slice(1))},setArrElem:function e(t,s,r){if(!Array.isArray(s))throw new Error(`expected array, found ${typeof s}: ${s}`);if(1!=s.length)return e(t[s[0]],s.slice(1),r);t[s]=r}};const b=v;class _{constructor(e){if(null==e)throw new Error("shape required");if(!(e instanceof b))throw new Error(`IntTuple shape expected, found ${typeof e}: shape`);this.shape=e,this.done=!1,this.idx=[],e.forEach((e=>{this.idx.push(0)}))}next(){const e=this.shape;for(let t=0;t<e.length;t++){const s=e.length-1-t;if(this.idx[s]<e.get(s)-1)return void this.idx[s]++;if(0==s)return void(this.done=!0);this.idx[s]=0}}static shapeForEach(e,t){const s=new _(e);for(;!s.done;)t(s.idx),s.next()}}const I=S,V=_,C=v;class A{constructor(e={}){const t=e.engine;if(null==t)throw new Error("engine required to create tensor");this.engine=t;const s=e.shape;if(null==s)throw new Error("shape required to create tensor");if(s instanceof C)this.shape=s;else{if(!Array.isArray(s))throw new Error(`invalid shape type ${typeof s}: ${s}`);this.shape=t.intTuple(s)}this.order=this.shape.length;const r=I.numelOfShape(this.shape);this.numel=r;const i=e.slot;if(r>0&&null==i)throw new Error("memory slot required to create tensor");this.slot=e.slot;const n=e.stride;if(null!=n){if(!(n instanceof C))throw new Error(`expected IntTuple stride, found ${typeof n}: ${n}`);this.stride=n}else this.setDefaultStride()}get ptr(){return this.slot.ptr}get wasmInstance(){return this.engine.wasmInstance}isScalar(){return 0==this.order}fill_(e){this.wasmInstance.exports.fill_(this.numel,this.ptr,e)}clamp_(e={}){const t=e.min,s=e.max;this.wasmInstance.exports.clamp(this.numel,this.ptr,this.ptr,t,s,null!=t,null!=s)}zero_(){this.fill_(0)}flattenIdx(e){let t,s,r=!1;if(Array.isArray(e)&&(t=this.engine.intTuple(e),r=!0),!(t instanceof C))throw new Error(`cannot handle ${typeof t}: ${t}`);return s=this.engine.wasmInstance.exports.flatten_idx(this.order,t.slot.ptr,this.stride.slot.ptr),r&&t.dispose(),s}typedArray(){return this.slot.f32()}toArray(){if(0==this.numel)return[];const e=I.makeNdArray(this.shape,0);return this.forEach((t=>{const s=this.get(t);I.setArrElem(e,t,s)})),e}get(e){const t=this.flattenIdx(e);return this.typedArray()[t]}item(){if(!this.isScalar())throw new Error(`item() only works for scalars, found tensor with shape ${this.shape}`);return this.get([0])}setDefaultStride(){let e=1;const t=this.order,s=[];for(let e=0;e<t;e++)s.push(0);for(let r=0;r<t;r++){const i=t-1-r;s[i]=e,e*=this.shape.get(i)}this.stride=this.engine.intTuple(s)}setFromArray(e){if(0==this.numel)return;if(this.isScalar()){if("number"!=typeof e)throw new Error(`expected number, found ${typeof e}: ${e}`);this.set([0],e)}else{if(!Array.isArray(e))throw new Error(`expected array, found ${typeof e}: ${e}`);const t=I.inferShape(e);if(!this.shape.equal(t))throw new Error(`inconsistent shapes ${t} != ${this.shape}`);this.forEach((t=>{const s=I.getArrElem(e,t);this.set(t,s)}))}}set(e,t){if(null==t&&Array.isArray(e))this.setFromArray(e);else{const s=this.flattenIdx(e);this.typedArray()[s]=t}}forEach(e){V.shapeForEach(this.shape,e)}squeeze(e){-1==e&&(e=this.shape.length-1);const t=this.shape.get(e);if(1!=t)throw new Error(`cannot squeeze a dimension that is not equal to 1, shape[${e}] = ${t}`);const s=[];for(let t=0;t<this.order;t++)e!=t&&s.push(this.shape.get(t));return new A({engine:this.engine,shape:s,slot:this.slot})}unsqueeze(e){-1==e&&(e=this.shape.length-1);const t=[];for(let s=0;s<this.order;s++)t.push(this.shape.get(s)),e==s&&t.push(1);return new A({engine:this.engine,shape:t,slot:this.slot})}add(e,t){this.engine.functional.add(this,e,t)}sum(e){this.engine.wasmInstance.exports.sum(this.numel,this.slot.ptr,e.slot.ptr)}dispose(){if(null==this.slot)throw new Error("tensor already disposed");this.slot.free(),this.slot=null,this.shape.dispose(),this.stride.dispose()}}var M=A;var T=class{constructor(e={}){const t=this.engine=e.engine;this.wasmInstance=t.wasmInstance}matvec(e,t,s){const r=e.shape.get(0),i=e.shape.get(1),n=t.shape.get(0),o=s.shape.get(0);if(r!=o)throw new Error(`inconsistent output size ${r} != ${o}`);if(i!=n)throw new Error(`inconsistent input size ${i} != ${n}`);this.wasmInstance.exports.matvec(r,i,e.stride.ptr,e.ptr,t.stride.ptr,t.ptr,s.stride.ptr,s.ptr)}mm(e,t,s){const r=e.shape.get(0),i=e.shape.get(1),n=t.shape.get(1);this.wasmInstance.exports.mm(r,i,n,e.stride.ptr,e.ptr,t.stride.ptr,t.ptr,s.stride.ptr,s.ptr)}relu(e,t){this.wasmInstance.exports.relu(e.numel,e.ptr,t.ptr)}tanh(e,t){const s=e.numel,r=e.typedArray(),i=t.typedArray();for(let e=0;e<s;e++)i[e]=Math.tanh(r[e])}add(e,t,s){this.wasmInstance.exports.add(e.numel,e.ptr,t.ptr,s.ptr)}sum(e,t){this.wasmInstance.exports.sum(e.numel,e.ptr,t.ptr)}sumBackward(e,t,s,r){this.wasmInstance.exports.sum_backward(e.numel,e.ptr,t.ptr,s.ptr,r.ptr)}};var k=class{constructor(){}};const z=k;var $=class extends z{constructor(e,t){super(),this.nn=e,this.layers=t}forward(e){let t=e;return this.layers.forEach((e=>{t=e.forward(t)})),t}dispose(){this.layers.forEach((e=>{e.dispose()}))}};const D=k;var L=class extends D{constructor(e,t,s){super(),this.nn=e,this.inputSize=t,this.outputSize=s;const r=this.nn.engine;this.weight=r.zeros([s,t]),this.bias=r.zeros([s]),this.output=r.zeros([s])}forward(e){const t=this.nn.engine.functional;return t.matvec(this.weight,e,this.output),t.add(this.output,this.bias,this.output),this.output}dispose(){this.weight.dispose(),this.bias.dispose(),this.output.dispose()}};const W=k;var P=class extends W{constructor(e){super(),this.nn=e,this.output=null}forward(e){const t=this.nn.engine;return null==this.output&&(this.output=t.zerosLike(e)),t.functional.relu(e,this.output),this.output}dispose(){null!=this.output&&this.output.dispose()}};const F=k;var q=class extends F{constructor(e){super(),this.nn=e,this.output=null}forward(e){const t=this.nn.engine;return null==this.output&&(this.output=t.zerosLike(e)),t.functional.tanh(e,this.output),this.output}dispose(){null!=this.output&&this.output.dispose()}};const B=$,O=L,N=P,R=q;const G=y,X=S,U=M,H=v,j=T,Y=class{constructor(e={}){this.engine=e.engine}Linear(e,t){return new O(this,e,t)}ReLU(){return new N(this)}Tanh(){return new R(this)}Sequential(){const e=Array.from(arguments);return new B(this,e)}};const J=class{constructor(e={}){null!=e.wasmInstance&&this.init(e),this.env={}}init(e={}){if(null==e.wasmInstance)throw new Error("wasmInstance required");this.wasmInstance=e.wasmInstance;const t=e.wasmInstance.exports.memory.buffer,s=new G.MemoryManager(t,e.wasmInstance.exports.__heap_base);this.mgr=s,this.functional=this.F=new j({engine:this}),this.nn=new Y({engine:this}),this._mergeF()}_mergeF(){Object.getOwnPropertyNames(Object.getPrototypeOf(this.F)).forEach((e=>{"constructor"!=e&&(this[e]=this.F[e])}))}tensor(e){const t=X.inferShape(e),s=this.intTuple(t),r=X.numelOfShape(t),i=this.mgr.malloc32(r),n=new U({engine:this,shape:s,slot:i});return n.setFromArray(e),n}intTuple(e){if(!Array.isArray(e))throw new Error(`expected array, found ${typeof e}: ${e}`);const t=e.length,s=this.mgr.malloc32(t),r=new H({engine:this,length:t,slot:s});for(let s=0;s<t;s++)r.set(s,e[s]);return r}zerosLike(e){if(!(e instanceof U))throw new Error(`expected tensor, found ${typeof e}: ${e}`);return this.zeros(e.shape.toArray())}empty(e){let t;if(e instanceof H)t=e;else{if(!Array.isArray(e))throw new Error(`expected array, found ${typeof e}: ${e}`);t=this.intTuple(e)}const s=X.numelOfShape(t),r=this.mgr.malloc32(s);return new U({engine:this,shape:t,slot:r})}zeros(e){const t=this.empty(e);return t.zero_(),t}ones(e){const t=this.empty(e);return t.fill_(1),t}};var K={engine:function(e={}){return new J({wasmInstance:e.wasmInstance})},Engine:J,Tensor:M,mmgr:y,utils:S};var Q=class{constructor(e={}){const t=e.ten;if(null==t)throw new Error("ten required");this.ten=t,this.spaceDim=e.spaceDim??2,this.vertexMass=e.vertexMass??6.0714287757873535,this.pos0=null,this.pos1=null,this.vel0=null,this.vel1=null,this.posGrad=null,this.posTmp=null,this._fixedVertexId=-1}getVertexPos(e){const t=[];for(let s=0;s<this.spaceDim;s++)t.push(this.pos.get([e,s]));return t}set fixedVertexId(e){throw new Error("use fixVertex instead")}get fixedVertexId(){return this._fixedVertexId}fixVertex(e){this._fixedVertexId=e}freeVertex(){this._fixedVertexId=-1}get pos(){return this.pos0}get vel(){return this.vel0}get numVertices(){return null==this.pos0?0:this.pos0.shape.get(0)}updateTmpBuffers(){if(null==this.pos0)throw new Error("pos0 required");const e=this.numVertices,t=this.spaceDim,s=this.ten,r=s.zeros([e,t]);null!=this.posGrad&&this.posGrad.dispose(),this.posGrad=r;const i=s.zeros([e,t]);null!=this.posTmp&&this.posTmp.dispose(),this.posTmp=i}get wasmInstance(){return this.ten.wasmInstance}get memoryManager(){return this.ten.mgr}set(e){const t=this.ten,s=this.spaceDim;if(null==e)throw new Error("pos required");const r=e.length,i=t.tensor(e);null!=this.pos0&&this.pos0.dispose(),this.pos0=i;const n=t.zeros([r,s]);null!=this.pos1&&this.pos1.dispose(),this.pos1=n;const o=t.zeros([r,s]);null!=this.vel0&&this.vel0.dispose(),this.vel0=o;const l=t.zeros([r,s]);null!=this.vel1&&this.vel1.dispose(),this.vel1=l,this.updateTmpBuffers()}addVertex(e={}){const t=this.ten,s=this.numVertices,r=this.spaceDim,i=t.empty([s+1,r]),n=t.empty([s+1,r]),o=t.empty([s+1,r]),l=t.empty([s+1,r]);for(let e=0;e<s;e++)for(let t=0;t<r;t++)i.set([e,t],this.pos0.get([e,t])),n.set([e,t],this.vel0.get([e,t])),o.set([e,t],this.pos1.get([e,t])),l.set([e,t],this.vel1.get([e,t]));const h=e.pos??[0,0],a=e.vel??[0,0];for(let e=0;e<r;e++)i.set([s,e],h[e]),o.set([s,e],h[e]),n.set([s,e],a[e]),l.set([s,e],a[e]);null!=this.pos0&&this.pos0.dispose(),this.pos0=i,null!=this.vel0&&this.vel0.dispose(),this.vel0=n,null!=this.pos1&&this.pos1.dispose(),this.pos1=o,null!=this.vel1&&this.vel1.dispose(),this.vel1=l,this.updateTmpBuffers()}dispose(){null!=this.pos0&&(this.pos0.dispose(),this.pos0=null),null!=this.pos1&&(this.pos1.dispose(),this.pos1=null),null!=this.vel0&&(this.vel0.dispose(),this.vel0=null),null!=this.vel1&&(this.vel1.dispose(),this.vel1=null),null!=this.posGrad&&(this.posGrad.dispose(),this.posGrad=null),null!=this.posTmp&&(this.posTmp.dispose(),this.posTmp=null)}};var Z=class{constructor(e={}){const t=e.ten;if(null==t)throw new Error("ten required");this.ten=t,this.muscles=null,this.k=Math.fround(90),this.l0=null,this.a=null}get wasmInstance(){return this.ten.wasmInstance}get memoryManager(){return this.ten.mgr}get numMuscles(){return null==this.muscles?0:this.muscles.u32().length/2}set(e={}){if(null==e.indices)throw new Error("indices required");const t=e.indices,s=t.length,r=this.numMuscles,i=this.memoryManager,n=this.ten;null!=e.k&&(this.k=e.k);const o=i.malloc32(2*s);null!=this.muscles&&this.muscles.free(),this.muscles=o;const l=o.u32();if(t.forEach(((e,t)=>{const s=2*t;l[s]=e[0],l[s+1]=e[1]})),null!=this.l0&&this.l0.dispose(),this.l0=null,0!=s){const t=n.zeros([s]);this.l0=t,null==e.l0?this.wasmInstance.exports.l0_of_pos(this.numVertices,e.pos.ptr,s,this.muscles.ptr,this.l0.ptr):this.l0.set(e.l0)}const h=e.keepA??!1;if(s!=r){if(h)throw new Error(`keepA can only be true when the number of muscles is the same (${s} != ${r})`);if(null!=this.a&&(this.a.dispose(),this.a=null),0!=s){const e=n.zeros([s]);this.a=e,e.fill_(1)}}else 0==s?(null!=this.a&&this.a.dispose(),this.a=null):h||this.a.fill_(1)}dispose(){null!=this.muscles&&(this.muscles.free(),this.muscles=null),null!=this.l0&&(this.l0.dispose(),this.l0=null),null!=this.a&&(this.a.dispose(),this.a=null)}};const ee=K,te=Q,se=Z,re=class{constructor(e={}){const t=e.ten;if(null==t)throw new Error("ten required");this.ten=t,this.simplexOrder=e.simplexOrder??3,this.triangles=null,this.rsi=null,this.mu=null,this.lambda=null}get wasmInstance(){return this.ten.wasmInstance}get memoryManager(){return this.ten.mgr}get numElements(){return null==this.indices?0:this.indices.u32().length/this.simplexOrder}get numTriangles(){return this.numElements}get indices(){return this.triangles}toStepArgs(){const e=this.numElements;return[e,0==e?0:this.indices.ptr,0==e?0:this.rsi.ptr,0==e?0:this.mu.ptr,0==e?0:this.lambda.ptr]}set(e={}){const t=e.indices,s=e.rsi,r=t?t.length:this.numTriangles;if(null==t&&(!s||s.length!==r))throw new Error("rsi is not consistent with the number of indices");const i=this.memoryManager,n=this.ten,o=t?i.malloc32(r*this.simplexOrder):this.triangles;if(t&&null!=this.triangles&&this.triangles.free(),this.triangles=o,null!=t){const e=o.u32();t.forEach(((t,s)=>{const r=s*this.simplexOrder;for(let s=0;s<this.simplexOrder;s++)e[r+s]=t[s]}))}if(null!=this.rsi&&this.rsi.dispose(),this.rsi=n.zeros([r,this.simplexOrder-1,this.simplexOrder-1]),null==s){let t=null,s=!1;if(null!=e.pos)if(Array.isArray(e.pos))t=n.tensor(e.pos),s=!0;else if(t=e.pos,null==t.ptr)throw new Error("invalid pos");this.wasmInstance.exports.rsi_of_pos(this.numVertices,t.ptr,r,this.triangles.ptr,this.rsi.ptr),s&&t.dispose()}else this.rsi.set(s);null!=this.mu&&this.mu.dispose(),this.mu=n.zeros([r]),this.mu.fill_(Math.fround(500)),null!=this.lambda&&this.lambda.dispose(),this.lambda=n.zeros([r]),this.lambda.fill_(Math.fround(50))}dispose(){null!=this.triangles&&(this.triangles.free(),this.triangles=null),null!=this.rsi&&(this.rsi.dispose(),this.rsi=null),null!=this.mu&&(this.mu.dispose(),this.mu=null),null!=this.lambda&&(this.lambda.dispose(),this.lambda=null)}};var ie=class{constructor(e={}){let t;if(null==e.ten){if(null==e.wasmInstance)throw new Error("wasmInstance required");t=new ee.Engine({wasmInstance:e.wasmInstance}),this.ten=t}else t=e.ten,this.ten=t;this.h=.033,this.g=9.8,this.spaceDim=e.spaceDim??2,this._vertices=new te({ten:this.ten,vertexMass:e.vertexMass,spaceDim:this.spaceDim}),this._muscles=new se({ten:this.ten}),this._triangles=new re({ten:this.ten,simplexOrder:this.spaceDim+1}),this.friction={k:Math.fround(300)}}get vertices(){return this._vertices}set fixedVertexId(e){throw new Error("System.fixedVertexId setter is deprecated, use System.vertices.fixedVertexId instead")}get fixedVertexId(){throw new Error("System.fixedVertexId getter is deprecated, use System.vertices.fixedVertexId instead")}get wasmInstance(){return this.ten.wasmInstance}get memoryManager(){return this.ten.mgr}get vertexMass(){return this._vertices.vertexMass}get triangles(){return this._triangles.triangles}set triangles(e){this._triangles.triangles=e}get rsi(){return this._triangles.rsi}set rsi(e){this._triangles.rsi=e}get k(){return this._muscles.k}set k(e){this._muscles.k=e}get pos0(){return this._vertices.pos}get vel0(){return this._vertices.vel0}get pos(){return this.vertices.pos}get vel(){return this.vertices.vel}get numVertices(){return this._vertices.numVertices}get numTriangles(){return this._triangles.numTriangles}get numMuscles(){return this._muscles.numMuscles}get muscles(){return this._muscles.muscles}set muscles(e){this._muscles.muscles=e}get a(){return this._muscles.a}set a(e){this._muscles.a=e}get l0(){return this._muscles.l0}set l0(e){this._muscles.l0=e}setVertices(e){this._vertices.set(e)}setMuscles(e={}){this._muscles.set({...e,pos:e.pos??this.pos0})}setTriangles(e={}){this._triangles.set({...e,pos:e.pos??this.pos0})}getMusclesArray(){if(null==this.muscles)return[];const e=this.numMuscles,t=this.muscles.u32(),s=[];for(let r=0;r<e;r++){const e=2*r;s.push([t[e],t[e+1]])}return s}getTrianglesArray(){if(null==this.triangles)return[];const e=this.numTriangles,t=this.triangles.u32(),s=[];for(let r=0;r<e;r++){const e=3*r;s.push([t[e],t[e+1],t[e+2]])}return s}set(e){this.setVertices(e.pos),this.setMuscles({indices:e.muscles??[],l0:e.musclesL0,k:e.musclesK}),this.setTriangles({indices:e.triangles??[],rsi:e.trianglesRsi})}step(){const e=this.numVertices,t=this.numMuscles,s=this.vertices._fixedVertexId,r=this.vertexMass;this.wasmInstance.exports.backward_euler_update(this.spaceDim,this.g,this.h,e,0==e?0:this.pos0.ptr,0==e?0:this.vel0.ptr,r,t,0==t?0:this.muscles.ptr,this.k,0==t?0:this.a.ptr,0==t?0:this.l0.ptr,...this._triangles.toStepArgs(),this.friction.k,s,0==e?0:this._vertices.pos1.ptr,0==e?0:this._vertices.posGrad.ptr,0==e?0:this._vertices.posTmp.ptr,0==e?0:this._vertices.vel1.ptr),0!=e&&(this._vertices.pos0.slot.f32().set(this._vertices.pos1.slot.f32()),this._vertices.vel0.slot.f32().set(this._vertices.vel1.slot.f32()))}dispose(){this._vertices.dispose(),this._muscles.dispose(),this._triangles.dispose()}};function ne(e){return[e[0],e[1]]}function oe(e,t){e[0]*=t,e[1]*=t}function le(e,t){const s=ne(e);return oe(s,t),s}function he(e){return e[0]*e[0]+e[1]*e[1]}function ae(e){return Math.sqrt(he(e))}var ue={clone:ne,add:function(e,t){return[e[0]+t[0],e[1]+t[1]]},add_:function(e,t){e[0]+=t[0],e[1]+=t[1]},mulScalar_:oe,mulScalar:le,sub:function(e,t){return[e[0]-t[0],e[1]-t[1]]},quadrance:he,norm:ae,normalize:function(e){return le(e,1/ae(e))},dot:function(e,t){return e[0]*t[0]+e[1]*t[1]}};class ce{constructor(e,t,s,r){this.m00=e,this.m01=t,this.m10=s,this.m11=r}get(e,t){return this[`m${e}${t}`]}set(e,t,s,r){this.m00=e,this.m01=t,this.m10=s,this.m11=r}toArray(){return[[this.m00,this.m01],[this.m10,this.m11]]}negate(){return new ce(-this.m00,-this.m01,-this.m10,-this.m11)}apply(e){return[this.m00*e[0]+this.m01*e[1],this.m10*e[0]+this.m11*e[1]]}det(){return this.m00*this.m11-this.m10*this.m01}inv(){const e=this.det();return new ce(this.m11/e,-this.m01/e,-this.m10/e,this.m00/e)}mm(e){const t=this.m00,s=this.m01,r=this.m10,i=this.m11,n=e.m00,o=e.m01,l=e.m10,h=e.m11;return new ce(t*n+s*l,t*o+s*h,r*n+i*l,r*o+i*h)}t(){return new ce(this.m00,this.m10,this.m01,this.m11)}static fromArray(e){return new ce(e[0][0],e[0][1],e[1][0],e[1][1])}}var de=ce;const pe=de,me=ue;class fe{constructor(){this.translation=[0,0],this.linear=new pe(1,0,0,1)}inferScale(){return this.linear.m00}apply(e){return me.add(this.linear.apply(e),this.translation)}inv(){const e=new fe;return e.linear=this.linear.inv(),e.translation=e.linear.negate().apply(this.translation),e}toColumnMajorArray(){return[this.linear.get(0,0),this.linear.get(1,0),this.linear.get(0,1),this.linear.get(1,1),this.translation[0],this.translation[1]]}}var ge=fe;var we={Vec2:ue,Matrix2x2:de,Transform2d:ge,AABB:class{constructor(e={}){if(null==e.x0)throw new Error("x0 required");if(null==e.y0)throw new Error("y0 required");this._x0=e.x0,this._y0=e.y0;let t=null;if(null!=e.width)t=this._x0+e.width;else{if(null==e.x1)throw new Error("x1 required");t=e.x1}this._x1=t;let s=null;if(null!=e.height)s=this._y0+e.height;else{if(null==e.y1)throw new Error("y1 required");s=e.y1}this._y1=s}get x0(){return this._x0}get x1(){return this._x1}get y0(){return this._y0}get y1(){return this._y1}get width(){return this._x1-this._x0}get height(){return this._y1-this._y0}get center(){return[.5*(this.x0+this.x1),.5*(this.y0+this.y1)]}}};const ye=we;var xe=class{constructor(){this.transform=new ye.Transform2d}domToWorldSpace(e){if(!Array.isArray(e))throw new Error("array expected, found "+typeof e);if(2!=e.length)throw new Error(`array with 2 elements expected, found ${e.length}`);return this.transform.inv().apply(e)}inferScale(){return this.transform.inferScale()}center(e={}){let t=e.viewportWidth,s=e.viewportHeight;const r=e.renderer;if((null==t||null==s)&&null==r)throw new Error("renderer required");if(null!=r&&(t=r.width,s=r.height),null==t)throw new Error("viewportWidth required");if(null==s)throw new Error("viewportHeight required");let i,n=e.zoom??1;if(null!=e.worldWidth&&(n=t/e.worldWidth),this.transform.linear=new ye.Matrix2x2(n,0,0,-n),null!=e.worldCenter){const r=e.worldCenter;i=[.5*t-r[0]*n,.5*s+r[1]*n]}else i=[.5*t,.5*s];this.transform.translation=i}};var ve=class{constructor(){}renderPoint(e={}){const t=e.ctx,s=e.p;t.beginPath(),t.arc(s[0],s[1],3,0,2*Math.PI),t.fill()}};var Ee=class{constructor(){}renderLine(e={}){const t=e.ctx,s=e.a,r=e.b;t.beginPath(),t.strokeStyle="red",t.lineWidth=5,t.moveTo(s[0],s[1]),t.lineTo(r[0],r[1]),t.closePath(),t.stroke()}};var Se={PointShader:ve,LineShader:Ee,TriangleShader:class{constructor(){}renderTriangle(e={}){const t=e.ctx,s=e.a,r=e.b,i=e.c;t.save(),t.beginPath(),t.strokeStyle="black",t.moveTo(s[0],s[1]),t.lineTo(r[0],r[1]),t.lineTo(i[0],i[1]),t.closePath(),t.stroke(),t.restore()}}};const be=we,_e=Se;var Ie=class{constructor(e={}){this.scene=e.scene,this.id=e.id,this.x=[],this.triangles=[],this.lines=[],this.pointShader=new _e.PointShader({}),this.lineShader=new _e.LineShader({}),this.triangleShader=new _e.TriangleShader({}),this.customAttributes={}}get pos(){return this.x}set pos(e){this.x=e}numVertices(){return this.pos.length}numTriangles(){return this.triangles.length}numLines(){return this.lines.length}setCustomAttribute(e,t){this.customAttributes[e]=t}getCustomAttribute(e){return this.customAttributes[e]}computeAABB(){let e=null,t=null,s=null,r=null;return this.pos.forEach((i=>{const n=i[0],o=i[1];(null==e||n<e)&&(e=n),(null==t||n>t)&&(t=n),(null==s||o<s)&&(s=o),(null==r||o>r)&&(r=o)})),new be.AABB({x0:e,y0:s,x1:t,y1:r})}computeCenter(){const e=this.pos.length;if(0==e)throw new Error("no vertices to compute center");let t=[0,0];for(let s=0;s<e;s++){const e=this.pos[s];be.Vec2.add_(t,e)}return be.Vec2.mulScalar_(t,1/e),t}};const Ve=Ie;var Ce=class{constructor(e={}){const t=e.headless??!1;if(this.headless=t,!t){const e=document.createElement("canvas");this.domElement=e,this.ctx=e.getContext("2d")}this.setSize({width:200,height:200})}setSize(e){const t=e.width;if(null==t)throw new Error("width required to setSize");const s=e.height;if(null==s)throw new Error("height required to setSize");let r=e.viewportWidth;null==r&&(r=t);let i=e.viewportHeight;if(null==i&&(i=s),this.width=t,this.height=s,this.viewportWidth=r,this.viewportHeight=i,!this.headless){const e=this.domElement;e.width=r,e.height=i,e.style.width=`${t}px`,e.style.height=`${s}px`}}renderPoint(e,t,s,r,i){const n=this.ctx;let o;if(!(t instanceof Ve))throw new Error("invalid mesh");o=t.pos[r];const l=s.transform.apply(o);n.save(),t.pointShader.renderPoint({ctx:n,renderer:e,mesh:t,camera:s,id:r,p:l,custom:i}),n.restore()}renderLine(e,t,s,r,i){const n=this.ctx,o=t.lines[r],l=s.transform.apply(t.pos[o[0]]),h=s.transform.apply(t.pos[o[1]]);n.save(),t.lineShader.renderLine({ctx:n,renderer:e,mesh:t,camera:s,id:r,a:l,b:h,custom:i}),n.restore()}renderTriangle(e,t,s,r,i){const n=this.ctx,o=t.triangles[r],l=o[0],h=o[1],a=o[2];let u,c,d;if(t.pos instanceof Float32Array){const e=2;u=[t.pos[l*e],t.pos[l*e+1]],c=[t.pos[h*e],t.pos[h*e+1]],d=[t.pos[a*e],t.pos[a*e+1]]}else u=t.pos[l],c=t.pos[h],d=t.pos[a];const p=s.transform.apply(u),m=s.transform.apply(c),f=s.transform.apply(d);n.save(),t.triangleShader.renderTriangle({ctx:n,renderer:e,mesh:t,camera:s,id:r,a:p,b:m,c:f,custom:i}),n.restore()}renderMesh(e,t,s,r={}){const i=t.sortedElements;if(null==i){for(let i=0;i<t.triangles.length;i++)this.renderTriangle(e,t,s,i,r);for(let i=0;i<t.lines.length;i++)this.renderLine(e,t,s,i,r);for(let i=0;i<t.pos.length;i++)this.renderPoint(e,t,s,i,r)}else i.forEach((i=>{if(null==i.order)throw new Error(`invalid element, order not defined ${i}`);if(1==i.order)this.renderPoint(e,t,s,i.id,r);else if(2==i.order)this.renderLine(e,t,s,i.id,r);else{if(3!=i.order)throw new Error(`invalid element ${i}`);this.renderTriangle(e,t,s,i.id,r)}}))}render(e,t,s={}){this.ctx.clearRect(0,0,this.viewportWidth,this.viewportHeight),e.meshes.forEach((e=>{this.renderMesh(this,e,t,s)}))}};const Ae=Ie;var Me={Camera:xe,Mesh:Ie,Renderer:Ce,Scene:class{constructor(){this.meshes=new Map}clean(){this.meshes=new Map}numMeshes(){return this.meshes.size}addMesh(){const e=this.meshes.size,t=new Ae({scene:this,id:e});return this.meshes.set(e,t),t}}};var Te={computeDomCursor:function(e,t){let s,r;if(null==e.touches)s=e.clientX,r=e.clientY;else{if(0==e.touches.length)return null;const t=e.touches[0];s=t.clientX,r=t.clientY}let i=new DOMMatrix,n=t;for(;null!=n;){const e=window.getComputedStyle(n);i=new DOMMatrix(e.transform).multiply(i),n=n.parentElement}const o=i.inverse(),l=new DOMPointReadOnly(s,r).matrixTransform(o),h=t.getBoundingClientRect(),a=new DOMPointReadOnly(h.left,h.top).matrixTransform(o);return[l.x-a.x,l.y-a.y]}};const ke=Te;var ze={cursorUtils:Te,DragBehavior:class{constructor(e={}){this._dragging=!1,this.onDomCursorDown=e.onDomCursorDown,this.onDragProgress=e.onDragProgress,this.onDomCursorUp=e.onDomCursorUp,this.domElement=null}beginDrag(){this._dragging=!0}endDrag(){this._dragging=!1}dragging(){return this._dragging}domCursorDown(e,t){null!=this.onDomCursorDown&&this.onDomCursorDown(e,t)}domCursorMove(e,t){this.dragging()&&null!=this.onDragProgress&&this.onDragProgress(e,t)}domCursorUp(e,t){this.endDrag(),null!=this.onDomCursorUp&&this.onDomCursorUp(e,t)}linkToDom(e,t=null){if(null!=this.domElement)throw new Error("already linked to DOM");this.domElement=e;const s=t=>{t.preventDefault();const s=ke.computeDomCursor(t,e);this.domCursorDown(s,t)};e.addEventListener("mousedown",s,{passive:!1}),e.addEventListener("touchstart",s,{passive:!1});const r=t=>{const s=ke.computeDomCursor(t,e);this.domCursorMove(s,t)};null==t&&(t=e),t.addEventListener("mousemove",r,{passive:!1}),t.addEventListener("touchmove",r,{passive:!1});const i=t=>{const s=ke.computeDomCursor(t,e);this.domCursorUp(s,t)};window.addEventListener("mouseup",i),window.addEventListener("touchend",i),window.addEventListener("touchcancel",i)}}};class $e{constructor(e={}){if(null==e.scene)throw new Error("scene required");const t=null==e.color?"rgba(0, 0, 0, 0.30)":e.color,s=this.mesh=e.scene.addMesh();this.set(e),s.setCustomAttribute("translation",[0,0]),s.pointShader.renderPoint=()=>{},s.lineShader.renderLine=$e.makeGridLineShader({color:t})}get numVertices(){return this.mesh.x.length}get numLines(){return this.mesh.lines.length}set(e={}){const t=null==e.cellSize?1:e.cellSize,s=null==e.innerCells?3:e.innerCells,r=null==e.rows?3:e.rows,i=null==e.cols?4:e.cols,n=null==e.x0?-2:e.x0,o=null==e.y0?0:e.y0,l=null==e.primaryLineWidth?.03:e.primaryLineWidth,h=null==e.secondaryLineWidth?.008:e.secondaryLineWidth,a=this.mesh,{x:u,lineIndices:c,lineWidths:d}=function(e={}){const t=null==e.cellSize?1:e.cellSize,s=null==e.innerCells?3:e.innerCells,r=null==e.rows?3:e.rows,i=null==e.cols?4:e.cols,n=null==e.x0?-2:e.x0,o=null==e.y0?0:e.y0,l=null==e.primaryLineWidth?.022:e.primaryLineWidth,h=null==e.secondaryLineWidth?.008:e.secondaryLineWidth,a=[],u=[],c=[],d=o+r*t,p=n+i*t;function m(e,t){for(let r=0;r<e+1;r++){const i=r==e?1:s;for(let e=0;e<i;e++){const s=2*u.length;t(r,e,i,a),u.push([s,s+1]),0==e?c.push(l):c.push(h)}}}return m(r,((e,s,r,i)=>{const l=s/r,h=(o+e*t)*(1-l)+(o+(e+1)*t)*l;i.push([n,h]),i.push([p,h])})),m(i,((e,s,r,i)=>{const l=s/r,h=(n+e*t)*(1-l)+(n+(e+1)*t)*l;i.push([h,o]),i.push([h,d])})),{x:a,lineIndices:u,lineWidths:c}}({cellSize:t,innerCells:s,rows:r,cols:i,x0:n,y0:o,primaryLineWidth:l,secondaryLineWidth:h});a.pos=u,a.lines=c,a.setCustomAttribute("lineWidths",d)}static makeGridLineShader(e={}){const t=null==e.color?"black":e.color;return e=>{const s=e.ctx,r=e.a,i=e.b,n=e.camera,o=e.mesh,l=n.inferScale();s.beginPath(),s.strokeStyle=t;const h=o.getCustomAttribute("lineWidths");if(null==h)throw new Error("custom attribute lineWidths missing");const a=h[e.id],u=o.getCustomAttribute("translation"),c=[l*u[0],l*u[1]];s.lineWidth=a*l,s.moveTo(r[0]+c[0],r[1]+c[1]),s.lineTo(i[0]+c[0],i[1]+c[1]),s.closePath(),s.stroke()}}}var De=$e;var Le={Grid:De,Background:class{constructor(e={}){if(null==e.scene)throw new Error("scene required");const t=this.mesh=e.scene.addMesh();t.pos=[[0,0]];const s=null==e.color1?"#fcfcfc":e.color1,r=null==e.color2?"#d7d8d8":e.color2;t.pointShader.renderPoint=(e={})=>{const t=e.renderer.width,i=e.renderer.height,n=e.ctx,o=n.createRadialGradient(.5*t,.5*i,.05*t,.5*t,.5*i,.5*t);o.addColorStop(0,s),o.addColorStop(1,r),n.fillStyle=o,n.fillRect(0,0,t,i)}}}};var We=class{constructor(e,t){if(null==e)throw new Error("id required to create simplex");this.order=t.length,this.id=e,this.vertexIds=t}};const Pe=We;function Fe(e){return e.sort(),e.join("_")}var qe=class{constructor(e={}){if(null==e.order)throw new Error("order required");this.order=e.order,this.simplicesByHash=new Map}forEach(e){this.simplicesByHash.forEach(e)}size(){return this.simplicesByHash.size}has(e){return this.simplicesByHash.has(Fe(e.vertexIds))}add(e,t){let s=null;if(Array.isArray(e)){if(null==t)throw new Error("id required");s=e,e=new Pe(t,s)}else{if(s=e.vertexIds,null==s)throw new Error(`vertexIds required ${e}`);t=e.id}if(s.length!=this.order)throw new Error(`expected ${this.order} vertices, found ${s.length}`);const r=Fe(s);return this.simplicesByHash.set(r,e),e}};const Be=qe;const Oe=qe,Ne=class{constructor(e){this.id=e,this.edges=new Be({order:2}),this.triangles=new Be({order:3})}addTriangle(e,t){this.triangles.add(e,t)}addEdge(e,t){this.edges.add(e,t)}};var Re=class{constructor(e={}){this.vertices=new Map,this.edges=new Oe({order:2}),this.triangles=new Oe({order:3});(e.edges??[]).forEach(((e,t)=>{this.addEdge(t,e)}));(e.triangles??[]).forEach(((e,t)=>{this.addTriangle(t,e)}))}numVertices(){return this.vertices.size}numEdges(){return this.edges.size()}numTriangles(){return this.triangles.size()}getVertexById(e,t=!1){let s=this.vertices.get(e);return null==s&&t&&(s=new Ne(e),this.vertices.set(e,s)),s}addEdge(e,t){const s=this.edges.add(t,e);return t.forEach((e=>{this.getVertexById(e,!0).addEdge(s)})),s}addTriangle(e,t){const s=this.triangles.add(t,e);return t.forEach((e=>{this.getVertexById(e,!0).addTriangle(s)})),s}};const Ge=Re,Xe=qe;var Ue={math:we,ui:ze,shaders:Se,background:Le,sorted:{makeSortedElements:function(e={}){if(null==e.sortedVertexIds)throw new Error("sortedVertexIds required");if(null==e.triangles)throw new Error("triangles required");if(null==e.edges)throw new Error("edges required");const t=e.sortedVertexIds,s=new Map;t.forEach(((e,t)=>{s.set(e,t)}));const r=new Ge({triangles:e.triangles}),i=new Ge({edges:e.edges}),n=[],o=new Xe({order:3}),l=new Xe({order:2});return t.forEach((e=>{const t=r.getVertexById(e,!0).triangles,h=i.getVertexById(e,!0).edges,a=[];t.forEach((e=>{a.push(e)})),h.forEach((e=>{a.push(e)})),a.sort(((e,t)=>{const r=e.vertexIds.map((e=>s.get(e))),i=t.vertexIds.map((e=>s.get(e))),n=Math.max(...r),o=Math.max(...i);return n<o?1:n==o?0:-1})),a.forEach((e=>{if(2==e.order){const t=e;l.has(t)||(n.push(t),l.add(t))}else{const t=e;o.has(t)||(n.push(t),o.add(t))}})),n.push({order:1,id:e})})),n},MeshTopology:Re,Simplex:We,Simplices:qe},core:Me,Renderer:Me.Renderer,Camera:Me.Camera,Scene:Me.Scene};var He=class{constructor(e={}){this.targetCenterX=null,this.currentCenterX=null,this.active=!0,this.visibleWorldWidth=e.visibleWorldWidth??3.8,this.targetCenterY=e.targetCenterY??1,this.offsetX=e.offsetX??0,this.fullGrid=!1,this.centeringSpeedFactor=.5}step(e={}){if(!this.active)return;const t=e.renderer,s=e.camera,r=e.mesh,i=e.floor,n=e.grid;let o=[0,0];r.pos.length>0&&(o=r.computeCenter());const l=o[0]+this.offsetX;isNaN(l)||(this.targetCenterX=l),null==this.currentCenterX?this.currentCenterX=this.targetCenterX:this.currentCenterX+=(this.targetCenterX-this.currentCenterX)*this.centeringSpeedFactor;const h=[this.currentCenterX,this.targetCenterY];s.center({worldCenter:h,worldWidth:this.visibleWorldWidth,viewportWidth:t.width,viewportHeight:t.height});const a=s.domToWorldSpace([t.width,0]),u=s.domToWorldSpace([0,t.height]),[c,d]=u,p=Math.floor(c)-1;let m=Math.floor(d);this.fullGrid||m<0&&(m=0);const[f,g]=a,w=f,y=w-p,x=g-m,v=Math.ceil(x)+1,E=Math.ceil(y)+1;n.set({x0:p,y0:m,rows:v,cols:E,innerCells:n.innerCells,primaryLineWidth:n.primaryLineWidth,secondaryLineWidth:n.secondaryLineWidth}),i.mesh.pos=[[p,0],[w,0]]}};class je{constructor(e={}){if(null==e.scene)throw new Error("scene required");const t=this.scene=e.scene,s=this.mesh=t.addMesh();s.pos=[[-10,0],[10,0]],s.lines=[[0,1]],s.lineShader.renderLine=je.makeFloorLineShaderFunction({width:e.width,color:e.color}),s.pointShader.renderPoint=()=>{},s.setCustomAttribute("translation",[0,0])}static makeFloorLineShaderFunction(e={}){const t=e.width??.055,s=e.color??"black";return e=>{const r=e.ctx,i=e.a,n=e.b,o=e.camera,l=e.mesh,h=o.inferScale(),a=l.getCustomAttribute("translation"),u=[h*a[0],h*a[1]];r.strokeStyle=s,r.lineWidth=h*t,r.beginPath(),r.moveTo(i[0]+u[0],i[1]+u[1]),r.lineTo(n[0]+u[0],n[1]+u[1]),r.stroke()}}}var Ye=je;const Je=Ue;var Ke=class{constructor(e={}){this.system=e.system,this.renderVertexIds=e.renderVertexIds??!1,this.radius=e.radius??.028,this.borderColor=e.borderColor??"black",this.fillColor=e.fillColor??"white",this.borderWidth=e.borderWidth??.023}renderVertex(e={}){const t=this.radius,s=this.borderColor,r=this.fillColor,i=this.borderWidth,n=e.ctx,o=e.p,l=e.camera.inferScale();if(function(e,t,s,r,i,n,o){const l=(r+.5*i)*t;e.fillStyle=o,e.beginPath(),e.arc(s[0],s[1],l,0,2*Math.PI),e.fill(),e.lineWidth=i*t,e.strokeStyle=n,e.stroke()}(n,l,o,t,i,s,r),this.renderVertexIds){n.beginPath(),n.fillStyle="rgba(255, 255, 255, 0.8)",n.arc(o[0],o[1],.1*l,0,2*Math.PI),n.fill();const t=Math.floor(.15*l);n.font=`${t}px monospace`,n.fillStyle="black",n.textAlign="center",n.textBaseline="middle",n.fillText(e.id,o[0],o[1])}}getVertexPos(e){const t=this.system.pos.slot.f32(),s=e*this.system.spaceDim;return[t[s],t[s+1]]}get numVertices(){return this.system.numVertices}hitTest(e,t=.31){const s=this.numVertices;if(0==s)return null;let r=null,i=1/0;const n=t*t;for(let t=0;t<s;t++){const s=this.getVertexPos(t),o=Je.math.Vec2.sub(s,e),l=Je.math.Vec2.quadrance(o);l<n&&l<i&&(r=t,i=l)}return r}setVertexPos(e,t){if(null==e)throw new Error("vertex id required");const s=this.system.pos.slot.f32(),r=2*e;s[r]=t[0],s[r+1]=t[1]}setVertexVel(e,t){const s=this.system.vel.slot.f32(),r=2*e;s[r]=t[0],s[r+1]=t[1]}};const Qe=Ue,Ze=He,et=Ye,tt=Ke,st=class{constructor(e={}){this.system=e.system}makeLineShaderFunction(e={}){const t=e.activeMuscleColor??[255,0,0],s=e.inactiveMuscleColor??[0,0,255],r=e.borderColor??"black";return(e={})=>{const i=e.ctx,n=e.a,o=e.b,l=e.camera.inferScale(),h=e.mesh.getCustomAttribute("lineIdToMuscleId")[e.id];if(null==h){!function(e,t,s,r,i,n){e.beginPath(),e.lineJoin="round",e.lineCap="round",e.strokeStyle=n,e.lineWidth=i*t,e.moveTo(s[0],s[1]),e.lineTo(r[0],r[1]),e.closePath(),e.stroke()}(i,l,n,o,.029,r)}else{const a=t,u=s,c=.065,d=.017,p="muscleIntensity",m=e.mesh.getCustomAttribute(p);if(null==m)throw new Error(`muscle intensity attribute (${p}) not found, call setCustomAttribute("${p}", value) before rendering.`);if(!Array.isArray(m))throw new Error("muscle intensity attribute must be an array with values for each fiber, found "+typeof m);!function(e,t,s,r,i,n,o,l,h,a){e.beginPath(),e.lineCap="butt",e.strokeStyle=l,e.lineWidth=(n+2*o)*t,e.moveTo(s[0],s[1]),e.lineTo(r[0],r[1]),e.stroke(),e.beginPath();const u=(1-i)*h[0]+i*a[0],c=(1-i)*h[1]+i*a[1],d=(1-i)*h[2]+i*a[2];e.strokeStyle=`rgb(${u}, ${c}, ${d})`,e.lineWidth=n*t,e.moveTo(s[0],s[1]),e.lineTo(r[0],r[1]),e.stroke()}(i,l,n,o,m[h],c,d,r,a,u)}}}};function rt(e){return e.sort(),e.join("_")}function it(e){if(7!=e.length)throw new Error(`invalid hex string ${e}`);if("#"!=e[0])throw new Error(`invalid hex string ${e}, expected #, found ${e[0]}`);e=e.substring(1);return[parseInt(e.substring(0,2),16),parseInt(e.substring(2,4),16),parseInt(e.substring(4,6),16)]}var nt=class{constructor(e={}){if(null==e.system)throw new Error("system required");this.system=e.system;const t=e.sortedVertexIds;this.sortedVertexIds=t,null!=e.vertexDepths&&this.setSortedVertexIdsFromVertexDepths(e.vertexDepths);const s=e.headless??!1,r=e.borderColor??"black",i=r,n=e.fillColor??"white",o=e.gridColor??"#acadad";this.vertices=new tt({system:this.system,renderVertexIds:e.renderVertexIds??!1,borderColor:r,fillColor:n}),this.lines=new st({system:this.system});const l=new Qe.Renderer({headless:s});this.renderer=l,this.domElement=l.domElement,this.setSize({width:e.width??400,height:e.height??400});const h=new Qe.Scene;this.scene=h;const a=new Qe.Camera;this.camera=a;let u,c,d=e.activeMuscleColor??[255,0,0],p=e.inactiveMuscleColor??[250,190,190];"string"==typeof d&&(d=it(d)),"string"==typeof p&&(p=it(p)),null!=e.backgroundColor?(u=e.backgroundColor,c=e.backgroundColor):(u=e.backgroundCenterColor??"#fcfcfc",c=e.backgroundOuterColor??"#d7d8d8"),new Qe.background.Background({scene:h,color1:u,color2:c});const m=this.grid=new Qe.background.Grid({scene:h,x0:-3,y0:0,rows:4,cols:10,innerCells:2,primaryLineWidth:.022,secondaryLineWidth:.005,color:o});m.innerCells=2,m.primaryLineWidth=.022,m.secondaryLineWidth=.005,this.floor=new et({scene:h,color:i});const f=h.addMesh();this.mesh=f,f.pointShader.renderPoint=e=>{this.vertices.renderVertex(e)},f.triangleShader.renderTriangle=(e={})=>{const t=e.ctx,s=e.a,r=e.b,i=e.c;t.beginPath(),t.fillStyle=n,t.moveTo(...s),t.lineTo(...r),t.lineTo(...i),t.closePath(),t.fill()},f.lineShader.renderLine=this.lines.makeLineShaderFunction({activeMuscleColor:d,inactiveMuscleColor:p,borderColor:r});if(e.draggable??!0){const t=this.dragBehavior=new Qe.ui.DragBehavior({onDomCursorDown:(e,s)=>{if("button"in s&&0!=s.button)return;const r=this.system,i=a.domToWorldSpace(e),n=this.hitTestVertex(i);null!=n&&(this.fixVertex(n),t.beginDrag(),this.setVertexPos(r.vertices.fixedVertexId,[i[0],Math.max(0,i[1])]))},onDragProgress:e=>{const t=this.system,s=a.domToWorldSpace(e);this.setVertexPos(t.vertices.fixedVertexId,[s[0],Math.max(0,s[1])])},onDomCursorUp:()=>{this.freeVertex()}});if(!s){const s=e.domElementForMoveEvents??null;t.linkToDom(l.domElement,s)}}this.tracker=new Ze}setSortedVertexIdsFromVertexDepths(e){if(e.length!=this.system.numVertices)throw new Error(`invalid size for depths, found ${e.length}, expected ${this.system.numVertices}`);const t=e.map(((e,t)=>({depth:e,index:t})));t.sort(((e,t)=>t.depth-e.depth));const s=t.map((e=>e.index));this.sortedVertexIds=s}setSize(e={}){this.renderer.setSize({width:e.width,height:e.height})}render(){(null==this.needsMeshUpdate||this.needsMeshUpdate)&&(this._updateMesh({triangles:this.system.getTrianglesArray(),muscles:this.system.getMusclesArray()}),this.needsMeshUpdate=!1);const e=this.renderer,t=this.scene,s=this.camera,r=this.mesh;this._updateFromSystem(),null!=this.dragBehavior&&this.dragBehavior.dragging()||this.tracker.step({mesh:r,camera:s,floor:this.floor,grid:this.grid,renderer:this.renderer}),e.render(t,s)}_updateMesh(e){const t=this.mesh,s=this.system.numVertices;if(!Number.isInteger(s)||s<0)throw new Error(`invalid number of vertices ${s}`);null!=e.pos&&(t.pos=e.pos),t.triangles=e.triangles,t.lines=function(e){const t=new Map;function s(e,s){const r=rt([e,s]);t.set(r,[e,s])}return e.forEach((e=>{s(e[0],e[1]),s(e[1],e[2]),s(e[0],e[2])})),Array.from(t.values())}(e.triangles),Array.prototype.push.apply(t.lines,e.muscles);const r=new Map;e.muscles.forEach(((e,t)=>{r.set(rt(e),t)}));const i=[];t.setCustomAttribute("lineIdToMuscleId",i),t.lines.forEach((e=>{const t=rt(e),s=r.get(t);i.push(s)}));let n=this.sortedVertexIds;if(null==n){n=[];for(let e=0;e<s;e++)n.push(e)}if(n.length!=s)throw new Error(`invalid size for sortedVertexIds, found ${n.length}, expected ${s}`);t.sortedElements=Qe.sorted.makeSortedElements({sortedVertexIds:n,triangles:t.triangles,edges:t.lines});const o=[],l=this.system.numMuscles;for(let e=0;e<l;e++)o.push(1);t.setCustomAttribute("muscleIntensity",o)}_updateFromSystem(){this._updateVertexPositionsFromSystem(),this._updateMuscleIntensityFromSystem()}_updateVertexPositionsFromSystem(){const e=this.mesh,t=this.system;if(0==t.numVertices)e.pos=[];else{const s=t.pos.toArray();e.pos=s}}_updateMuscleIntensityFromSystem(){const e=this.mesh,t=this.system,s=t.numMuscles;if(!Number.isInteger(s)||s<0)throw new Error(`invalid number of muscles ${s}`);let r=[];if(s>0)if(t.a){const e=t.a.slot.f32();for(let t=0;t<s;t++)r.push(e[t])}else r=new Array(s).fill(1);e.setCustomAttribute("muscleIntensity",r)}hitTestVertex(e,t=.31){return this.vertices.hitTest(e,t)}setVertexPos(e,t){this.vertices.setVertexPos(e,t)}setVertexVel(e,t){this.vertices.setVertexVel(e,t)}fixVertex(e){const t=this.system;this.setVertexVel(e,[0,0]),null==e&&(e=-1),t.vertices.fixVertex(e)}freeVertex(){this.system.vertices.freeVertex()}},ot={SystemViewport:nt,VertexRenderer:Ke,Tracker:He};var lt=e({System:ie,Vertices:Q,mmgrten:K,SystemViewport:ot.SystemViewport,mm2d:Ue,render:ot});export{lt as default};
