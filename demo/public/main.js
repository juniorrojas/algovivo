class t{constructor(t,e){this.list=t,this.data=e,this.next=null,this.prev=null}append(e){const s=new t(this.list,e);return this.list.last==this&&(this.list.last=s),s.next=this.next,s.prev=this,null!=this.next&&(this.next.prev=s),this.next=s,this.list.size++,s}prepend(e){const s=new t(this.list,e);return this.list.first==this&&(this.list.first=s),s.next=this,s.prev=this.prev,null!=this.prev&&(this.prev.next=s),this.prev=s,this.list.size++,s}remove(){null!=this.prev&&(this.prev.next=this.next),null!=this.next&&(this.next.prev=this.prev),this.list.first==this&&(this.list.first=this.next),this.list.last==this&&(this.list.last=this.prev),this.list.size--,this.next=null,this.prev=null}}var e=t;const s=e;class r{constructor(t){this.list=t,this.nextNode=this.list.first}next(){if(null==this.nextNode)return{done:!0};{const t={done:!1,value:this.nextNode.data};return this.nextNode=this.nextNode.next,t}}}class n{constructor(){this.first=null,this.last=null,this.size=0}isEmpty(){if(null==this.first&&null!=this.last||null!=this.first&&null==this.last)throw Error("inconsistent first last state");return null==this.first}append(t){return this.isEmpty()?this.setSingleton(t):this.last.append(t)}prepend(t){return this.isEmpty()?this.setSingleton(t):this.first.prepend(t)}setSingleton(t){const e=new s(this,t);return this.first=e,this.last=e,this.size=1,e}iter(){return new r(this)}*[Symbol.iterator](){const t=this.iter();let e=t.next();for(;!e.done;)yield e.value,e=t.next()}}var i,o,h,l,a,c;function d(){if(o)return i;o=1;const t=u();return i=class extends t{constructor(t={}){super(t)}isFree(){return!1}free(){let t=this.appendFree(this.ptr,this.size);this.remove();const e=t.prev(),s=t.next();return null!=e&&e.isFree()&&(t=e.merge(t)),null!=s&&s.isFree()&&(t=t.merge(s)),t}}}function u(){return l||(l=1,h=class{constructor(t={}){this.manager=t.manager,this.ptr=t.ptr,this.size=t.size,this.node=t.node}numBytes(){return this.size}prev(){const t=this.node.prev;return null!=t?t.data:null}next(){const t=this.node.next;return null!=t?t.data:null}appendReserved(t,e){const s=d(),r=this.node.append(null),n=new s({manager:this.manager,ptr:t,size:e,node:r});return r.data=n,this.manager._addReservedSlot(n),n}appendFree(t,e){const s=p(),r=this.node.append(null),n=new s({manager:this.manager,ptr:t,size:e,node:r});return r.data=n,this.manager._addFreeSlot(n),n}remove(){this.node.remove(),this.node.data=null,this.node=null,this.isFree()?this.manager._removeFreeSlot(this):this.manager._removeReservedSlot(this)}toTypedArray(t){const e=this.size,s=t.BYTES_PER_ELEMENT;if(e%s!=0)throw new Error(`size in bytes must be a multiple of ${s}, found ${e}`);const r=this.ptr;return new t(this.manager.array,r,e/s)}f32(){return this.toTypedArray(Float32Array)}u32(){return this.toTypedArray(Uint32Array)}}),h}function p(){if(c)return a;c=1;const t=u();return a=class extends t{constructor(t={}){super(t)}isFree(){return!0}reserve(t){const e=this.numBytes();if(t>e)throw new Error(`cannot reserve ${t} bytes, only ${e} bytes are available`);const s=this.appendReserved(this.ptr,t);return s.appendFree(this.ptr+t,e-t),this.remove(),s}merge(t){if(!this.isFree()||!t.isFree())throw new Error("only free slots can be merged");if(this.next()!=t)throw new Error("only adjacent slots can be merged");const e=t.appendFree(this.ptr,this.size+t.size);return this.remove(),t.remove(),e}}}const m={List:n,Node:e},g=p();var f={MemoryManager:class{constructor(t,e){this.array=t,null==e&&(e=0),this.ptrToSlot=new Map,this.slots=new m.List,this.freeSlots=new m.List,this.reservedSlots=new m.List;const s=new g({manager:this,ptr:e,size:t.byteLength-e}),r=this.slots.append();r.data=s,s.node=r;const n=this.freeSlots.append();n.data=s,s.freeNode=n}numReservedSlots(){return this.reservedSlots.size}numFreeSlots(){return this.freeSlots.size}numFreeBytes(){let t=0;const e=this.freeSlots.iter();let s=e.next();for(;!s.done;)t+=s.value.size,s=e.next();return t}numReservedBytes(){let t=0;const e=this.reservedSlots.iter();let s=e.next();for(;!s.done;)t+=s.value.size,s=e.next();return t}mallocBytes(t){return this._malloc(t)}malloc32(t){return this.mallocBytes(4*t)}_addReservedSlot(t){const e=this.reservedSlots.append(t);t.reservedNode=e}_removeReservedSlot(t){if(null==t.reservedNode)throw new Error("reservedNode cannot be null");t.reservedNode.remove()}_addFreeSlot(t){const e=this.freeSlots.append(t);t.freeNode=e}_removeFreeSlot(t){if(null==t.freeNode)throw new Error("freeNode cannot be null");t.freeNode.remove()}_malloc(t){if(!Number.isInteger(t))throw new Error(`expected integer, found ${t}`);let e=null;const s=this.freeSlots.iter();let r=s.next();for(;!r.done;){const n=r.value;if(n.size>=t){e=n;break}r=s.next()}if(null==e)throw new Error("no valid free slot available");return e.reserve(t)}malloc(t){const e=this._malloc(t);return this.ptrToSlot.set(e.ptr,e),e.ptr}free(t){this.ptrToSlot.get(t).free()}},FreeSlot:p(),ReservedSlot:d()};class w{constructor(t={}){const e=t.engine;if(null==e)throw new Error("engine required to create IntTuple");this.engine=e;const s=t.slot;if(null==s)throw new Error("slot required to create IntTuple");this.slot=s,this.ptr=s.ptr,this.length=t.length}forEach(t){for(let e=0;e<this.length;e++)t(this.get(e),e)}equal(t){if(t instanceof w){for(let e=0;e<this.length;e++)if(this.get(e)!=t.get(e))return!1;return!0}if(Array.isArray(t)){for(let e=0;e<this.length;e++)if(this.get(e)!=t[e])return!1;return!0}return!1}toString(){return this.slot.u32().toString()}toArray(){const t=[];return this.forEach((e=>{t.push(e)})),t}typedArray(){return this.slot.u32()}set(t,e){this.typedArray()[t]=e}get(t){return this.typedArray()[t]}dispose(){this.slot.free()}}var y=w;function x(t,e,s,r){if(e==s.length-1)for(let n=0;n<s[e];n++)t.push(r);else for(let n=0;n<s[e];n++){const n=[];t.push(n),x(n,e+1,s,r)}}var v={inferShape:function(t){const e=[];let s=t;for(;Array.isArray(s);)e.push(s.length),s=s[0];return e},makeNdArray:function(t,e){let s=t;t instanceof y&&(s=t.toArray());const r=[];return x(r,0,s,e),r},numelOfShape:function(t){let e=1;return t.forEach((t=>{e*=t})),e},getArrElem:function t(e,s){if(!Array.isArray(s))throw new Error(`expected array, found ${typeof s}: ${s}`);return 0==s.length?e:t(e[s[0]],s.slice(1))},setArrElem:function t(e,s,r){if(!Array.isArray(s))throw new Error(`expected array, found ${typeof s}: ${s}`);if(1!=s.length)return t(e[s[0]],s.slice(1),r);e[s]=r}};const E=y;class S{constructor(t){if(null==t)throw new Error("shape required");if(!(t instanceof E))throw new Error(`IntTuple shape expected, found ${typeof t}: shape`);this.shape=t,this.done=!1,this.idx=[],t.forEach((t=>{this.idx.push(0)}))}next(){const t=this.shape;for(let e=0;e<t.length;e++){const s=t.length-1-e;if(this.idx[s]<t.get(s)-1)return void this.idx[s]++;if(0==s)return void(this.done=!0);this.idx[s]=0}}static shapeForEach(t,e){const s=new S(t);for(;!s.done;)e(s.idx),s.next()}}const b=v,C=S,I=y;class A{constructor(t={}){const e=t.engine;if(null==e)throw new Error("engine required to create tensor");this.engine=e;const s=t.shape;if(null==s)throw new Error("shape required to create tensor");if(s instanceof I)this.shape=s;else{if(!Array.isArray(s))throw new Error(`invalid shape type ${typeof s}: ${s}`);this.shape=e.intTuple(s)}this.order=this.shape.length;const r=b.numelOfShape(this.shape);this.numel=r;const n=t.slot;if(r>0&&null==n)throw new Error("memory slot required to create tensor");this.slot=t.slot,this.ptr=this.slot.ptr;const i=t.stride;if(null!=i){if(!(i instanceof I))throw new Error(`expected IntTuple stride, found ${typeof i}: ${i}`);this.stride=i}else this.setDefaultStride()}get wasmInstance(){return this.engine.wasmInstance}isScalar(){return 0==this.order}fill_(t){this.wasmInstance.exports.fill_(this.numel,this.ptr,t)}clamp_(t={}){const e=t.min,s=t.max;this.wasmInstance.exports.clamp(this.numel,this.ptr,this.ptr,e,s,null!=e,null!=s)}zero_(){this.fill_(0)}flattenIdx(t){let e,s,r=!1;if(Array.isArray(t)&&(e=this.engine.intTuple(t),r=!0),!(e instanceof I))throw new Error(`cannot handle ${typeof e}: ${e}`);return s=this.engine.wasmInstance.exports.flatten_idx(this.order,e.slot.ptr,this.stride.slot.ptr),r&&e.dispose(),s}typedArray(){return this.slot.f32()}toArray(){if(0==this.numel)return[];const t=b.makeNdArray(this.shape,0);return this.forEach((e=>{const s=this.get(e);b.setArrElem(t,e,s)})),t}get(t){const e=this.flattenIdx(t);return this.typedArray()[e]}item(){if(!this.isScalar())throw new Error(`item() only works for scalars, found tensor with shape ${this.shape}`);return this.get([0])}setDefaultStride(){let t=1;const e=this.order,s=[];for(let t=0;t<e;t++)s.push(0);for(let r=0;r<e;r++){const n=e-1-r;s[n]=t,t*=this.shape.get(n)}this.stride=this.engine.intTuple(s)}setFromArray(t){if(0!=this.numel)if(this.isScalar()){if("number"!=typeof t)throw new Error(`expected number, found ${typeof t}: ${t}`);this.set([0],t)}else{if(!Array.isArray(t))throw new Error(`expected array, found ${typeof t}: ${t}`);const e=b.inferShape(t);if(!this.shape.equal(e))throw new Error(`inconsistent shapes ${e} != ${this.shape}`);this.forEach((e=>{const s=b.getArrElem(t,e);this.set(e,s)}))}}set(t,e){if(null==e&&Array.isArray(t))this.setFromArray(t);else{const s=this.flattenIdx(t);this.typedArray()[s]=e}}forEach(t){C.shapeForEach(this.shape,t)}squeeze(t){-1==t&&(t=this.shape.length-1);const e=this.shape.get(t);if(1!=e)throw new Error(`cannot squeeze a dimension that is not equal to 1, shape[${t}] = ${e}`);const s=[];for(let e=0;e<this.order;e++)t!=e&&s.push(this.shape.get(e));return new A({engine:this.engine,shape:s,slot:this.slot})}unsqueeze(t){-1==t&&(t=this.shape.length-1);const e=[];for(let s=0;s<this.order;s++)e.push(this.shape.get(s)),t==s&&e.push(1);return new A({engine:this.engine,shape:e,slot:this.slot})}add(t,e){this.engine.functional.add(this,t,e)}sum(t){this.engine.wasmInstance.exports.sum(this.numel,this.slot.ptr,t.slot.ptr)}dispose(){this.slot.free(),this.shape.dispose(),this.stride.dispose()}}var _=A,T=class{constructor(){}};const z=T;const M=T;const V=T;const k=T;const $=class extends z{constructor(t,e){super(),this.nn=t,this.layers=e}forward(t){let e=t;return this.layers.forEach((t=>{e=t.forward(e)})),e}dispose(){this.layers.forEach((t=>{t.dispose()}))}},L=class extends M{constructor(t,e,s){super(),this.nn=t,this.inputSize=e,this.outputSize=s;const r=this.nn.engine;this.weight=r.zeros([s,e]),this.bias=r.zeros([s]),this.output=r.zeros([s])}forward(t){const e=this.nn.engine.functional;return e.matvec(this.weight,t,this.output),e.add(this.output,this.bias,this.output),this.output}dispose(){this.weight.dispose(),this.bias.dispose(),this.output.dispose()}},D=class extends V{constructor(t){super(),this.nn=t,this.output=null}forward(t){const e=this.nn.engine;return null==this.output&&(this.output=e.zerosLike(t)),e.functional.relu(t,this.output),this.output}dispose(){null!=this.output&&this.output.dispose()}},P=class extends k{constructor(t){super(),this.nn=t,this.output=null}forward(t){const e=this.nn.engine;return null==this.output&&(this.output=e.zerosLike(t)),e.functional.tanh(t,this.output),this.output}dispose(){null!=this.output&&this.output.dispose()}},q=f,W=v,F=_,B=y,R=class{constructor(t={}){const e=this.engine=t.engine;this.wasmInstance=e.wasmInstance}matvec(t,e,s){const r=t.shape.get(0),n=t.shape.get(1),i=e.shape.get(0),o=s.shape.get(0);if(r!=o)throw new Error(`inconsistent output size ${r} != ${o}`);if(n!=i)throw new Error(`inconsistent input size ${n} != ${i}`);this.wasmInstance.exports.matvec(r,n,t.stride.ptr,t.ptr,e.stride.ptr,e.ptr,s.stride.ptr,s.ptr)}mm(t,e,s){const r=t.shape.get(0),n=t.shape.get(1),i=e.shape.get(1);this.wasmInstance.exports.mm(r,n,i,t.stride.ptr,t.ptr,e.stride.ptr,e.ptr,s.stride.ptr,s.ptr)}relu(t,e){this.wasmInstance.exports.relu(t.numel,t.ptr,e.ptr)}tanh(t,e){const s=t.numel,r=t.typedArray(),n=e.typedArray();for(let t=0;t<s;t++)n[t]=Math.tanh(r[t])}add(t,e,s){this.wasmInstance.exports.add(t.numel,t.ptr,e.ptr,s.ptr)}sum(t,e){this.wasmInstance.exports.sum(t.numel,t.ptr,e.ptr)}sumBackward(t,e,s,r){this.wasmInstance.exports.sum_backward(t.numel,t.ptr,e.ptr,s.ptr,r.ptr)}},j=class{constructor(t={}){if(null==t.wasmInstance)throw new Error("wasmInstance required");this.wasmInstance=t.wasmInstance;const e=t.wasmInstance.exports.memory.buffer,s=new q.MemoryManager(e,t.wasmInstance.exports.__heap_base);this.mgr=s,this.functional=this.F=new R({engine:this}),this.nn=new class{constructor(t={}){this.engine=t.engine}Linear(t,e){return new L(this,t,e)}ReLU(){return new D(this)}Tanh(){return new P(this)}Sequential(){const t=Array.from(arguments);return new $(this,t)}}({engine:this}),this._mergeF()}_mergeF(){Object.getOwnPropertyNames(Object.getPrototypeOf(this.F)).forEach((t=>{"constructor"!=t&&(this[t]=this.F[t])}))}tensor(t){const e=W.inferShape(t),s=this.intTuple(e),r=W.numelOfShape(e),n=this.mgr.malloc32(r),i=new F({engine:this,shape:s,slot:n});return i.setFromArray(t),i}intTuple(t){if(!Array.isArray(t))throw new Error(`expected array, found ${typeof t}: ${t}`);const e=t.length,s=this.mgr.malloc32(e),r=new B({engine:this,length:e,slot:s});for(let s=0;s<e;s++)r.set(s,t[s]);return r}zerosLike(t){if(!(t instanceof F))throw new Error(`expected tensor, found ${typeof t}: ${t}`);return this.zeros(t.shape.toArray())}empty(t){let e;if(t instanceof B)e=t;else{if(!Array.isArray(t))throw new Error(`expected array, found ${typeof t}: ${t}`);e=this.intTuple(t)}const s=W.numelOfShape(e),r=this.mgr.malloc32(s);return new F({engine:this,shape:e,slot:r})}zeros(t){const e=this.empty(t);return e.zero_(),e}ones(t){const e=this.empty(t);return e.fill_(1),e}};var N={engine:function(t={}){return new j({wasmInstance:t.wasmInstance})},Engine:j,Tensor:_,mmgr:f,utils:v};const X=N;function U(t){return[t[0],t[1]]}function H(t,e){t[0]*=e,t[1]*=e}function G(t,e){const s=U(t);return H(s,e),s}function O(t){return t[0]*t[0]+t[1]*t[1]}function Y(t){return Math.sqrt(O(t))}var J={clone:U,add:function(t,e){return[t[0]+e[0],t[1]+e[1]]},add_:function(t,e){t[0]+=e[0],t[1]+=e[1]},mulScalar_:H,mulScalar:G,sub:function(t,e){return[t[0]-e[0],t[1]-e[1]]},quadrance:O,norm:Y,normalize:function(t){return G(t,1/Y(t))},dot:function(t,e){return t[0]*e[0]+t[1]*e[1]}};class K{constructor(t,e,s,r){this.m00=t,this.m01=e,this.m10=s,this.m11=r}get(t,e){return this[`m${t}${e}`]}set(t,e,s,r){this.m00=t,this.m01=e,this.m10=s,this.m11=r}toArray(){return[[this.m00,this.m01],[this.m10,this.m11]]}negate(){return new K(-this.m00,-this.m01,-this.m10,-this.m11)}apply(t){return[this.m00*t[0]+this.m01*t[1],this.m10*t[0]+this.m11*t[1]]}det(){return this.m00*this.m11-this.m10*this.m01}inv(){const t=this.det();return new K(this.m11/t,-this.m01/t,-this.m10/t,this.m00/t)}mm(t){const e=this.m00,s=this.m01,r=this.m10,n=this.m11,i=t.m00,o=t.m01,h=t.m10,l=t.m11;return new K(e*i+s*h,e*o+s*l,r*i+n*h,r*o+n*l)}t(){return new K(this.m00,this.m10,this.m01,this.m11)}static fromArray(t){return new K(t[0][0],t[0][1],t[1][0],t[1][1])}}var Q=K;const Z=Q,tt=J;class et{constructor(){this.translation=[0,0],this.linear=new Z(1,0,0,1)}inferScale(){return this.linear.m00}apply(t){return tt.add(this.linear.apply(t),this.translation)}inv(){const t=new et;return t.linear=this.linear.inv(),t.translation=t.linear.negate().apply(this.translation),t}toColumnMajorArray(){return[this.linear.get(0,0),this.linear.get(1,0),this.linear.get(0,1),this.linear.get(1,1),this.translation[0],this.translation[1]]}}var st={Vec2:J,Matrix2x2:Q,Transform2d:et,AABB:class{constructor(t={}){if(null==t.x0)throw new Error("x0 required");if(null==t.y0)throw new Error("y0 required");this._x0=t.x0,this._y0=t.y0;let e=null;if(null!=t.width)e=this._x0+t.width;else{if(null==t.x1)throw new Error("x1 required");e=t.x1}this._x1=e;let s=null;if(null!=t.height)s=this._y0+t.height;else{if(null==t.y1)throw new Error("y1 required");s=t.y1}this._y1=s}get x0(){return this._x0}get x1(){return this._x1}get y0(){return this._y0}get y1(){return this._y1}get width(){return this._x1-this._x0}get height(){return this._y1-this._y0}get center(){return[.5*(this.x0+this.x1),.5*(this.y0+this.y1)]}}};const rt=st;var nt={PointShader:class{constructor(){}renderPoint(t={}){const e=t.ctx,s=t.p;e.beginPath(),e.arc(s[0],s[1],3,0,2*Math.PI),e.fill()}},LineShader:class{constructor(){}renderLine(t={}){const e=t.ctx,s=t.a,r=t.b;e.beginPath(),e.strokeStyle="red",e.lineWidth=5,e.moveTo(s[0],s[1]),e.lineTo(r[0],r[1]),e.closePath(),e.stroke()}},TriangleShader:class{constructor(){}renderTriangle(t={}){const e=t.ctx,s=t.a,r=t.b,n=t.c;e.save(),e.beginPath(),e.strokeStyle="black",e.moveTo(s[0],s[1]),e.lineTo(r[0],r[1]),e.lineTo(n[0],n[1]),e.closePath(),e.stroke(),e.restore()}}};const it=st,ot=nt;var ht=class{constructor(t={}){this.scene=t.scene,this.id=t.id,this.x=[],this.triangles=[],this.lines=[],this.pointShader=new ot.PointShader({}),this.lineShader=new ot.LineShader({}),this.triangleShader=new ot.TriangleShader({}),this.customAttributes={}}numVertices(){return this.x.length}numTriangles(){return this.triangles.length}numLines(){return this.lines.length}setCustomAttribute(t,e){this.customAttributes[t]=e}getCustomAttribute(t){return this.customAttributes[t]}computeAABB(){let t=null,e=null,s=null,r=null;return this.x.forEach((n=>{const i=n[0],o=n[1];(null==t||i<t)&&(t=i),(null==e||i>e)&&(e=i),(null==s||o<s)&&(s=o),(null==r||o>r)&&(r=o)})),new it.AABB({x0:t,y0:s,x1:e,y1:r})}computeCenter(){let t=[0,0];const e=this.x.length;for(let s=0;s<e;s++){const e=this.x[s];it.Vec2.add_(t,e)}return it.Vec2.mulScalar_(t,1/e),t}};const lt=ht;const at=ht;var ct={Camera:class{constructor(){this.transform=new rt.Transform2d}domToWorldSpace(t){if(!Array.isArray(t))throw new Error("array expected, found "+typeof t);if(2!=t.length)throw new Error(`array with 2 elements expected, found ${t.length}`);return this.transform.inv().apply(t)}inferScale(){return this.transform.inferScale()}center(t){let e,s=t.zoom?t.zoom:1,r=t.viewportWidth,n=t.viewportHeight;if(null!=t.renderer&&(r=t.renderer.width,n=t.renderer.height),null!=t.worldWidth){if(null==r)throw new Error("viewportWidth required");s=r/t.worldWidth}if(this.transform.linear=new rt.Matrix2x2(s,0,0,-s),null!=t.worldCenter){const i=t.worldCenter;e=[.5*r-i[0]*s,.5*n+i[1]*s]}else e=[.5*r,.5*n];this.transform.translation=e}},Mesh:ht,Renderer:class{constructor(t={}){const e=t.headless??!1;if(this.headless=e,!e){const t=document.createElement("canvas");this.domElement=t,this.ctx=t.getContext("2d")}this.setSize({width:200,height:200})}setSize(t){const e=t.width;if(null==e)throw new Error("width required to setSize");const s=t.height;if(null==s)throw new Error("height required to setSize");let r=t.viewportWidth;null==r&&(r=e);let n=t.viewportHeight;if(null==n&&(n=s),this.width=e,this.height=s,this.viewportWidth=r,this.viewportHeight=n,!this.headless){const t=this.domElement;t.width=r,t.height=n,t.style.width=`${e}px`,t.style.height=`${s}px`}}renderPoint(t,e,s,r,n){const i=this.ctx;let o;if(!(e instanceof lt))throw new Error("invalid mesh");o=e.x[r];const h=s.transform.apply(o);i.save(),e.pointShader.renderPoint({ctx:i,renderer:t,mesh:e,camera:s,id:r,p:h,custom:n}),i.restore()}renderLine(t,e,s,r,n){const i=this.ctx,o=e.lines[r],h=s.transform.apply(e.x[o[0]]),l=s.transform.apply(e.x[o[1]]);i.save(),e.lineShader.renderLine({ctx:i,renderer:t,mesh:e,camera:s,id:r,a:h,b:l,custom:n}),i.restore()}renderTriangle(t,e,s,r,n){const i=this.ctx,o=e.triangles[r],h=o[0],l=o[1],a=o[2];let c,d,u;if(e.x instanceof Float32Array){const t=2;c=[e.x[h*t],e.x[h*t+1]],d=[e.x[l*t],e.x[l*t+1]],u=[e.x[a*t],e.x[a*t+1]]}else c=e.x[h],d=e.x[l],u=e.x[a];const p=s.transform.apply(c),m=s.transform.apply(d),g=s.transform.apply(u);i.save(),e.triangleShader.renderTriangle({ctx:i,renderer:t,mesh:e,camera:s,id:r,a:p,b:m,c:g,custom:n}),i.restore()}renderMesh(t,e,s,r={}){const n=e.sortedElements;if(null==n){for(let n=0;n<e.triangles.length;n++)this.renderTriangle(t,e,s,n,r);for(let n=0;n<e.lines.length;n++)this.renderLine(t,e,s,n,r);for(let n=0;n<e.x.length;n++)this.renderPoint(t,e,s,n,r)}else n.forEach((n=>{if(null==n.order)throw new Error(`invalid element, order not defined ${n}`);if(1==n.order)this.renderPoint(t,e,s,n.id,r);else if(2==n.order)this.renderLine(t,e,s,n.id,r);else{if(3!=n.order)throw new Error(`invalid element ${n}`);this.renderTriangle(t,e,s,n.id,r)}}))}render(t,e,s={}){this.ctx.clearRect(0,0,this.viewportWidth,this.viewportHeight),t.meshes.forEach((t=>{this.renderMesh(this,t,e,s)}))}},Scene:class{constructor(){this.meshes=new Map}clean(){this.meshes=new Map}numMeshes(){return this.meshes.size}addMesh(){const t=this.meshes.size,e=new at({scene:this,id:t});return this.meshes.set(t,e),e}}},dt={computeDomCursor:function(t,e){const s=e.getBoundingClientRect();let r,n;if(null==t.touches)r=t.clientX,n=t.clientY;else{if(0==t.touches.length)return null;const e=t.touches[0];r=e.clientX,n=e.clientY}return[r-s.left,n-s.top]}};const ut=dt;var pt={cursorUtils:dt,DragBehavior:class{constructor(t={}){this._dragging=!1,this.onDomCursorDown=t.onDomCursorDown,this.onDragProgress=t.onDragProgress,this.onDomCursorUp=t.onDomCursorUp,this.domElement=null}beginDrag(){this._dragging=!0}endDrag(){this._dragging=!1}dragging(){return this._dragging}domCursorDown(t,e){null!=this.onDomCursorDown&&this.onDomCursorDown(t,e)}domCursorMove(t,e){this.dragging()&&null!=this.onDragProgress&&this.onDragProgress(t,e)}domCursorUp(t,e){this.endDrag(),null!=this.onDomCursorUp&&this.onDomCursorUp(t,e)}linkToDom(t){if(null!=this.domElement)throw new Error("already linked to DOM");this.domElement=t;const e=e=>{e.preventDefault();const s=ut.computeDomCursor(e,t);this.domCursorDown(s,e)};t.addEventListener("mousedown",e,{passive:!1}),t.addEventListener("touchstart",e,{passive:!1});const s=e=>{const s=ut.computeDomCursor(e,t);this.domCursorMove(s,e)};t.addEventListener("mousemove",s,{passive:!1}),t.addEventListener("touchmove",s,{passive:!1});const r=e=>{const s=ut.computeDomCursor(e,t);this.domCursorUp(s,e)};window.addEventListener("mouseup",r),window.addEventListener("touchend",r),window.addEventListener("touchcancel",r)}}};class mt{constructor(t={}){if(null==t.scene)throw new Error("scene required");const e=null==t.color?"rgba(0, 0, 0, 0.30)":t.color,s=null==t.cellSize?1:t.cellSize,r=null==t.innerCells?3:t.innerCells,n=null==t.rows?3:t.rows,i=null==t.cols?4:t.cols,o=null==t.x0?-2:t.x0,h=null==t.y0?0:t.y0,l=null==t.primaryLineWidth?.03:t.primaryLineWidth,a=null==t.secondaryLineWidth?.008:t.secondaryLineWidth,c=this.mesh=t.scene.addMesh(),d=function(t={}){const e=null==t.cellSize?1:t.cellSize,s=null==t.innerCells?3:t.innerCells,r=null==t.rows?3:t.rows,n=null==t.cols?4:t.cols,i=null==t.x0?-2:t.x0,o=null==t.y0?0:t.y0,h=null==t.primaryLineWidth?.022:t.primaryLineWidth,l=null==t.secondaryLineWidth?.008:t.secondaryLineWidth,a=[],c=[],d=[],u=o+r*e,p=i+n*e;function m(t,e){for(let r=0;r<t+1;r++){const n=r==t?1:s;for(let t=0;t<n;t++){const s=2*c.length;e(r,t,n,a),c.push([s,s+1]),0==t?d.push(h):d.push(l)}}}return m(r,((t,s,r,n)=>{const h=s/r,l=(o+t*e)*(1-h)+(o+(t+1)*e)*h;n.push([i,l]),n.push([p,l])})),m(n,((t,s,r,n)=>{const h=s/r,l=(i+t*e)*(1-h)+(i+(t+1)*e)*h;n.push([l,o]),n.push([l,u])})),[a,c,d]}({cellSize:s,innerCells:r,rows:n,cols:i,x0:o,y0:h,primaryLineWidth:l,secondaryLineWidth:a});c.x=d[0],c.lines=d[1],c.setCustomAttribute("lineWidths",d[2]),c.setCustomAttribute("translation",[0,0]),c.pointShader.renderPoint=()=>{},c.lineShader.renderLine=mt.makeGridLineShader({color:e})}static makeGridLineShader(t={}){const e=null==t.color?"black":t.color;return t=>{const s=t.ctx,r=t.a,n=t.b,i=t.camera,o=t.mesh,h=i.inferScale();s.beginPath(),s.strokeStyle=e;const l=o.getCustomAttribute("lineWidths");if(null==l)throw new Error("custom attribute lineWidths missing");const a=l[t.id],c=o.getCustomAttribute("translation"),d=[h*c[0],h*c[1]];s.lineWidth=a*h,s.moveTo(r[0]+d[0],r[1]+d[1]),s.lineTo(n[0]+d[0],n[1]+d[1]),s.closePath(),s.stroke()}}}var gt={Grid:mt,Background:class{constructor(t={}){if(null==t.scene)throw new Error("scene required");const e=this.mesh=t.scene.addMesh();e.x=[[0,0]];const s=null==t.color1?"#fcfcfc":t.color1,r=null==t.color2?"#d7d8d8":t.color2;e.pointShader.renderPoint=(t={})=>{const e=t.renderer.width,n=t.renderer.height,i=t.ctx,o=i.createRadialGradient(.5*e,.5*n,.05*e,.5*e,.5*n,.5*e);o.addColorStop(0,s),o.addColorStop(1,r),i.fillStyle=o,i.fillRect(0,0,e,n)}}}},ft=class{constructor(t,e){if(null==t)throw new Error("id required to create simplex");this.order=e.length,this.id=t,this.vertexIds=e}};const wt=ft;function yt(t){return t.sort(),t.join("_")}var xt=class{constructor(t={}){if(null==t.order)throw new Error("order required");this.order=t.order,this.simplicesByHash=new Map}forEach(t){this.simplicesByHash.forEach(t)}size(){return this.simplicesByHash.size}has(t){return this.simplicesByHash.has(yt(t.vertexIds))}add(t,e){let s=null;if(Array.isArray(t)){if(null==e)throw new Error("id required");s=t,t=new wt(e,s)}else{if(s=t.vertexIds,null==s)throw new Error(`vertexIds required ${t}`);e=t.id}if(s.length!=this.order)throw new Error(`expected ${this.order} vertices, found ${s.length}`);const r=yt(s);return this.simplicesByHash.set(r,t),t}};const vt=xt,Et=xt;var St=class{constructor(t={}){this.vertices=new Map,this.edges=new Et({order:2}),this.triangles=new Et({order:3}),(t.edges??[]).forEach(((t,e)=>{this.addEdge(e,t)})),(t.triangles??[]).forEach(((t,e)=>{this.addTriangle(e,t)}))}numVertices(){return this.vertices.size}numEdges(){return this.edges.size()}numTriangles(){return this.triangles.size()}getVertexById(t,e=!1){let s=this.vertices.get(t);return null==s&&e&&(s=new class{constructor(t){this.id=t,this.edges=new vt({order:2}),this.triangles=new vt({order:3})}addTriangle(t,e){this.triangles.add(t,e)}addEdge(t,e){this.edges.add(t,e)}}(t),this.vertices.set(t,s)),s}addEdge(t,e){const s=this.edges.add(e,t);return e.forEach((t=>{this.getVertexById(t,!0).addEdge(s)})),s}addTriangle(t,e){const s=this.triangles.add(e,t);return e.forEach((t=>{this.getVertexById(t,!0).addTriangle(s)})),s}};const bt=St,Ct=xt;var It={math:st,ui:pt,shaders:nt,background:gt,sorted:{makeSortedElements:function(t={}){if(null==t.sortedVertexIds)throw new Error("sortedVertexIds required");if(null==t.triangles)throw new Error("triangles required");if(null==t.edges)throw new Error("edges required");const e=t.sortedVertexIds,s=new Map;e.forEach(((t,e)=>{s.set(t,e)}));const r=new bt({triangles:t.triangles}),n=new bt({edges:t.edges}),i=[],o=new Ct({order:3}),h=new Ct({order:2});return e.forEach((t=>{const e=r.getVertexById(t,!0).triangles,l=n.getVertexById(t,!0).edges,a=[];e.forEach((t=>{a.push(t)})),l.forEach((t=>{a.push(t)})),a.sort(((t,e)=>{const r=t.vertexIds.map((t=>s.get(t))),n=e.vertexIds.map((t=>s.get(t))),i=Math.max(...r),o=Math.max(...n);return i<o?1:i==o?0:-1})),a.forEach((t=>{if(2==t.order){const e=t;h.has(e)||(i.push(e),h.add(e))}else{const e=t;o.has(e)||(i.push(e),o.add(e))}})),i.push({order:1,id:t})})),i},MeshTopology:St,Simplex:ft,Simplices:xt},core:ct,Renderer:ct.Renderer,Camera:ct.Camera,Scene:ct.Scene};const At=class{constructor(t={}){this.targetCenterX=null,this.currentCenterX=null,this.active=!0,this.visibleWorldWidth=t.visibleWorldWidth??3.8}step(t={}){if(!this.active)return;const e=t.renderer,s=t.camera,r=t.mesh,n=t.floor,i=t.grid,o=r.computeCenter()[0];isNaN(o)||(this.targetCenterX=o),null==this.currentCenterX?this.currentCenterX=this.targetCenterX:this.currentCenterX+=.5*(this.targetCenterX-this.currentCenterX);const h=this.currentCenterX,l=3*Math.floor(h/3);i.mesh.setCustomAttribute("translation",[l,0]),n.mesh.setCustomAttribute("translation",[l,0]);const a=[this.currentCenterX,1];s.center({worldCenter:a,worldWidth:this.visibleWorldWidth,viewportWidth:e.width,viewportHeight:e.height})}},_t=It;function Tt(t){return t.sort(),t.join("_")}class zt{constructor(t={}){if(null==t.scene)throw new Error("scene required");const e=this.scene=t.scene,s=this.mesh=e.addMesh();s.x=[[-10,0],[10,0]],s.lines=[[0,1]],s.lineShader.renderLine=zt.makeFloorLineShaderFunction({width:t.width,color:t.color}),s.pointShader.renderPoint=()=>{},s.setCustomAttribute("translation",[0,0])}static makeFloorLineShaderFunction(t={}){const e=t.width??.055,s=t.color??"black";return t=>{const r=t.ctx,n=t.a,i=t.b,o=t.camera,h=t.mesh,l=o.inferScale(),a=h.getCustomAttribute("translation"),c=[l*a[0],l*a[1]];r.strokeStyle=s,r.lineWidth=l*e,r.beginPath(),r.moveTo(n[0]+c[0],n[1]+c[1]),r.lineTo(i[0]+c[0],i[1]+c[1]),r.stroke()}}}function Mt(t){if(7!=t.length)throw new Error(`invalid hex string ${t}`);if("#"!=t[0])throw new Error(`invalid hex string ${t}, expected #, found ${t[0]}`);return t=t.substring(1),[parseInt(t.substring(0,2),16),parseInt(t.substring(2,4),16),parseInt(t.substring(4,6),16)]}var Vt=function(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}({System:class{constructor(t={}){if(null==t.wasmInstance)throw new Error("wasmInstance required");const e=new X.Engine({wasmInstance:t.wasmInstance});this.ten=e;const s=e.wasmInstance,r=e.mgr;this.wasmInstance=s,this.memoryManager=r,this.fixedVertexId=-1,this.vertexMass=t.vertexMass??6.0714287757873535,this.h=.033,this.spaceDim=2}numVertices(){return null==this.x0?0:this.x0.shape.get(0)}numTriangles(){return null==this.triangles?0:this.triangles.u32().length/3}numSprings(){return null==this.springs?0:this.springs.u32().length/2}setX(t){const e=this.ten,s=this.spaceDim,r=t.length,n=e.tensor(t);null!=this.x0&&this.x0.dispose(),this.x0=n;const i=e.zeros([r,s]);null!=this.x1&&this.x1.dispose(),this.x1=i;const o=e.zeros([r,s]);null!=this.v0&&this.v0.dispose(),this.v0=o;const h=e.zeros([r,s]);null!=this.v1&&this.v1.dispose(),this.v1=h,this.updateTmpBuffers()}setSprings(t={}){if(null==t.indices)throw new Error("indices required");const e=t.indices,s=e.length,r=this.numSprings(),n=this.memoryManager,i=this.ten,o=n.malloc32(2*s);null!=this.springs&&this.springs.free(),this.springs=o;const h=o.u32();if(e.forEach(((t,e)=>{const s=2*e;h[s]=t[0],h[s+1]=t[1]})),null!=this.l0&&this.l0.dispose(),this.l0=null,0!=s){const e=i.zeros([s]);this.l0=e,null==t.l0?this.wasmInstance.exports.l0_of_x(this.numVertices(),this.x0.ptr,s,this.springs.ptr,this.l0.ptr):this.l0.set(t.l0)}const l=t.keepA??!1;if(s!=r){if(l)throw new Error(`keepA can only be true when the number of springs is the same (${s} != ${r})`);if(null!=this.a&&this.a.dispose(),0!=s){const t=i.zeros([s]);this.a=t,t.fill_(1)}}else 0==s?(null!=this.a&&this.a.dispose(),this.a=null):l||this.a.fill_(1)}setTriangles(t={}){if(null==t.indices)throw new Error("indices required");const e=t.indices,s=e.length,r=this.memoryManager,n=this.ten,i=r.malloc32(3*s);null!=this.triangles&&this.triangles.free(),this.triangles=i;const o=i.u32();e.forEach(((t,e)=>{const s=3*e;o[s]=t[0],o[s+1]=t[1],o[s+2]=t[2]}));const h=n.zeros([s,2,2]);null!=this.rsi&&this.rsi.dispose(),this.rsi=h,null==t.rsi?this.wasmInstance.exports.rsi_of_x(this.numVertices(),this.x0.ptr,s,this.triangles.ptr,this.rsi.ptr):this.rsi.set(t.rsi)}set(t){this.setX(t.x),this.r=null,this.setSprings({indices:t.springs??[],l0:t.springsL0}),this.setTriangles({indices:t.triangles??[],rsi:t.trianglesRsi})}updateTmpBuffers(){if(null==this.x0)throw new Error("x0 required");const t=this.numVertices(),e=this.spaceDim,s=this.ten,r=s.zeros([t,e]);null!=this.xGrad&&this.xGrad.dispose(),this.xGrad=r;const n=s.zeros([t,e]);null!=this.xTmp&&this.xTmp.dispose(),this.xTmp=n}step(){const t=this.numVertices(),e=this.numSprings(),s=this.numTriangles(),r=this.fixedVertexId,n=this.vertexMass;this.wasmInstance.exports.backward_euler_update(t,0==t?0:this.x1.ptr,0==t?0:this.xGrad.ptr,0==t?0:this.xTmp.ptr,0==t?0:this.x0.ptr,0==t?0:this.v0.ptr,0==t?0:this.v1.ptr,this.h,0,e,0==e?0:this.springs.ptr,s,0==s?0:this.triangles.ptr,0==s?0:this.rsi.ptr,0==e?0:this.a.ptr,0==e?0:this.l0.ptr,r,n),0!=t&&(this.x0.slot.f32().set(this.x1.slot.f32()),this.v0.slot.f32().set(this.v1.slot.f32()))}dispose(){null!=this.x0&&(this.x0.dispose(),this.x0=null),null!=this.x1&&(this.x1.dispose(),this.x1=null),null!=this.xGrad&&(this.xGrad.dispose(),this.xGrad=null),null!=this.xTmp&&(this.xTmp.dispose(),this.xTmp=null),null!=this.v0&&(this.v0.dispose(),this.v0=null),null!=this.v1&&(this.v1.dispose(),this.v1=null),null!=this.triangles&&(this.triangles.free(),this.triangles=null),null!=this.rsi&&(this.rsi.dispose(),this.rsi=null),null!=this.springs&&(this.springs.free(),this.springs=null),null!=this.l0&&(this.l0.dispose(),this.l0=null),null!=this.a&&(this.a.dispose(),this.a=null)}},mmgrten:N,SystemViewport:class{constructor(t={}){if(null==t.system)throw new Error("system required");this.system=t.system,this.sortedVertexIds=t.sortedVertexIds;const e=t.headless??!1,s=new _t.Renderer({headless:e});this.renderer=s,this.domElement=s.domElement,this.setSize({width:400,height:400});const r=new _t.Scene;this.scene=r;const n=new _t.Camera;this.camera=n;const i=t.borderColor??"black",o=i,h=t.fillColor??"white",l=t.gridColor??"#acadad";let a,c,d=t.activeMuscleColor??[255,0,0],u=t.inactiveMuscleColor??[250,190,190];"string"==typeof d&&(d=Mt(d)),"string"==typeof u&&(u=Mt(u)),null!=t.backgroundColor?(a=t.backgroundColor,c=t.backgroundColor):(a=t.backgroundCenterColor??"#fcfcfc",c=t.backgroundOuterColor??"#d7d8d8"),new _t.background.Background({scene:r,color1:a,color2:c}),this.grid=new _t.background.Grid({scene:r,x0:-3,y0:0,rows:4,cols:10,innerCells:2,primaryLineWidth:.022,secondaryLineWidth:.005,color:l}),this.floor=new zt({scene:r,color:o});const p=r.addMesh();if(this.mesh=p,p.pointShader.renderPoint=function(t={}){const e=t.radius??.028,s=t.borderColor??"black",r=t.fillColor??"white",n=t.borderWidth??.023;return t=>{const i=t.ctx,o=t.p,h=t.camera.inferScale(),l=(e+n)*h;i.fillStyle=s,i.beginPath(),i.arc(o[0],o[1],l,0,2*Math.PI),i.fill();const a=e*h;i.fillStyle=r,i.beginPath(),i.arc(o[0],o[1],a,0,2*Math.PI),i.fill()}}({borderColor:i,fillColor:h}),p.triangleShader.renderTriangle=(t={})=>{const e=t.ctx,s=t.a,r=t.b,n=t.c;e.beginPath(),e.fillStyle=h,e.moveTo(...s),e.lineTo(...r),e.lineTo(...n),e.closePath(),e.fill()},p.lineShader.renderLine=(t={})=>{const e=t.ctx,s=t.a,r=t.b,n=t.camera.inferScale(),o=t.mesh.getCustomAttribute("lineIdToSpringId")[t.id];if(null==o){const t=.029;e.beginPath(),e.lineJoin="round",e.lineCap="round",e.strokeStyle=i,e.lineWidth=t*n,e.moveTo(s[0],s[1]),e.lineTo(r[0],r[1]),e.closePath(),e.stroke()}else{const t=d,h=u,l=.065,a=.017,c="butt",m="muscleIntensity";e.beginPath(),e.lineCap=c,e.strokeStyle=i,e.lineWidth=(l+2*a)*n,e.moveTo(s[0],s[1]),e.lineTo(r[0],r[1]),e.stroke(),e.beginPath();const g=p.getCustomAttribute(m);if(null==g)throw new Error(`muscle intensity attribute (${m}) not found, call setCustomAttribute("${m}", value) before rendering.`);if(!Array.isArray(g))throw new Error("muscle intensity attribute must be an array with values for each fiber, found "+typeof g);const f=g[o],w=(1-f)*t[0]+f*h[0],y=(1-f)*t[1]+f*h[1],x=(1-f)*t[2]+f*h[2];e.strokeStyle=`rgb(${w}, ${y}, ${x})`,e.lineCap=c,e.lineWidth=l*n,e.moveTo(s[0],s[1]),e.lineTo(r[0],r[1]),e.stroke()}},t.draggable??1){const t=this.dragBehavior=new _t.ui.DragBehavior({onDomCursorDown:(e,s)=>{if("button"in s&&0!=s.button)return;const r=this.system,i=n.domToWorldSpace(e),o=this.hitTestVertex(i);null!=o&&(this.fixVertex(o),t.beginDrag(),this.setVertexPos(r.fixedVertexId,[i[0],Math.max(0,i[1])]))},onDragProgress:t=>{const e=this.system,s=n.domToWorldSpace(t);this.setVertexPos(e.fixedVertexId,[s[0],Math.max(0,s[1])])},onDomCursorUp:()=>{this.freeVertex()}});e||t.linkToDom(s.domElement)}this.tracker=new At}setSize(t={}){this.renderer.setSize({width:t.width,height:t.height})}render(){if(null==this.needsMeshUpdate||this.needsMeshUpdate){const t=[];if(null!=this.system.triangles){const e=this.system.triangles.u32();for(let s=0;s<this.system.numTriangles();s++){const r=3*s;t.push([e[r],e[r+1],e[r+2]])}}const e=[];if(null!=this.system.springs){const t=this.system.springs.u32();for(let s=0;s<this.system.numSprings();s++){const r=2*s;e.push([t[r],t[r+1]])}}this._updateMesh({triangles:t,springs:e}),this.needsMeshUpdate=!1}const t=this.renderer,e=this.scene,s=this.camera,r=this.mesh;this._updateFromSystem(),null!=this.dragBehavior&&this.dragBehavior.dragging()||this.tracker.step({mesh:r,camera:s,floor:this.floor,grid:this.grid,renderer:this.renderer}),t.render(e,s)}_updateMesh(t){const e=this.mesh;null!=t.x&&(e.x=t.x),e.triangles=t.triangles,e.lines=function(t){const e=new Map;function s(t,s){const r=Tt([t,s]);e.set(r,[t,s])}return t.forEach((t=>{s(t[0],t[1]),s(t[1],t[2]),s(t[0],t[2])})),Array.from(e.values())}(t.triangles);const s=new Map;if(null!=this.system.springs){const t=this.system.springs.u32();for(let e=0;e<this.system.numSprings();e++){const r=2*e,n=[t[r],t[r+1]];s.set(Tt(n),e)}}const r=[];e.setCustomAttribute("lineIdToSpringId",r),e.lines.forEach((t=>{const e=Tt(t),n=s.get(e);r.push(n)}));let n=this.sortedVertexIds;if(null==n){n=[];for(let t=0;t<this.system.numVertices();t++)n.push(t)}if(n.length!=this.system.numVertices())throw new Error(`invalid size for sortedVertexIds, found ${n.length}, expected ${this.system.numVertices()}`);e.sortedElements=_t.sorted.makeSortedElements({sortedVertexIds:n,triangles:e.triangles,edges:e.lines});const i=[],o=this.system.numSprings();for(let t=0;t<o;t++)i.push(1);e.setCustomAttribute("muscleIntensity",i)}_updateFromSystem(){this._updateVertexPositionsFromSystem(),this._updateMuscleIntensityFromSystem()}_updateVertexPositionsFromSystem(){const t=this.mesh,e=this.system;if(0==e.numVertices())t.x=[];else{const s=e.x0.toArray();t.x=s}}_updateMuscleIntensityFromSystem(){const t=this.mesh,e=this.system,s=[],r=e.numSprings();if(r>0){const t=e.a.slot.f32();for(let e=0;e<r;e++)s.push(t[e])}t.setCustomAttribute("muscleIntensity",s)}hitTestVertex(t,e=.31){const s=this.system.numVertices(),r=this.system.x0.slot.f32();let n=null,i=1/0;const o=e*e;for(let e=0;e<s;e++){const s=2*e,h=[r[s],r[s+1]],l=_t.math.Vec2.sub(h,t),a=_t.math.Vec2.quadrance(l);a<o&&a<i&&(n=e,i=a)}return n}setVertexPos(t,e){const s=this.system.x0.slot.f32(),r=2*t;s[r]=e[0],s[r+1]=e[1]}setVertexVel(t,e){const s=this.system.v0.slot.f32(),r=2*t;s[r]=e[0],s[r+1]=e[1]}fixVertex(t){const e=this.system;this.setVertexVel(t,[0,0]),null==t&&(t=-1),e.fixedVertexId=t}freeVertex(){this.system.fixedVertexId=-1}},mm2d:It});function kt(t,e){const s=1-Math.random(),r=Math.random();return t+Math.sqrt(-2*Math.log(s))*Math.cos(2*Math.PI*r)*e}class $t{constructor(t={}){if(null==t.system)throw new Error("system required to create policy");this.system=t.system,this.ten=this.system.ten,this.active=t.active??!1,this.stochastic=t.stochastic??!1,this.stdDev=t.stdDev??.05;const e=this.system,s=this.ten,r=e.numVertices(),n=e.numSprings();this.projectedX=s.zeros([r,2]),this.projectedV=s.zeros([r,2]);const i=2*r*2,o=n;this.input=s.zeros([i]);const h=s.nn;this.model=h.Sequential(h.Linear(i,32),h.ReLU(),h.Linear(32,o),h.Tanh())}step(){const t=this.system,e=this.ten.wasmInstance,s=t.numVertices();e.exports.make_neural_policy_input(s,t.x0.ptr,t.v0.ptr,this.centerVertexId,this.forwardVertexId,this.projectedX.ptr,this.projectedV.ptr,this.input.ptr);const r=this.model.forward(this.input),n=this.minA,i=this.maxAbsDa,o=this.system.a,h=r.slot.f32(),l=this.system.numSprings();for(let t=0;t<l;t++){let e;this.active?(e=r.get([t]),this.stochastic&&(e+=kt(0,this.stdDev))):e=1,h[t]=e}r.clamp_({min:-i,max:i});const a=o.slot.f32();for(let t=0;t<l;t++)a[t]+=h[t];o.clamp_({min:n,max:1})}loadData(t){const e=this.model.layers[0];e.weight.set(t.fc1.weight),e.bias.set(t.fc1.bias);const s=this.model.layers[2];s.weight.set(t.fc2.weight),s.bias.set(t.fc2.bias),this.minA=t.min_a??(()=>{throw new Error("min_a required")})(),this.maxAbsDa=t.max_abs_da??(()=>{throw new Error("max_abs_da required")})(),this.centerVertexId=t.center_vertex_id??(()=>{throw new Error("center_vertex_id required")})(),this.forwardVertexId=t.forward_vertex_id??(()=>{throw new Error("forward_vertex_id required")})()}dispose(){null!=this.projectedX&&this.projectedX.dispose(),null!=this.projectedV&&this.projectedV.dispose(),null!=this.input&&this.input.dispose(),this.model.dispose()}}class Lt{constructor(t={}){const e=this.domElement=document.createElement("div");e.style.userSelect="none",e.style.webkitTapHighlightColor="transparent",e.style.padding="12px",e.style.cursor="pointer",e.style.padding="0",e.style.borderRadius="50%",e.style.width="78px",e.style.height="78px",e.style.minHeight=e.style.height,e.style.margin="4px",e.style.display="flex",e.style.alignItems="center",e.style.justifyContent="center",e.style.boxShadow="0 0 8px rgba(0, 0, 0, 0.2)";const s=new Image;s.src=t.src;s.style.width="40px",s.style.height="40px",e.appendChild(s),this.setInactiveStyle()}setActiveStyle(){this.domElement.style.backgroundColor="black"}setInactiveStyle(){this.domElement.style.backgroundColor="rgba(1, 1, 1, 0.2)"}}const Dt="#000000";class Pt extends Vt.SystemViewport{constructor(t={}){super(t),this.setStyle()}setStyle(){this.domElement.style.borderRadius="10px",this.domElement.style.border="2px solid #c9c9c9",this.domElement.style.boxShadow="0 0 10px rgba(0, 0, 0, 0.1)";const t=window.matchMedia("(max-width: 410px)"),e=()=>{t.matches?this.setSize({width:300,height:350}):this.setSize({width:400,height:400})};t.addEventListener("change",(t=>{e()})),e()}}const qt="data";async function Wt(){const t=await fetch(`${qt}/mesh.json`);return await t.json()}async function Ft(){const t=await fetch(`${qt}/policy.json`);return await t.json()}!async function(){!function(){const t=document.createElement("a");document.body.appendChild(t),t.href="https://github.com/juniorrojas/algovivo",t.innerHTML='<svg style="cursor: pointer; position: absolute; top: 0; border: 0; right: 0; margin: 10px 7px;" viewBox="0 0 98 96" width="40" height="40" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M48.854 0C21.839 0 0 22 0 49.217c0 21.756 13.993 40.172 33.405 46.69 2.427.49 3.316-1.059 3.316-2.362 0-1.141-.08-5.052-.08-9.127-13.59 2.934-16.42-5.867-16.42-5.867-2.184-5.704-5.42-7.17-5.42-7.17-4.448-3.015.324-3.015.324-3.015 4.934.326 7.523 5.052 7.523 5.052 4.367 7.496 11.404 5.378 14.235 4.074.404-3.178 1.699-5.378 3.074-6.6-10.839-1.141-22.243-5.378-22.243-24.283 0-5.378 1.94-9.778 5.014-13.2-.485-1.222-2.184-6.275.486-13.038 0 0 4.125-1.304 13.426 5.052a46.97 46.97 0 0 1 12.214-1.63c4.125 0 8.33.571 12.213 1.63 9.302-6.356 13.427-5.052 13.427-5.052 2.67 6.763.97 11.816.485 13.038 3.155 3.422 5.015 7.822 5.015 13.2 0 18.905-11.404 23.06-22.324 24.283 1.78 1.548 3.316 4.481 3.316 9.126 0 6.6-.08 11.897-.08 13.526 0 1.304.89 2.853 3.316 2.364 19.412-6.52 33.405-24.935 33.405-46.691C97.707 22 75.788 0 48.854 0z" fill="#fff"/></svg>'}(),function(){const t=document.createElement("div");var e;document.body.appendChild(t),(e=t.style).display="flex",e.flexDirection="column",e.alignItems="center",e.color="white",e.width="100%",e.backgroundColor=Dt,e.paddingTop="20px",e.paddingBottom="20px",e.paddingRight="50px",e.paddingLeft="50px",e.marginBottom="30px",e.boxShadow="0 0 10px rgba(0, 0, 0, 0.3)";const s=document.createElement("h1");s.textContent="algovivo",t.appendChild(s),(t=>{t.fontSize="33px"})(s.style);const r=document.createElement("h2");r.textContent="an energy-based formulation for soft-bodied virtual creatures",t.appendChild(r),(t=>{t.textAlign="center",t.fontSize="18px",t.color="#c7c7c7"})(r.style)}(),document.body.style.background="rgb(248, 248, 248)",document.body.style.display="flex",document.body.style.flexDirection="column";const t=document.createElement("div");t.style.display="flex",t.style.flexDirection="column",t.style.alignItems="center",document.body.appendChild(t);const e=await async function(){const t=await fetch("algovivo.wasm");return(await WebAssembly.instantiateStreaming(t)).instance}(),s=new Vt.System({wasmInstance:e});document.documentElement.style.height="100%",document.body.style.height="100%",document.body.style.display="flex",document.body.style.margin=0,document.body.style.padding=0,document.body.style.alignItems="center";const[r,n]=await Promise.all([Wt,Ft].map((t=>t()))),i=new Pt({system:s,sortedVertexIds:r.sorted_vertex_ids});t.appendChild(i.domElement),s.set({x:r.x,springs:r.springs,springsL0:r.l0,triangles:r.triangles,trianglesRsi:r.rsi});const o=new $t({system:s,stochastic:!0});o.loadData(n),window.togglePolicy=()=>{o.active=!o.active,o.active?h.setActiveStyle():h.setInactiveStyle()};const h=new Lt({src:"assets/brain.svg"});h.domElement.style.marginTop="8px",h.domElement.style.marginBottom="8px",h.domElement.addEventListener("click",(()=>{togglePolicy()})),t.appendChild(h.domElement),i.render(),setInterval((()=>{o.step(),s.step(),i.render()}),1e3/30),window.system=s}();
