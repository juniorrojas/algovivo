function e(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}class t{constructor(e,t){this.list=e,this.data=t,this.next=null,this.prev=null}append(e){const s=new t(this.list,e);return this.list.last==this&&(this.list.last=s),s.next=this.next,s.prev=this,null!=this.next&&(this.next.prev=s),this.next=s,this.list.size++,s}prepend(e){const s=new t(this.list,e);return this.list.first==this&&(this.list.first=s),s.next=this,s.prev=this.prev,null!=this.prev&&(this.prev.next=s),this.prev=s,this.list.size++,s}remove(){null!=this.prev&&(this.prev.next=this.next),null!=this.next&&(this.next.prev=this.prev),this.list.first==this&&(this.list.first=this.next),this.list.last==this&&(this.list.last=this.prev),this.list.size--,this.next=null,this.prev=null}}var s=t;const r=s;class i{constructor(e){this.list=e,this.nextNode=this.list.first}next(){if(null==this.nextNode)return{done:!0};{const e={done:!1,value:this.nextNode.data};return this.nextNode=this.nextNode.next,e}}}class n{constructor(){this.first=null,this.last=null,this.size=0}isEmpty(){if(null==this.first&&null!=this.last||null!=this.first&&null==this.last)throw Error("inconsistent first last state");return null==this.first}append(e){return this.isEmpty()?this.setSingleton(e):this.last.append(e)}prepend(e){return this.isEmpty()?this.setSingleton(e):this.first.prepend(e)}setSingleton(e){const t=new r(this,e);return this.first=t,this.last=t,this.size=1,t}iter(){return new i(this)}*[Symbol.iterator](){const e=this.iter();let t=e.next();for(;!t.done;)yield t.value,t=e.next()}}var o,l,h,a,c,d,u={List:n,Node:s};function m(){if(l)return o;l=1;const e=p();return o=class extends e{constructor(e={}){super(e)}isFree(){return!1}free(){let e=this.appendFree(this.ptr,this.size);this.remove();const t=e.prev(),s=e.next();return null!=t&&t.isFree()&&(e=t.merge(e)),null!=s&&s.isFree()&&(e=e.merge(s)),e}}}function p(){if(a)return h;a=1;return h=class{constructor(e={}){this.manager=e.manager,this.ptr=e.ptr,this.size=e.size,this.node=e.node}numBytes(){return this.size}prev(){const e=this.node.prev;return null!=e?e.data:null}next(){const e=this.node.next;return null!=e?e.data:null}appendReserved(e,t){const s=m(),r=this.node.append(null),i=new s({manager:this.manager,ptr:e,size:t,node:r});return r.data=i,this.manager._addReservedSlot(i),i}appendFree(e,t){const s=f(),r=this.node.append(null),i=new s({manager:this.manager,ptr:e,size:t,node:r});return r.data=i,this.manager._addFreeSlot(i),i}remove(){this.node.remove(),this.node.data=null,this.node=null,this.isFree()?this.manager._removeFreeSlot(this):this.manager._removeReservedSlot(this)}toTypedArray(e){const t=this.size,s=e.BYTES_PER_ELEMENT;if(t%s!=0)throw new Error(`size in bytes must be a multiple of ${s}, found ${t}`);const r=this.ptr;return new e(this.manager.array,r,t/s)}f32(){return this.toTypedArray(Float32Array)}u32(){return this.toTypedArray(Uint32Array)}},h}function f(){if(d)return c;d=1;const e=p();return c=class extends e{constructor(e={}){super(e)}isFree(){return!0}reserve(e){const t=this.numBytes();if(e>t)throw new Error(`cannot reserve ${e} bytes, only ${t} bytes are available`);const s=this.appendReserved(this.ptr,e);return s.appendFree(this.ptr+e,t-e),this.remove(),s}merge(e){if(!this.isFree()||!e.isFree())throw new Error("only free slots can be merged");if(this.next()!=e)throw new Error("only adjacent slots can be merged");const t=e.appendFree(this.ptr,this.size+e.size);return this.remove(),e.remove(),t}}}const g=u,w=f();var y=class{constructor(e,t){this.array=e,null==t&&(t=0),this.ptrToSlot=new Map,this.slots=new g.List,this.freeSlots=new g.List,this.reservedSlots=new g.List;const s=new w({manager:this,ptr:t,size:e.byteLength-t}),r=this.slots.append();r.data=s,s.node=r;const i=this.freeSlots.append();i.data=s,s.freeNode=i}numReservedSlots(){return this.reservedSlots.size}numFreeSlots(){return this.freeSlots.size}numFreeBytes(){let e=0;const t=this.freeSlots.iter();let s=t.next();for(;!s.done;){e+=s.value.size,s=t.next()}return e}numReservedBytes(){let e=0;const t=this.reservedSlots.iter();let s=t.next();for(;!s.done;){e+=s.value.size,s=t.next()}return e}mallocBytes(e){return this._malloc(e)}malloc32(e){return this.mallocBytes(4*e)}_addReservedSlot(e){const t=this.reservedSlots.append(e);e.reservedNode=t}_removeReservedSlot(e){if(null==e.reservedNode)throw new Error("reservedNode cannot be null");e.reservedNode.remove()}_addFreeSlot(e){const t=this.freeSlots.append(e);e.freeNode=t}_removeFreeSlot(e){if(null==e.freeNode)throw new Error("freeNode cannot be null");e.freeNode.remove()}_malloc(e){if(!Number.isInteger(e))throw new Error(`expected integer, found ${e}`);let t=null;const s=this.freeSlots.iter();let r=s.next();for(;!r.done;){const i=r.value;if(i.size>=e){t=i;break}r=s.next()}if(null==t)throw new Error("no valid free slot available");return t.reserve(e)}malloc(e){const t=this._malloc(e);return this.ptrToSlot.set(t.ptr,t),t.ptr}free(e){this.ptrToSlot.get(e).free()}},x={linked:u,MemoryManager:y,FreeSlot:f(),ReservedSlot:m()};class v{constructor(e={}){const t=e.engine;if(null==t)throw new Error("engine required to create IntTuple");this.engine=t;const s=e.slot;if(null==s)throw new Error("slot required to create IntTuple");this.slot=s,this.ptr=s.ptr,this.length=e.length}forEach(e){for(let t=0;t<this.length;t++)e(this.get(t),t)}equal(e){if(e instanceof v){for(let t=0;t<this.length;t++){if(this.get(t)!=e.get(t))return!1}return!0}if(Array.isArray(e)){for(let t=0;t<this.length;t++){if(this.get(t)!=e[t])return!1}return!0}return!1}toString(){return this.slot.u32().toString()}toArray(){const e=[];return this.forEach((t=>{e.push(t)})),e}typedArray(){return this.slot.u32()}set(e,t){this.typedArray()[e]=t}get(e){return this.typedArray()[e]}dispose(){this.slot.free()}}var E=v;function b(e,t,s,r){if(t==s.length-1)for(let i=0;i<s[t];i++)e.push(r);else for(let i=0;i<s[t];i++){const i=[];e.push(i),b(i,t+1,s,r)}}var S={inferShape:function(e){const t=[];let s=e;for(;Array.isArray(s);)t.push(s.length),s=s[0];return t},makeNdArray:function(e,t){let s=e;e instanceof E&&(s=e.toArray());const r=[];return b(r,0,s,t),r},numelOfShape:function(e){let t=1;return e.forEach((e=>{t*=e})),t},getArrElem:function e(t,s){if(!Array.isArray(s))throw new Error(`expected array, found ${typeof s}: ${s}`);return 0==s.length?t:e(t[s[0]],s.slice(1))},setArrElem:function e(t,s,r){if(!Array.isArray(s))throw new Error(`expected array, found ${typeof s}: ${s}`);if(1!=s.length)return e(t[s[0]],s.slice(1),r);t[s]=r}};const V=E;class I{constructor(e){if(null==e)throw new Error("shape required");if(!(e instanceof V))throw new Error(`IntTuple shape expected, found ${typeof e}: shape`);this.shape=e,this.done=!1,this.idx=[],e.forEach((e=>{this.idx.push(0)}))}next(){const e=this.shape;for(let t=0;t<e.length;t++){const s=e.length-1-t;if(this.idx[s]<e.get(s)-1)return void this.idx[s]++;if(0==s)return void(this.done=!0);this.idx[s]=0}}static shapeForEach(e,t){const s=new I(e);for(;!s.done;)t(s.idx),s.next()}}const C=S,A=I,M=E;class T{constructor(e={}){const t=e.engine;if(null==t)throw new Error("engine required to create tensor");this.engine=t;const s=e.shape;if(null==s)throw new Error("shape required to create tensor");if(s instanceof M)this.shape=s;else{if(!Array.isArray(s))throw new Error(`invalid shape type ${typeof s}: ${s}`);this.shape=t.intTuple(s)}this.order=this.shape.length;const r=C.numelOfShape(this.shape);this.numel=r;const i=e.slot;if(r>0&&null==i)throw new Error("memory slot required to create tensor");this.slot=e.slot;const n=e.stride;if(null!=n){if(!(n instanceof M))throw new Error(`expected IntTuple stride, found ${typeof n}: ${n}`);this.stride=n}else this.setDefaultStride()}get ptr(){return this.slot.ptr}get wasmInstance(){return this.engine.wasmInstance}isScalar(){return 0==this.order}fill_(e){this.wasmInstance.exports.fill_(this.numel,this.ptr,e)}clamp_(e={}){const t=e.min,s=e.max;this.wasmInstance.exports.clamp(this.numel,this.ptr,this.ptr,t,s,null!=t,null!=s)}zero_(){this.fill_(0)}flattenIdx(e){let t,s,r=!1;if(Array.isArray(e)&&(t=this.engine.intTuple(e),r=!0),!(t instanceof M))throw new Error(`cannot handle ${typeof t}: ${t}`);return s=this.engine.wasmInstance.exports.flatten_idx(this.order,t.slot.ptr,this.stride.slot.ptr),r&&t.dispose(),s}typedArray(){return this.slot.f32()}toArray(){if(0==this.numel)return[];const e=C.makeNdArray(this.shape,0);return this.forEach((t=>{const s=this.get(t);C.setArrElem(e,t,s)})),e}get(e){const t=this.flattenIdx(e);return this.typedArray()[t]}item(){if(!this.isScalar())throw new Error(`item() only works for scalars, found tensor with shape ${this.shape}`);return this.get([0])}setDefaultStride(){let e=1;const t=this.order,s=[];for(let e=0;e<t;e++)s.push(0);for(let r=0;r<t;r++){const i=t-1-r;s[i]=e,e*=this.shape.get(i)}this.stride=this.engine.intTuple(s)}setFromArray(e){if(0==this.numel)return;if(this.isScalar()){if("number"!=typeof e)throw new Error(`expected number, found ${typeof e}: ${e}`);this.set([0],e)}else{if(!Array.isArray(e))throw new Error(`expected array, found ${typeof e}: ${e}`);const t=C.inferShape(e);if(!this.shape.equal(t))throw new Error(`inconsistent shapes ${t} != ${this.shape}`);this.forEach((t=>{const s=C.getArrElem(e,t);this.set(t,s)}))}}set(e,t){if(null==t&&Array.isArray(e))this.setFromArray(e);else{const s=this.flattenIdx(e);this.typedArray()[s]=t}}forEach(e){A.shapeForEach(this.shape,e)}squeeze(e){-1==e&&(e=this.shape.length-1);const t=this.shape.get(e);if(1!=t)throw new Error(`cannot squeeze a dimension that is not equal to 1, shape[${e}] = ${t}`);const s=[];for(let t=0;t<this.order;t++)e!=t&&s.push(this.shape.get(t));return new T({engine:this.engine,shape:s,slot:this.slot})}unsqueeze(e){-1==e&&(e=this.shape.length-1);const t=[];for(let s=0;s<this.order;s++)t.push(this.shape.get(s)),e==s&&t.push(1);return new T({engine:this.engine,shape:t,slot:this.slot})}add(e,t){this.engine.functional.add(this,e,t)}sum(e){this.engine.wasmInstance.exports.sum(this.numel,this.slot.ptr,e.slot.ptr)}dispose(){if(null==this.slot)throw new Error("tensor already disposed");this.slot.free(),this.slot=null,this.shape.dispose(),this.stride.dispose()}}var _=T;var k=class{constructor(e={}){const t=this.engine=e.engine;this.wasmInstance=t.wasmInstance}matvec(e,t,s){const r=e.shape.get(0),i=e.shape.get(1),n=t.shape.get(0),o=s.shape.get(0);if(r!=o)throw new Error(`inconsistent output size ${r} != ${o}`);if(i!=n)throw new Error(`inconsistent input size ${i} != ${n}`);this.wasmInstance.exports.matvec(r,i,e.stride.ptr,e.ptr,t.stride.ptr,t.ptr,s.stride.ptr,s.ptr)}mm(e,t,s){const r=e.shape.get(0),i=e.shape.get(1),n=t.shape.get(1);this.wasmInstance.exports.mm(r,i,n,e.stride.ptr,e.ptr,t.stride.ptr,t.ptr,s.stride.ptr,s.ptr)}relu(e,t){this.wasmInstance.exports.relu(e.numel,e.ptr,t.ptr)}tanh(e,t){const s=e.numel,r=e.typedArray(),i=t.typedArray();for(let e=0;e<s;e++)i[e]=Math.tanh(r[e])}add(e,t,s){this.wasmInstance.exports.add(e.numel,e.ptr,t.ptr,s.ptr)}sum(e,t){this.wasmInstance.exports.sum(e.numel,e.ptr,t.ptr)}sumBackward(e,t,s,r){this.wasmInstance.exports.sum_backward(e.numel,e.ptr,t.ptr,s.ptr,r.ptr)}};var z=class{constructor(){}};const L=z;var D=class extends L{constructor(e,t){super(),this.nn=e,this.layers=t}forward(e){let t=e;return this.layers.forEach((e=>{t=e.forward(t)})),t}dispose(){this.layers.forEach((e=>{e.dispose()}))}};const $=z;var P=class extends ${constructor(e,t,s){super(),this.nn=e,this.inputSize=t,this.outputSize=s;const r=this.nn.engine;this.weight=r.zeros([s,t]),this.bias=r.zeros([s]),this.output=r.zeros([s])}forward(e){const t=this.nn.engine.functional;return t.matvec(this.weight,e,this.output),t.add(this.output,this.bias,this.output),this.output}dispose(){this.weight.dispose(),this.bias.dispose(),this.output.dispose()}};const q=z;var W=class extends q{constructor(e){super(),this.nn=e,this.output=null}forward(e){const t=this.nn.engine;return null==this.output&&(this.output=t.zerosLike(e)),t.functional.relu(e,this.output),this.output}dispose(){null!=this.output&&this.output.dispose()}};const F=z;var B=class extends F{constructor(e){super(),this.nn=e,this.output=null}forward(e){const t=this.nn.engine;return null==this.output&&(this.output=t.zerosLike(e)),t.functional.tanh(e,this.output),this.output}dispose(){null!=this.output&&this.output.dispose()}};const R=D,O=P,j=W,N=B;const H=x,U=S,X=_,G=E,Y=k,Z=class{constructor(e={}){this.engine=e.engine}Linear(e,t){return new O(this,e,t)}ReLU(){return new j(this)}Tanh(){return new N(this)}Sequential(){const e=Array.from(arguments);return new R(this,e)}};var J=class{constructor(e={}){null!=e.wasmInstance&&this.init(e)}init(e={}){if(null==e.wasmInstance)throw new Error("wasmInstance required");this.wasmInstance=e.wasmInstance;const t=e.wasmInstance.exports.memory.buffer,s=new H.MemoryManager(t,e.wasmInstance.exports.__heap_base);this.mgr=s,this.functional=this.F=new Y({engine:this}),this.nn=new Z({engine:this}),this._mergeF()}_mergeF(){Object.getOwnPropertyNames(Object.getPrototypeOf(this.F)).forEach((e=>{"constructor"!=e&&(this[e]=this.F[e])}))}tensor(e){const t=U.inferShape(e),s=this.intTuple(t),r=U.numelOfShape(t),i=this.mgr.malloc32(r),n=new X({engine:this,shape:s,slot:i});return n.setFromArray(e),n}intTuple(e){if(!Array.isArray(e))throw new Error(`expected array, found ${typeof e}: ${e}`);const t=e.length,s=this.mgr.malloc32(t),r=new G({engine:this,length:t,slot:s});for(let s=0;s<t;s++)r.set(s,e[s]);return r}zerosLike(e){if(!(e instanceof X))throw new Error(`expected tensor, found ${typeof e}: ${e}`);return this.zeros(e.shape.toArray())}empty(e){let t;if(e instanceof G)t=e;else{if(!Array.isArray(e))throw new Error(`expected array, found ${typeof e}: ${e}`);t=this.intTuple(e)}const s=U.numelOfShape(t),r=this.mgr.malloc32(s);return new X({engine:this,shape:t,slot:r})}zeros(e){const t=this.empty(e);return t.zero_(),t}ones(e){const t=this.empty(e);return t.fill_(1),t}};const K=J;var Q={engine:function(e={}){return new K({wasmInstance:e.wasmInstance})},Engine:K,Tensor:_,mmgr:x,utils:S};var ee=class{constructor(e={}){const t=e.ten;if(null==t)throw new Error("ten required");this.ten=t,this.spaceDim=e.spaceDim??2,this.vertexMass=e.vertexMass??6.0714287757873535,this.pos0=null,this.pos1=null,this.vel0=null,this.vel1=null,this.posGrad=null,this.posTmp=null,this._fixedVertexId=null}toStepArgs(){const e=this.numVertices,t=this.vertexMass,s=this.fixedVertexId;return[e,0==e?0:this.pos0.ptr,0==e?0:this.vel0.ptr,t,-1==s?0:this._fixedVertexId.ptr,0==e?0:this.pos1.ptr,0==e?0:this.posGrad.ptr,0==e?0:this.posTmp.ptr,0==e?0:this.vel1.ptr]}setVertexPos(e,t){for(let s=0;s<this.spaceDim;s++)this.pos.set([e,s],t[s])}getVertexPos(e){const t=[];for(let s=0;s<this.spaceDim;s++)t.push(this.pos.get([e,s]));return t}get fixedVertexId(){return null==this._fixedVertexId?-1:this._fixedVertexId.u32()[0]}fixVertex(e){null==this._fixedVertexId&&(this._fixedVertexId=this.ten.mgr.malloc32(1)),this._fixedVertexId.u32().set([e])}freeVertex(){null!=this._fixedVertexId&&(this._fixedVertexId.free(),this._fixedVertexId=null)}get pos(){return this.pos0}get vel(){return this.vel0}get numVertices(){return null==this.pos0?0:this.pos0.shape.get(0)}updateTmpBuffers(){if(null==this.pos0)throw new Error("pos0 required");const e=this.numVertices,t=this.spaceDim,s=this.ten,r=s.zeros([e,t]);null!=this.posGrad&&this.posGrad.dispose(),this.posGrad=r;const i=s.zeros([e,t]);null!=this.posTmp&&this.posTmp.dispose(),this.posTmp=i}get wasmInstance(){return this.ten.wasmInstance}get memoryManager(){return this.ten.mgr}set(e){const t=this.ten,s=this.spaceDim;if(null==e)throw new Error("pos required");const r=e.length,i=t.tensor(e);null!=this.pos0&&this.pos0.dispose(),this.pos0=i;const n=t.zeros([r,s]);null!=this.pos1&&this.pos1.dispose(),this.pos1=n;const o=t.zeros([r,s]);null!=this.vel0&&this.vel0.dispose(),this.vel0=o;const l=t.zeros([r,s]);null!=this.vel1&&this.vel1.dispose(),this.vel1=l,this.updateTmpBuffers()}addVertex(e={}){const t=this.ten,s=this.numVertices,r=this.spaceDim,i=t.empty([s+1,r]),n=t.empty([s+1,r]),o=t.empty([s+1,r]),l=t.empty([s+1,r]);for(let e=0;e<s;e++)for(let t=0;t<r;t++)i.set([e,t],this.pos0.get([e,t])),n.set([e,t],this.vel0.get([e,t])),o.set([e,t],this.pos1.get([e,t])),l.set([e,t],this.vel1.get([e,t]));const h=e.pos??[0,0],a=e.vel??[0,0];for(let e=0;e<r;e++)i.set([s,e],h[e]),o.set([s,e],h[e]),n.set([s,e],a[e]),l.set([s,e],a[e]);null!=this.pos0&&this.pos0.dispose(),this.pos0=i,null!=this.vel0&&this.vel0.dispose(),this.vel0=n,null!=this.pos1&&this.pos1.dispose(),this.pos1=o,null!=this.vel1&&this.vel1.dispose(),this.vel1=l,this.updateTmpBuffers()}dispose(){null!=this._fixedVertexId&&(this._fixedVertexId.free(),this._fixedVertexId=null),null!=this.pos0&&(this.pos0.dispose(),this.pos0=null),null!=this.pos1&&(this.pos1.dispose(),this.pos1=null),null!=this.vel0&&(this.vel0.dispose(),this.vel0=null),null!=this.vel1&&(this.vel1.dispose(),this.vel1=null),null!=this.posGrad&&(this.posGrad.dispose(),this.posGrad=null),null!=this.posTmp&&(this.posTmp.dispose(),this.posTmp=null)}};var te=class{constructor(e={}){const t=e.ten;if(null==t)throw new Error("ten required");this.ten=t,this.indices=null,this.k=Math.fround(90),this.l0=null,this.a=null}get wasmInstance(){return this.ten.wasmInstance}get memoryManager(){return this.ten.mgr}get numMuscles(){return null==this.indices?0:this.indices.u32().length/2}set(e={}){if(null==e.indices)throw new Error("indices required");const t=e.indices,s=t.length,r=this.numMuscles,i=this.memoryManager,n=this.ten;null!=e.k&&(this.k=e.k);const o=i.malloc32(2*s);null!=this.indices&&this.indices.free(),this.indices=o;const l=o.u32();if(t.forEach(((e,t)=>{const s=2*t;l[s]=e[0],l[s+1]=e[1]})),null!=this.l0&&this.l0.dispose(),this.l0=null,0!=s){const t=n.zeros([s]);this.l0=t,null==e.l0?this.wasmInstance.exports.l0_of_pos(this.numVertices,e.pos.ptr,s,this.indices.ptr,this.l0.ptr):this.l0.set(e.l0)}const h=e.keepA??!1;if(s!=r){if(h)throw new Error(`keepA can only be true when the number of muscles is the same (${s} != ${r})`);if(null!=this.a&&(this.a.dispose(),this.a=null),0!=s){const e=n.zeros([s]);this.a=e,e.fill_(1)}}else 0==s?(null!=this.a&&this.a.dispose(),this.a=null):h||this.a.fill_(1)}toStepArgs(){const e=this.numMuscles;return[e,0==e?0:this.indices.ptr,this.k,0==e?0:this.a.ptr,0==e?0:this.l0.ptr]}dispose(){null!=this.indices&&(this.indices.free(),this.indices=null),null!=this.l0&&(this.l0.dispose(),this.l0=null),null!=this.a&&(this.a.dispose(),this.a=null)}};var se=class{constructor(e={}){const t=e.ten;if(null==t)throw new Error("ten required");this.ten=t,this.simplexOrder=e.simplexOrder??3,this.indices=null,this.rsi=null,this.mu=null,this.lambda=null}get wasmInstance(){return this.ten.wasmInstance}get memoryManager(){return this.ten.mgr}get numElements(){return null==this.indices?0:this.indices.u32().length/this.simplexOrder}get numTriangles(){return this.numElements}toStepArgs(){const e=this.numElements;return[e,0==e?0:this.indices.ptr,0==e?0:this.rsi.ptr,0==e?0:this.mu.ptr,0==e?0:this.lambda.ptr]}set(e={}){const t=e.indices,s=e.rsi,r=t?t.length:this.numTriangles;if(null==t&&(!s||s.length!==r))throw new Error("rsi is not consistent with the number of indices");const i=this.memoryManager,n=this.ten,o=t?i.malloc32(r*this.simplexOrder):this.indices;if(t&&null!=this.indices&&this.indices.free(),this.indices=o,null!=t){const e=o.u32();t.forEach(((t,s)=>{const r=s*this.simplexOrder;for(let s=0;s<this.simplexOrder;s++)e[r+s]=t[s]}))}if(null!=this.rsi&&this.rsi.dispose(),this.rsi=n.zeros([r,this.simplexOrder-1,this.simplexOrder-1]),null==s){let t=null,s=!1;if(null!=e.pos)if(Array.isArray(e.pos))t=n.tensor(e.pos),s=!0;else if(t=e.pos,null==t.ptr)throw new Error("invalid pos");this.wasmInstance.exports.rsi_of_pos(this.numVertices,t.ptr,r,this.indices.ptr,this.rsi.ptr),s&&t.dispose()}else this.rsi.set(s);null!=this.mu&&this.mu.dispose(),this.mu=n.zeros([r]),this.mu.fill_(Math.fround(500)),null!=this.lambda&&this.lambda.dispose(),this.lambda=n.zeros([r]),this.lambda.fill_(Math.fround(50))}dispose(){null!=this.indices&&(this.indices.free(),this.indices=null),null!=this.rsi&&(this.rsi.dispose(),this.rsi=null),null!=this.mu&&(this.mu.dispose(),this.mu=null),null!=this.lambda&&(this.lambda.dispose(),this.lambda=null)}};const re=Q,ie=ee,ne=te,oe=se;var le=class{constructor(e={}){let t;if(null==e.ten){if(null==e.wasmInstance)throw new Error("wasmInstance required");t=new re.Engine({wasmInstance:e.wasmInstance}),this.ten=t}else t=e.ten,this.ten=t;this.h=.033,this.g=9.8,this.spaceDim=e.spaceDim??2,this.vertices=new ie({ten:this.ten,vertexMass:e.vertexMass,spaceDim:this.spaceDim}),this.muscles=new ne({ten:this.ten}),this.triangles=new oe({ten:this.ten,simplexOrder:this.spaceDim+1}),this.friction={k:Math.fround(300)},this.collision={k:Math.fround(14e3)}}set fixedVertexId(e){throw new Error("System.fixedVertexId setter is deprecated, use System.vertices.fixedVertexId instead")}get fixedVertexId(){throw new Error("System.fixedVertexId getter is deprecated, use System.vertices.fixedVertexId instead")}get wasmInstance(){return this.ten.wasmInstance}get memoryManager(){return this.ten.mgr}get vertexMass(){return this.vertices.vertexMass}get rsi(){return this.triangles.rsi}set rsi(e){this.triangles.rsi=e}get k(){return this.muscles.k}set k(e){this.muscles.k=e}get pos0(){return this.vertices.pos}get vel0(){return this.vertices.vel0}get pos(){return this.vertices.pos}get vel(){return this.vertices.vel}get numVertices(){return this.vertices.numVertices}get numTriangles(){return this.triangles.numTriangles}get numMuscles(){return this.muscles.numMuscles}get a(){return this.muscles.a}set a(e){this.muscles.a=e}get l0(){return this.muscles.l0}set l0(e){this.muscles.l0=e}setVertices(e){this.vertices.set(e)}setMuscles(e={}){this.muscles.set({...e,pos:e.pos??this.pos0})}setTriangles(e={}){this.triangles.set({...e,pos:e.pos??this.pos0})}getMusclesArray(){if(0==this.numMuscles)return[];const e=this.numMuscles,t=this.muscles.indices.u32(),s=[];for(let r=0;r<e;r++){const e=2*r;s.push([t[e],t[e+1]])}return s}getTrianglesArray(){if(0==this.numTriangles)return[];const e=this.numTriangles,t=this.triangles.indices.u32(),s=[];for(let r=0;r<e;r++){const e=3*r;s.push([t[e],t[e+1],t[e+2]])}return s}set(e){this.setVertices(e.pos),this.setMuscles({indices:e.muscles??[],l0:e.musclesL0,k:e.musclesK}),this.setTriangles({indices:e.triangles??[],rsi:e.trianglesRsi})}toStepArgs(){return[this.spaceDim,this.g,this.h,...this.vertices.toStepArgs(),...this.muscles.toStepArgs(),...this.triangles.toStepArgs(),this.friction.k,this.collision.k]}step(){const e=this.toStepArgs();this.wasmInstance.exports.backward_euler_update(...e),0!=this.numVertices&&(this.vertices.pos0.slot.f32().set(this.vertices.pos1.slot.f32()),this.vertices.vel0.slot.f32().set(this.vertices.vel1.slot.f32()))}dispose(){this.vertices.dispose(),this.muscles.dispose(),this.triangles.dispose()}};function he(e){return[e[0],e[1]]}function ae(e,t){e[0]*=t,e[1]*=t}function ce(e){return e[0]*e[0]+e[1]*e[1]}function de(e){return Math.sqrt(ce(e))}function ue(e){const t=de(e);0!==t&&ae(e,1/t)}var me={clone:he,add:function(e,t){return[e[0]+t[0],e[1]+t[1]]},add_:function(e,t){e[0]+=t[0],e[1]+=t[1]},mulScalar_:ae,mulScalar:function(e,t){const s=he(e);return ae(s,t),s},sub:function(e,t){return[e[0]-t[0],e[1]-t[1]]},quadrance:ce,norm:de,normalize:function(e){const t=[...e];return ue(t),t},normalize_:ue,dot:function(e,t){return e[0]*t[0]+e[1]*t[1]}};class pe{constructor(e,t,s,r){this.m00=e,this.m01=t,this.m10=s,this.m11=r}get(e,t){return this[`m${e}${t}`]}set(e,t,s,r){this.m00=e,this.m01=t,this.m10=s,this.m11=r}toArray(){return[[this.m00,this.m01],[this.m10,this.m11]]}negate(){return new pe(-this.m00,-this.m01,-this.m10,-this.m11)}apply(e){return[this.m00*e[0]+this.m01*e[1],this.m10*e[0]+this.m11*e[1]]}det(){return this.m00*this.m11-this.m10*this.m01}inv(){const e=this.det();return new pe(this.m11/e,-this.m01/e,-this.m10/e,this.m00/e)}mm(e){const t=this.m00,s=this.m01,r=this.m10,i=this.m11,n=e.m00,o=e.m01,l=e.m10,h=e.m11;return new pe(t*n+s*l,t*o+s*h,r*n+i*l,r*o+i*h)}t(){return new pe(this.m00,this.m10,this.m01,this.m11)}static fromArray(e){return new pe(e[0][0],e[0][1],e[1][0],e[1][1])}}var fe=pe;const ge=fe,we=me;class ye{constructor(){this.translation=[0,0],this.linear=new ge(1,0,0,1)}inferScale(){return this.linear.m00}apply(e){return we.add(this.linear.apply(e),this.translation)}inv(){const e=new ye;return e.linear=this.linear.inv(),e.translation=e.linear.negate().apply(this.translation),e}toColumnMajorArray(){return[this.linear.get(0,0),this.linear.get(1,0),this.linear.get(0,1),this.linear.get(1,1),this.translation[0],this.translation[1]]}}var xe=ye;var ve={Vec2:me,Matrix2x2:fe,Transform2d:xe,AABB:class{constructor(e={}){if(null==e.x0)throw new Error("x0 required");if(null==e.y0)throw new Error("y0 required");this._x0=e.x0,this._y0=e.y0;let t=null;if(null!=e.width)t=this._x0+e.width;else{if(null==e.x1)throw new Error("x1 required");t=e.x1}this._x1=t;let s=null;if(null!=e.height)s=this._y0+e.height;else{if(null==e.y1)throw new Error("y1 required");s=e.y1}this._y1=s}get x0(){return this._x0}get x1(){return this._x1}get y0(){return this._y0}get y1(){return this._y1}get width(){return this._x1-this._x0}get height(){return this._y1-this._y0}get center(){return[.5*(this.x0+this.x1),.5*(this.y0+this.y1)]}}};const Ee=ve;var be=class{constructor(){this.transform=new Ee.Transform2d}domToWorldSpace(e){if(!Array.isArray(e))throw new Error("array expected, found "+typeof e);if(2!=e.length)throw new Error(`array with 2 elements expected, found ${e.length}`);return this.transform.inv().apply(e)}inferScale(){return this.transform.inferScale()}center(e={}){let t=e.viewportWidth,s=e.viewportHeight;const r=e.renderer;if((null==t||null==s)&&null==r)throw new Error("renderer required");if(null!=r&&(t=r.width,s=r.height),null==t)throw new Error("viewportWidth required");if(null==s)throw new Error("viewportHeight required");let i,n=e.zoom??1;if(null!=e.worldWidth&&(n=t/e.worldWidth),this.transform.linear=new Ee.Matrix2x2(n,0,0,-n),null!=e.worldCenter){const r=e.worldCenter;i=[.5*t-r[0]*n,.5*s+r[1]*n]}else i=[.5*t,.5*s];this.transform.translation=i}};var Se=class{constructor(){}renderPoint(e={}){const t=e.ctx,s=e.p;t.beginPath(),t.arc(s[0],s[1],3,0,2*Math.PI),t.fill()}};var Ve=class{constructor(){}renderLine(e={}){const t=e.ctx,s=e.a,r=e.b;t.beginPath(),t.strokeStyle="red",t.lineWidth=5,t.moveTo(s[0],s[1]),t.lineTo(r[0],r[1]),t.closePath(),t.stroke()}};var Ie=class{constructor(){}renderTriangle(e={}){const t=e.ctx,s=e.a,r=e.b,i=e.c;t.save(),t.beginPath(),t.strokeStyle="black",t.moveTo(s[0],s[1]),t.lineTo(r[0],r[1]),t.lineTo(i[0],i[1]),t.closePath(),t.stroke(),t.restore()}},Ce={PointShader:Se,LineShader:Ve,TriangleShader:Ie};const Ae=ve,Me=Ce;var Te=class{constructor(e={}){this.scene=e.scene,this.id=e.id,this.x=[],this.triangles=[],this.lines=[],this.pointShader=new Me.PointShader({}),this.lineShader=new Me.LineShader({}),this.triangleShader=new Me.TriangleShader({}),this.customAttributes={}}get pos(){return this.x}set pos(e){this.x=e}numVertices(){return this.pos.length}numTriangles(){return this.triangles.length}numLines(){return this.lines.length}setCustomAttribute(e,t){this.customAttributes[e]=t}getCustomAttribute(e){return this.customAttributes[e]}computeAABB(){let e=null,t=null,s=null,r=null;return this.pos.forEach((i=>{const n=i[0],o=i[1];(null==e||n<e)&&(e=n),(null==t||n>t)&&(t=n),(null==s||o<s)&&(s=o),(null==r||o>r)&&(r=o)})),new Ae.AABB({x0:e,y0:s,x1:t,y1:r})}computeCenter(){const e=this.pos.length;if(0==e)throw new Error("no vertices to compute center");let t=[0,0];for(let s=0;s<e;s++){const e=this.pos[s];Ae.Vec2.add_(t,e)}return Ae.Vec2.mulScalar_(t,1/e),t}};const _e=Te;var ke=class{constructor(e={}){const t=e.headless??!1;if(this.headless=t,!t){const e=document.createElement("canvas");this.domElement=e,this.ctx=e.getContext("2d")}this.setSize({width:200,height:200})}setSize(e){const t=e.width;if(null==t)throw new Error("width required to setSize");const s=e.height;if(null==s)throw new Error("height required to setSize");let r=e.viewportWidth;null==r&&(r=t);let i=e.viewportHeight;if(null==i&&(i=s),this.width=t,this.height=s,this.viewportWidth=r,this.viewportHeight=i,!this.headless){const e=this.domElement;e.width=r,e.height=i,e.style.width=`${t}px`,e.style.height=`${s}px`}}renderPoint(e,t,s,r,i){const n=this.ctx;let o;if(!(t instanceof _e))throw new Error("invalid mesh");o=t.pos[r];const l=s.transform.apply(o);n.save(),t.pointShader.renderPoint({ctx:n,renderer:e,mesh:t,camera:s,id:r,p:l,custom:i}),n.restore()}renderLine(e,t,s,r,i){const n=this.ctx,o=t.lines[r],l=s.transform.apply(t.pos[o[0]]),h=s.transform.apply(t.pos[o[1]]);n.save(),t.lineShader.renderLine({ctx:n,renderer:e,mesh:t,camera:s,id:r,a:l,b:h,custom:i}),n.restore()}renderTriangle(e,t,s,r,i){const n=this.ctx,o=t.triangles[r],l=o[0],h=o[1],a=o[2];let c,d,u;if(t.pos instanceof Float32Array){const e=2;c=[t.pos[l*e],t.pos[l*e+1]],d=[t.pos[h*e],t.pos[h*e+1]],u=[t.pos[a*e],t.pos[a*e+1]]}else c=t.pos[l],d=t.pos[h],u=t.pos[a];const m=s.transform.apply(c),p=s.transform.apply(d),f=s.transform.apply(u);n.save(),t.triangleShader.renderTriangle({ctx:n,renderer:e,mesh:t,camera:s,id:r,a:m,b:p,c:f,custom:i}),n.restore()}renderMesh(e,t,s,r={}){const i=t.sortedElements;if(null==i){for(let i=0;i<t.triangles.length;i++)this.renderTriangle(e,t,s,i,r);for(let i=0;i<t.lines.length;i++)this.renderLine(e,t,s,i,r);for(let i=0;i<t.pos.length;i++)this.renderPoint(e,t,s,i,r)}else i.forEach((i=>{if(null==i.order)throw new Error(`invalid element, order not defined ${i}`);if(1==i.order)this.renderPoint(e,t,s,i.id,r);else if(2==i.order)this.renderLine(e,t,s,i.id,r);else{if(3!=i.order)throw new Error(`invalid element ${i}`);this.renderTriangle(e,t,s,i.id,r)}}))}render(e,t,s={}){this.ctx.clearRect(0,0,this.viewportWidth,this.viewportHeight),e.meshes.forEach((e=>{this.renderMesh(this,e,t,s)}))}};const ze=Te;var Le={Camera:be,Mesh:Te,Renderer:ke,Scene:class{constructor(){this.meshes=new Map}clean(){this.meshes=new Map}numMeshes(){return this.meshes.size}addMesh(){const e=this.meshes.size,t=new ze({scene:this,id:e});return this.meshes.set(e,t),t}}};var De={computeDomCursor:function(e,t){let s,r;if(null==e.touches)s=e.clientX,r=e.clientY;else{if(0==e.touches.length)return null;const t=e.touches[0];s=t.clientX,r=t.clientY}let i=new DOMMatrix,n=t;for(;null!=n;){const e=window.getComputedStyle(n);i=new DOMMatrix(e.transform).multiply(i),n=n.parentElement}const o=i.inverse(),l=new DOMPointReadOnly(s,r).matrixTransform(o),h=t.getBoundingClientRect(),a=new DOMPointReadOnly(h.left,h.top).matrixTransform(o);return[l.x-a.x,l.y-a.y]}};const $e=De;var Pe={cursorUtils:De,DragBehavior:class{constructor(e={}){this._dragging=!1,this.onDomCursorDown=e.onDomCursorDown,this.onDragProgress=e.onDragProgress,this.onDomCursorUp=e.onDomCursorUp,this.domElement=null}beginDrag(){this._dragging=!0}endDrag(){this._dragging=!1}dragging(){return this._dragging}domCursorDown(e,t){null!=this.onDomCursorDown&&this.onDomCursorDown(e,t)}domCursorMove(e,t){this.dragging()&&(t.preventDefault(),null!=this.onDragProgress&&this.onDragProgress(e,t))}domCursorUp(e,t){this.endDrag(),null!=this.onDomCursorUp&&this.onDomCursorUp(e,t)}linkToDom(e,t=null){if(null!=this.domElement)throw new Error("already linked to DOM");this.domElement=e;const s=t=>{const s=$e.computeDomCursor(t,e);this.domCursorDown(s,t)};e.addEventListener("mousedown",s,{passive:!1}),e.addEventListener("touchstart",s,{passive:!1});const r=t=>{const s=$e.computeDomCursor(t,e);this.domCursorMove(s,t)};null==t&&(t=e),t.addEventListener("mousemove",r,{passive:!1}),t.addEventListener("touchmove",r,{passive:!1});const i=t=>{const s=$e.computeDomCursor(t,e);this.domCursorUp(s,t)};window.addEventListener("mouseup",i),window.addEventListener("touchend",i),window.addEventListener("touchcancel",i)}}};class qe{constructor(e={}){if(null==e.scene)throw new Error("scene required");const t=null==e.color?"rgba(0, 0, 0, 0.30)":e.color,s=this.mesh=e.scene.addMesh();this.set(e),s.setCustomAttribute("translation",[0,0]),s.pointShader.renderPoint=()=>{},s.lineShader.renderLine=qe.makeGridLineShader({color:t})}get numVertices(){return this.mesh.x.length}get numLines(){return this.mesh.lines.length}set(e={}){const t=null==e.cellSize?1:e.cellSize,s=null==e.innerCells?3:e.innerCells,r=null==e.rows?3:e.rows,i=null==e.cols?4:e.cols,n=null==e.x0?-2:e.x0,o=null==e.y0?0:e.y0,l=null==e.primaryLineWidth?.03:e.primaryLineWidth,h=null==e.secondaryLineWidth?.008:e.secondaryLineWidth,a=this.mesh,{x:c,lineIndices:d,lineWidths:u}=function(e={}){const t=null==e.cellSize?1:e.cellSize,s=null==e.innerCells?3:e.innerCells,r=null==e.rows?3:e.rows,i=null==e.cols?4:e.cols,n=null==e.x0?-2:e.x0,o=null==e.y0?0:e.y0,l=null==e.primaryLineWidth?.022:e.primaryLineWidth,h=null==e.secondaryLineWidth?.008:e.secondaryLineWidth,a=[],c=[],d=[],u=o+r*t,m=n+i*t;function p(e,t){for(let r=0;r<e+1;r++){const i=r==e?1:s;for(let e=0;e<i;e++){const s=2*c.length;t(r,e,i,a),c.push([s,s+1]),0==e?d.push(l):d.push(h)}}}return p(r,((e,s,r,i)=>{const l=s/r,h=(o+e*t)*(1-l)+(o+(e+1)*t)*l;i.push([n,h]),i.push([m,h])})),p(i,((e,s,r,i)=>{const l=s/r,h=(n+e*t)*(1-l)+(n+(e+1)*t)*l;i.push([h,o]),i.push([h,u])})),{x:a,lineIndices:c,lineWidths:d}}({cellSize:t,innerCells:s,rows:r,cols:i,x0:n,y0:o,primaryLineWidth:l,secondaryLineWidth:h});a.pos=c,a.lines=d,a.setCustomAttribute("lineWidths",u)}static makeGridLineShader(e={}){const t=null==e.color?"black":e.color;return e=>{const s=e.ctx,r=e.a,i=e.b,n=e.camera,o=e.mesh,l=n.inferScale();s.beginPath(),s.strokeStyle=t;const h=o.getCustomAttribute("lineWidths");if(null==h)throw new Error("custom attribute lineWidths missing");const a=h[e.id],c=o.getCustomAttribute("translation"),d=[l*c[0],l*c[1]];s.lineWidth=a*l,s.moveTo(r[0]+d[0],r[1]+d[1]),s.lineTo(i[0]+d[0],i[1]+d[1]),s.closePath(),s.stroke()}}}var We=qe;var Fe={Grid:We,Background:class{constructor(e={}){if(null==e.scene)throw new Error("scene required");const t=this.mesh=e.scene.addMesh();t.pos=[[0,0]];const s=null==e.color1?"#fcfcfc":e.color1,r=null==e.color2?"#d7d8d8":e.color2;t.pointShader.renderPoint=(e={})=>{const t=e.renderer.width,i=e.renderer.height,n=e.ctx,o=n.createRadialGradient(.5*t,.5*i,.05*t,.5*t,.5*i,.5*t);o.addColorStop(0,s),o.addColorStop(1,r),n.fillStyle=o,n.fillRect(0,0,t,i)}}}};var Be=class{constructor(e,t){if(null==e)throw new Error("id required to create simplex");this.order=t.length,this.id=e,this.vertexIds=t}};const Re=Be;function Oe(e){return e.sort(),e.join("_")}var je=class{constructor(e={}){if(null==e.order)throw new Error("order required");this.order=e.order,this.simplicesByHash=new Map}forEach(e){this.simplicesByHash.forEach(e)}size(){return this.simplicesByHash.size}has(e){return this.simplicesByHash.has(Oe(e.vertexIds))}add(e,t){let s=null;if(Array.isArray(e)){if(null==t)throw new Error("id required");s=e,e=new Re(t,s)}else{if(s=e.vertexIds,null==s)throw new Error(`vertexIds required ${e}`);t=e.id}if(s.length!=this.order)throw new Error(`expected ${this.order} vertices, found ${s.length}`);const r=Oe(s);return this.simplicesByHash.set(r,e),e}};const Ne=je;const He=je,Ue=class{constructor(e){this.id=e,this.edges=new Ne({order:2}),this.triangles=new Ne({order:3})}addTriangle(e,t){this.triangles.add(e,t)}addEdge(e,t){this.edges.add(e,t)}};var Xe=class{constructor(e={}){this.vertices=new Map,this.edges=new He({order:2}),this.triangles=new He({order:3});(e.edges??[]).forEach(((e,t)=>{this.addEdge(t,e)}));(e.triangles??[]).forEach(((e,t)=>{this.addTriangle(t,e)}))}numVertices(){return this.vertices.size}numEdges(){return this.edges.size()}numTriangles(){return this.triangles.size()}getVertexById(e,t=!1){let s=this.vertices.get(e);return null==s&&t&&(s=new Ue(e),this.vertices.set(e,s)),s}addEdge(e,t){const s=this.edges.add(t,e);return t.forEach((e=>{this.getVertexById(e,!0).addEdge(s)})),s}addTriangle(e,t){const s=this.triangles.add(t,e);return t.forEach((e=>{this.getVertexById(e,!0).addTriangle(s)})),s}};const Ge=Xe,Ye=je;var Ze={makeSortedElements:function(e={}){if(null==e.sortedVertexIds)throw new Error("sortedVertexIds required");if(null==e.triangles)throw new Error("triangles required");if(null==e.edges)throw new Error("edges required");const t=e.sortedVertexIds,s=new Map;t.forEach(((e,t)=>{s.set(e,t)}));const r=new Ge({triangles:e.triangles}),i=new Ge({edges:e.edges}),n=[],o=new Ye({order:3}),l=new Ye({order:2});return t.forEach((e=>{const t=r.getVertexById(e,!0).triangles,h=i.getVertexById(e,!0).edges,a=[];t.forEach((e=>{a.push(e)})),h.forEach((e=>{a.push(e)})),a.sort(((e,t)=>{const r=e.vertexIds.map((e=>s.get(e))),i=t.vertexIds.map((e=>s.get(e))),n=Math.max(...r),o=Math.max(...i);return n<o?1:n==o?0:-1})),a.forEach((e=>{if(2==e.order){const t=e;l.has(t)||(n.push(t),l.add(t))}else{const t=e;o.has(t)||(n.push(t),o.add(t))}})),n.push({order:1,id:e})})),n},MeshTopology:Xe,Simplex:Be,Simplices:je};var Je={math:ve,ui:Pe,shaders:Ce,background:Fe,sorted:Ze,core:Le,Renderer:Le.Renderer,Camera:Le.Camera,Scene:Le.Scene};var Ke=class{constructor(e={}){this.targetCenterX=null,this.currentCenterX=null,this.active=!0,this.visibleWorldWidth=e.visibleWorldWidth??3.8,this.targetCenterY=e.targetCenterY??1,this.offsetX=e.offsetX??0,this.fullGrid=!1,this.centeringSpeedFactor=.5}step(e={}){if(!this.active)return;const t=e.renderer,s=e.camera,r=e.mesh,i=e.floor,n=e.grid;let o=[0,0];r.pos.length>0&&(o=r.computeCenter());const l=o[0]+this.offsetX;isNaN(l)||(this.targetCenterX=l),null==this.currentCenterX?this.currentCenterX=this.targetCenterX:this.currentCenterX+=(this.targetCenterX-this.currentCenterX)*this.centeringSpeedFactor;const h=[this.currentCenterX,this.targetCenterY];s.center({worldCenter:h,worldWidth:this.visibleWorldWidth,viewportWidth:t.width,viewportHeight:t.height});const a=s.domToWorldSpace([t.width,0]),c=s.domToWorldSpace([0,t.height]),[d,u]=c,m=Math.floor(d)-1;let p=Math.floor(u);this.fullGrid||p<0&&(p=0);const[f,g]=a,w=f,y=w-m,x=g-p,v=Math.ceil(x)+1,E=Math.ceil(y)+1;n.set({x0:m,y0:p,rows:v,cols:E,innerCells:n.innerCells,primaryLineWidth:n.primaryLineWidth,secondaryLineWidth:n.secondaryLineWidth}),i.mesh.pos=[[m,0],[w,0]]}};class Qe{constructor(e={}){if(null==e.scene)throw new Error("scene required");const t=this.scene=e.scene,s=this.mesh=t.addMesh();s.pos=[[-10,0],[10,0]],s.lines=[[0,1]],s.lineShader.renderLine=Qe.makeFloorLineShaderFunction({width:e.width,color:e.color}),s.pointShader.renderPoint=()=>{},s.setCustomAttribute("translation",[0,0])}static makeFloorLineShaderFunction(e={}){const t=e.width??.055,s=e.color??"black";return e=>{const r=e.ctx,i=e.a,n=e.b,o=e.camera,l=e.mesh,h=o.inferScale(),a=l.getCustomAttribute("translation"),c=[h*a[0],h*a[1]];r.strokeStyle=s,r.lineWidth=h*t,r.beginPath(),r.moveTo(i[0]+c[0],i[1]+c[1]),r.lineTo(n[0]+c[0],n[1]+c[1]),r.stroke()}}}var et=Qe;const tt=Je;var st=class{constructor(e={}){this.system=e.system,this.renderVertexIds=e.renderVertexIds??!1,this.radius=e.radius??.028,this.borderColor=e.borderColor??"black",this.fillColor=e.fillColor??"white",this.borderWidth=e.borderWidth??.023}renderVertex(e={}){const t=this.radius,s=this.borderColor,r=this.fillColor,i=this.borderWidth,n=e.ctx,o=e.p,l=e.camera.inferScale();if(function(e,t,s,r,i,n,o){const l=(r+.5*i)*t;e.fillStyle=o,e.beginPath(),e.arc(s[0],s[1],l,0,2*Math.PI),e.fill(),e.lineWidth=i*t,e.strokeStyle=n,e.stroke()}(n,l,o,t,i,s,r),this.renderVertexIds){n.beginPath(),n.fillStyle="rgba(255, 255, 255, 0.8)",n.arc(o[0],o[1],.1*l,0,2*Math.PI),n.fill();const t=Math.floor(.15*l);n.font=`${t}px monospace`,n.fillStyle="black",n.textAlign="center",n.textBaseline="middle",n.fillText(e.id,o[0],o[1])}}getVertexPos(e){const t=this.system.pos.slot.f32(),s=e*this.system.spaceDim;return[t[s],t[s+1]]}get numVertices(){return this.system.numVertices}hitTest(e,t=.31){const s=this.numVertices;if(0==s)return null;let r=null,i=1/0;const n=t*t;for(let t=0;t<s;t++){const s=this.getVertexPos(t),o=tt.math.Vec2.sub(s,e),l=tt.math.Vec2.quadrance(o);l<n&&l<i&&(r=t,i=l)}return r}setVertexPos(e,t){if(null==e)throw new Error("vertex id required");const s=this.system.pos.slot.f32(),r=2*e;s[r]=t[0],s[r+1]=t[1]}setVertexVel(e,t){const s=this.system.vel.slot.f32(),r=2*e;s[r]=t[0],s[r+1]=t[1]}};var rt=class{constructor(e={}){this.system=e.system}makeEdgesFromTriangles(e){const t=new Map;function s(e,s){const r=((i=[e,s]).sort(),i.join("_"));var i;t.set(r,[e,s])}return e.forEach((e=>{s(e[0],e[1]),s(e[1],e[2]),s(e[0],e[2])})),Array.from(t.values())}makeLineShaderFunction(e={}){const t=e.activeMuscleColor??[255,0,0],s=e.inactiveMuscleColor??[0,0,255],r=e.borderColor??"black";return(e={})=>{const i=e.ctx,n=e.a,o=e.b,l=e.camera.inferScale(),h=e.mesh.getCustomAttribute("lineIdToMuscleId");let a=null;if(null!=h&&(a=h[e.id]),null==a){!function(e,t,s,r,i,n){e.beginPath(),e.lineJoin="round",e.lineCap="round",e.strokeStyle=n,e.lineWidth=i*t,e.moveTo(s[0],s[1]),e.lineTo(r[0],r[1]),e.closePath(),e.stroke()}(i,l,n,o,.029,r)}else{const h=t,c=s,d=.065,u=.017,m="muscleIntensity",p=e.mesh.getCustomAttribute(m);if(null==p)throw new Error(`muscle intensity attribute (${m}) not found, call setCustomAttribute("${m}", value) before rendering.`);if(!Array.isArray(p))throw new Error("muscle intensity attribute must be an array with values for each fiber, found "+typeof p);!function(e,t,s,r,i,n,o,l,h,a){e.beginPath(),e.lineCap="butt",e.strokeStyle=l,e.lineWidth=(n+2*o)*t,e.moveTo(s[0],s[1]),e.lineTo(r[0],r[1]),e.stroke(),e.beginPath();const c=(1-i)*h[0]+i*a[0],d=(1-i)*h[1]+i*a[1],u=(1-i)*h[2]+i*a[2];e.strokeStyle=`rgb(${c}, ${d}, ${u})`,e.lineWidth=n*t,e.moveTo(s[0],s[1]),e.lineTo(r[0],r[1]),e.stroke()}(i,l,n,o,p[a],d,u,r,h,c)}}}};var it=class{constructor(e={}){this.fillColor=e.fillColor??"white"}renderTriangle(e={}){const t=e.ctx,s=e.a,r=e.b,i=e.c;t.beginPath(),t.fillStyle=this.fillColor,t.moveTo(...s),t.lineTo(...r),t.lineTo(...i),t.closePath(),t.fill()}};const nt=Je,ot=Ke,lt=et,ht=st,at=rt,ct=it;function dt(e){return e.sort(),e.join("_")}function ut(e){if(7!=e.length)throw new Error(`invalid hex string ${e}`);if("#"!=e[0])throw new Error(`invalid hex string ${e}, expected #, found ${e[0]}`);e=e.substring(1);return[parseInt(e.substring(0,2),16),parseInt(e.substring(2,4),16),parseInt(e.substring(4,6),16)]}var mt=class{constructor(e={}){if(null==e.system)throw new Error("system required");this.system=e.system;const t=e.sortedVertexIds;this.sortedVertexIds=t,null!=e.vertexDepths&&this.setSortedVertexIdsFromVertexDepths(e.vertexDepths);const s=e.headless??!1,r=e.borderColor??"black",i=r,n=e.fillColor??"white",o=e.gridColor??"#acadad";this.vertices=new ht({system:this.system,renderVertexIds:e.renderVertexIds??!1,borderColor:r,fillColor:n}),this.lines=new at({system:this.system});const l=new nt.Renderer({headless:s});this.renderer=l,this.domElement=l.domElement,this.setSize({width:e.width??400,height:e.height??400});const h=new nt.Scene;this.scene=h;const a=new nt.Camera;this.camera=a;let c,d,u=e.activeMuscleColor??[255,0,0],m=e.inactiveMuscleColor??[250,190,190];"string"==typeof u&&(u=ut(u)),"string"==typeof m&&(m=ut(m)),null!=e.backgroundColor?(c=e.backgroundColor,d=e.backgroundColor):(c=e.backgroundCenterColor??"#fcfcfc",d=e.backgroundOuterColor??"#d7d8d8"),new nt.background.Background({scene:h,color1:c,color2:d});const p=this.grid=new nt.background.Grid({scene:h,x0:-3,y0:0,rows:4,cols:10,innerCells:2,primaryLineWidth:.022,secondaryLineWidth:.005,color:o});p.innerCells=2,p.primaryLineWidth=.022,p.secondaryLineWidth=.005,this.floor=new lt({scene:h,color:i});const f=h.addMesh();this.mesh=f,f.pointShader.renderPoint=e=>{this.vertices.renderVertex(e)},this.triangleRenderer=new ct({fillColor:n}),f.triangleShader.renderTriangle=(e={})=>{this.triangleRenderer.renderTriangle(e)},f.lineShader.renderLine=this.lines.makeLineShaderFunction({activeMuscleColor:u,inactiveMuscleColor:m,borderColor:r});if(e.draggable??!0){const t=this.dragBehavior=new nt.ui.DragBehavior({onDomCursorDown:(e,s)=>{if("button"in s&&0!=s.button)return;const r=this.system,i=a.domToWorldSpace(e),n=this.hitTestVertex(i);null!=n&&(s.preventDefault(),this.fixVertex(n),t.beginDrag(),this.setVertexPos(r.vertices.fixedVertexId,[i[0],Math.max(0,i[1])]))},onDragProgress:e=>{const t=this.system,s=a.domToWorldSpace(e);this.setVertexPos(t.vertices.fixedVertexId,[s[0],Math.max(0,s[1])])},onDomCursorUp:()=>{this.freeVertex()}});if(!s){const s=e.domElementForMoveEvents??null;t.linkToDom(l.domElement,s)}}this.tracker=new ot}setSortedVertexIdsFromVertexDepths(e){if(e.length!=this.system.numVertices)throw new Error(`invalid size for depths, found ${e.length}, expected ${this.system.numVertices}`);const t=e.map(((e,t)=>({depth:e,index:t})));t.sort(((e,t)=>t.depth-e.depth));const s=t.map((e=>e.index));this.sortedVertexIds=s}setSize(e={}){this.renderer.setSize({width:e.width,height:e.height})}render(){(null==this.needsMeshUpdate||this.needsMeshUpdate)&&(this._updateMesh({triangles:this.system.getTrianglesArray(),muscles:this.system.getMusclesArray()}),this.needsMeshUpdate=!1);const e=this.renderer,t=this.scene,s=this.camera,r=this.mesh;this._updateFromSystem(),null!=this.dragBehavior&&this.dragBehavior.dragging()||this.tracker.step({mesh:r,camera:s,floor:this.floor,grid:this.grid,renderer:this.renderer}),e.render(t,s)}_updateMesh(e){const t=this.mesh,s=this.system.numVertices;if(!Number.isInteger(s)||s<0)throw new Error(`invalid number of vertices ${s}`);null!=e.pos&&(t.pos=e.pos),t.triangles=e.triangles;const r=this.lines;t.lines=r.makeEdgesFromTriangles(e.triangles),Array.prototype.push.apply(t.lines,e.muscles);const i=new Map;e.muscles.forEach(((e,t)=>{i.set(dt(e),t)}));const n=[];t.setCustomAttribute("lineIdToMuscleId",n),t.lines.forEach((e=>{const t=dt(e),s=i.get(t);n.push(s)}));let o=this.sortedVertexIds;if(null==o){o=[];for(let e=0;e<s;e++)o.push(e)}if(o.length!=s)throw new Error(`invalid size for sortedVertexIds, found ${o.length}, expected ${s}`);t.sortedElements=nt.sorted.makeSortedElements({sortedVertexIds:o,triangles:t.triangles,edges:t.lines});const l=[],h=this.system.numMuscles;for(let e=0;e<h;e++)l.push(1);t.setCustomAttribute("muscleIntensity",l)}_updateFromSystem(){this._updateVertexPositionsFromSystem(),this._updateMuscleIntensityFromSystem()}_updateVertexPositionsFromSystem(){const e=this.mesh,t=this.system;if(0==t.numVertices)e.pos=[];else{const s=t.pos.toArray();e.pos=s}}_updateMuscleIntensityFromSystem(){const e=this.mesh,t=this.system,s=t.numMuscles;if(!Number.isInteger(s)||s<0)throw new Error(`invalid number of muscles ${s}`);let r=[];if(s>0)if(t.a){const e=t.a.slot.f32();for(let t=0;t<s;t++)r.push(e[t])}else r=new Array(s).fill(1);e.setCustomAttribute("muscleIntensity",r)}hitTestVertex(e,t=.31){return this.vertices.hitTest(e,t)}setVertexPos(e,t){this.vertices.setVertexPos(e,t)}setVertexVel(e,t){this.vertices.setVertexVel(e,t)}fixVertex(e){const t=this.system;this.setVertexVel(e,[0,0]),null==e&&(e=-1),t.vertices.fixVertex(e)}freeVertex(){this.system.vertices.freeVertex()}},pt={SystemViewport:mt,VertexRenderer:st,LineRenderer:rt,TriangleRenderer:it,Tracker:Ke};function ft(e,t){const s=1-Math.random(),r=Math.random();return e+Math.sqrt(-2*Math.log(s))*Math.cos(2*Math.PI*r)*t}var gt=class{constructor(e={}){if(null==e.system)throw new Error("system required to create policy");this.system=e.system,this.ten=this.system.ten,this.active=e.active??!1,this.stochastic=e.stochastic??!1,this.stdDev=e.stdDev??.05;const t=this.system,s=this.ten,r=this.numVertices=e.numVertices??t.numVertices,i=this.numMuscles=e.numMuscles??t.numMuscles,n=t.spaceDim;this.vertexIdOffset=e.vertexIdOffset??0,this.muscleIdOffset=e.muscleIdOffset??0,this.projectedPos=s.zeros([r,n]),this.projectedVel=s.zeros([r,n]);const o=r*n*2,l=i;this.input=s.zeros([o]),this.clockwise=!1;const h=s.nn;this.model=h.Sequential(h.Linear(o,32),h.ReLU(),h.Linear(32,l),h.Tanh())}get spaceDim(){return this.system.spaceDim}step(e={}){const t=this.system,s=this.ten.wasmInstance,r=this.vertexIdOffset*this.spaceDim*4;s.exports.make_neural_policy_input(this.numVertices,t.pos.ptr+r,t.vel.ptr+r,this.centerVertexId,this.forwardVertexId,this.projectedPos.ptr,this.projectedVel.ptr,this.input.ptr,this.clockwise);const i=this.model.forward(this.input),n=this.minA,o=this.maxAbsDa,l=this.system.a,h=i.slot.f32(),a=this.numMuscles;for(let e=0;e<a;e++){let t;this.active?(t=i.get([e]),this.stochastic&&(t+=ft(0,this.stdDev))):t=1,h[e]=t}const c=e.trace;null!=c&&(c.policyInput=this.input.toArray(),c.policyOutput=i.toArray()),i.clamp_({min:-o,max:o});const d=l.slot.f32();for(let e=0;e<a;e++)d[this.muscleIdOffset+e]+=h[e];l.clamp_({min:n,max:1})}loadData(e){const t=this.model.layers[0];t.weight.set(e.fc1.weight),t.bias.set(e.fc1.bias);const s=this.model.layers[2];s.weight.set(e.fc2.weight),s.bias.set(e.fc2.bias),this.minA=e.min_a??(()=>{throw new Error("min_a required")})(),this.maxAbsDa=e.max_abs_da??(()=>{throw new Error("max_abs_da required")})(),this.centerVertexId=e.center_vertex_id??(()=>{throw new Error("center_vertex_id required")})(),this.forwardVertexId=e.forward_vertex_id??(()=>{throw new Error("forward_vertex_id required")})()}dispose(){null!=this.projectedPos&&this.projectedPos.dispose(),null!=this.projectedVel&&this.projectedVel.dispose(),null!=this.input&&this.input.dispose(),this.model.dispose()}};var wt=e({System:le,Vertices:ee,mmgrten:Q,SystemViewport:pt.SystemViewport,mm2d:Je,render:pt,nn:{NeuralFramePolicy:gt}});class yt{constructor(e={}){const t=this.domElement=document.createElement("div");t.style.userSelect="none",t.style.webkitTapHighlightColor="transparent",t.style.padding="12px",t.style.boxSizing="content-box",t.style.cursor="pointer",t.style.borderRadius="50%",t.style.minHeight=t.style.height,t.style.margin="4px",t.style.display="flex",t.style.alignItems="center",t.style.justifyContent="center",t.style.boxShadow="0 0 8px rgba(0, 0, 0, 0.2)",t.style.padding="20px",t.style.overflow="hidden",this.initSvg(),this.setSize(40),this.setInactiveStyle()}setSize(e){const t=this.domElement;t.style.width=`${e}px`,t.style.height=`${e}px`,t.style.minHeight=`${e}px`}initSvg(){const e="white",t=document.createElementNS("http://www.w3.org/2000/svg","svg");this.svg=t,t.style.width="100%",t.setAttribute("width","198"),t.setAttribute("height","217"),t.setAttribute("viewBox","0 0 198 217"),t.setAttribute("fill","none");const s=document.createElementNS("http://www.w3.org/2000/svg","path");s.setAttribute("fill-rule","evenodd"),s.setAttribute("clip-rule","evenodd"),s.setAttribute("d","M156.5 186.309L173 178.837V161.992L152.888 150.729L130.5 162.127V194.062H120.5V155.996L148 141.996V121.915L173 109.915V86.0615H183V116.208L158 128.208V142.131L177.975 153.317L197.5 142.16V76.5834L179.133 63.0079L157 75.4829L156.5 102H146.5L147 75.4371L119.5 59.4371V22.5615H129.5V53.6859L152.039 66.7998L174.42 54.185L174.077 41.482L156.5 31.2553V48.5615H146.5V13.2817L125.974 0L105 13.3103V128.519L121 117.442V89.0615H131V122.681L105 140.681V204.221L125.975 216.725L146.5 204.249V169.562H156.5V186.309Z"),s.setAttribute("fill",e),t.appendChild(s);const r=document.createElementNS("http://www.w3.org/2000/svg","path");r.setAttribute("fill-rule","evenodd"),r.setAttribute("clip-rule","evenodd"),r.setAttribute("d","M41 30.4169L24.5 37.8885V54.7333L44.6122 65.9962L67 54.5988V22.664H77V60.7291L49.5 74.7291V94.8101L24.5 106.81V130.664H14.5V100.518L39.5 88.5178V74.5946L19.5249 63.4085L0 74.5656V140.142L18.3669 153.718L40.5 141.243L41 114.725H51L50.5 141.288L78 157.288V194.164H68V163.04L45.4606 149.926L23.0796 162.54L23.4229 175.243L41 185.47V168.164H51V203.444L71.5262 216.725L92.5 203.415V88.2068L76.5 99.2837V127.664H66.5V94.0442L92.5 76.0442V12.5043L71.525 -3.05176e-05L51 12.476V47.164H41V30.4169Z"),r.setAttribute("fill",e),t.appendChild(r),this.domElement.appendChild(t)}setActiveStyle(e=!0){e?this.domElement.style.backgroundColor="black":this.setInactiveStyle()}setInactiveStyle(){this.domElement.style.backgroundColor="rgba(1, 1, 1, 0.2)"}}class xt{constructor(e,t){this.list=e,this.data=t,this.next=null,this.prev=null}append(e){const t=new xt(this.list,e);return this.list.last==this&&(this.list.last=t),t.next=this.next,t.prev=this,null!=this.next&&(this.next.prev=t),this.next=t,this.list.size++,t}prepend(e){const t=new xt(this.list,e);return this.list.first==this&&(this.list.first=t),t.next=this,t.prev=this.prev,null!=this.prev&&(this.prev.next=t),this.prev=t,this.list.size++,t}remove(){null!=this.prev&&(this.prev.next=this.next),null!=this.next&&(this.next.prev=this.prev),this.list.first==this&&(this.list.first=this.next),this.list.last==this&&(this.list.last=this.prev),this.list.size--,this.next=null,this.prev=null}}var vt=xt;const Et=vt;class bt{constructor(e){this.list=e,this.nextNode=this.list.first}next(){if(null==this.nextNode)return{done:!0};{const e={done:!1,value:this.nextNode.data};return this.nextNode=this.nextNode.next,e}}}class St{constructor(){this.first=null,this.last=null,this.size=0}isEmpty(){if(null==this.first&&null!=this.last||null!=this.first&&null==this.last)throw Error("inconsistent first last state");return null==this.first}append(e){return this.isEmpty()?this.setSingleton(e):this.last.append(e)}prepend(e){return this.isEmpty()?this.setSingleton(e):this.first.prepend(e)}setSingleton(e){const t=new Et(this,e);return this.first=t,this.last=t,this.size=1,t}iter(){return new bt(this)}*[Symbol.iterator](){const e=this.iter();let t=e.next();for(;!t.done;)yield t.value,t=e.next()}}var Vt,It,Ct,At,Mt,Tt,_t={List:St,Node:vt};function kt(){if(It)return Vt;It=1;const e=zt();return Vt=class extends e{constructor(e={}){super(e)}isFree(){return!1}free(){let e=this.appendFree(this.ptr,this.size);this.remove();const t=e.prev(),s=e.next();return null!=t&&t.isFree()&&(e=t.merge(e)),null!=s&&s.isFree()&&(e=e.merge(s)),e}}}function zt(){return At||(At=1,Ct=class{constructor(e={}){this.manager=e.manager,this.ptr=e.ptr,this.size=e.size,this.node=e.node}numBytes(){return this.size}prev(){const e=this.node.prev;return null!=e?e.data:null}next(){const e=this.node.next;return null!=e?e.data:null}appendReserved(e,t){const s=kt(),r=this.node.append(null),i=new s({manager:this.manager,ptr:e,size:t,node:r});return r.data=i,this.manager._addReservedSlot(i),i}appendFree(e,t){const s=Lt(),r=this.node.append(null),i=new s({manager:this.manager,ptr:e,size:t,node:r});return r.data=i,this.manager._addFreeSlot(i),i}remove(){this.node.remove(),this.node.data=null,this.node=null,this.isFree()?this.manager._removeFreeSlot(this):this.manager._removeReservedSlot(this)}toTypedArray(e){const t=this.size,s=e.BYTES_PER_ELEMENT;if(t%s!=0)throw new Error(`size in bytes must be a multiple of ${s}, found ${t}`);const r=this.ptr;return new e(this.manager.array,r,t/s)}f32(){return this.toTypedArray(Float32Array)}u32(){return this.toTypedArray(Uint32Array)}}),Ct}function Lt(){if(Tt)return Mt;Tt=1;const e=zt();return Mt=class extends e{constructor(e={}){super(e)}isFree(){return!0}reserve(e){const t=this.numBytes();if(e>t)throw new Error(`cannot reserve ${e} bytes, only ${t} bytes are available`);const s=this.appendReserved(this.ptr,e);return s.appendFree(this.ptr+e,t-e),this.remove(),s}merge(e){if(!this.isFree()||!e.isFree())throw new Error("only free slots can be merged");if(this.next()!=e)throw new Error("only adjacent slots can be merged");const t=e.appendFree(this.ptr,this.size+e.size);return this.remove(),e.remove(),t}}}const Dt=_t,$t=Lt();var Pt={linked:_t,MemoryManager:class{constructor(e,t){this.array=e,null==t&&(t=0),this.ptrToSlot=new Map,this.slots=new Dt.List,this.freeSlots=new Dt.List,this.reservedSlots=new Dt.List;const s=new $t({manager:this,ptr:t,size:e.byteLength-t}),r=this.slots.append();r.data=s,s.node=r;const i=this.freeSlots.append();i.data=s,s.freeNode=i}numReservedSlots(){return this.reservedSlots.size}numFreeSlots(){return this.freeSlots.size}numFreeBytes(){let e=0;const t=this.freeSlots.iter();let s=t.next();for(;!s.done;)e+=s.value.size,s=t.next();return e}numReservedBytes(){let e=0;const t=this.reservedSlots.iter();let s=t.next();for(;!s.done;)e+=s.value.size,s=t.next();return e}mallocBytes(e){return this._malloc(e)}malloc32(e){return this.mallocBytes(4*e)}_addReservedSlot(e){const t=this.reservedSlots.append(e);e.reservedNode=t}_removeReservedSlot(e){if(null==e.reservedNode)throw new Error("reservedNode cannot be null");e.reservedNode.remove()}_addFreeSlot(e){const t=this.freeSlots.append(e);e.freeNode=t}_removeFreeSlot(e){if(null==e.freeNode)throw new Error("freeNode cannot be null");e.freeNode.remove()}_malloc(e){if(!Number.isInteger(e))throw new Error(`expected integer, found ${e}`);let t=null;const s=this.freeSlots.iter();let r=s.next();for(;!r.done;){const i=r.value;if(i.size>=e){t=i;break}r=s.next()}if(null==t)throw new Error("no valid free slot available");return t.reserve(e)}malloc(e){const t=this._malloc(e);return this.ptrToSlot.set(t.ptr,t),t.ptr}free(e){this.ptrToSlot.get(e).free()}},FreeSlot:Lt(),ReservedSlot:kt()};class qt{constructor(e={}){const t=e.engine;if(null==t)throw new Error("engine required to create IntTuple");this.engine=t;const s=e.slot;if(null==s)throw new Error("slot required to create IntTuple");this.slot=s,this.ptr=s.ptr,this.length=e.length}forEach(e){for(let t=0;t<this.length;t++)e(this.get(t),t)}equal(e){if(e instanceof qt){for(let t=0;t<this.length;t++)if(this.get(t)!=e.get(t))return!1;return!0}if(Array.isArray(e)){for(let t=0;t<this.length;t++)if(this.get(t)!=e[t])return!1;return!0}return!1}toString(){return this.slot.u32().toString()}toArray(){const e=[];return this.forEach((t=>{e.push(t)})),e}typedArray(){return this.slot.u32()}set(e,t){this.typedArray()[e]=t}get(e){return this.typedArray()[e]}dispose(){this.slot.free()}}var Wt=qt;function Ft(e,t,s,r){if(t==s.length-1)for(let i=0;i<s[t];i++)e.push(r);else for(let i=0;i<s[t];i++){const i=[];e.push(i),Ft(i,t+1,s,r)}}var Bt={inferShape:function(e){const t=[];let s=e;for(;Array.isArray(s);)t.push(s.length),s=s[0];return t},makeNdArray:function(e,t){let s=e;e instanceof Wt&&(s=e.toArray());const r=[];return Ft(r,0,s,t),r},numelOfShape:function(e){let t=1;return e.forEach((e=>{t*=e})),t},getArrElem:function e(t,s){if(!Array.isArray(s))throw new Error(`expected array, found ${typeof s}: ${s}`);return 0==s.length?t:e(t[s[0]],s.slice(1))},setArrElem:function e(t,s,r){if(!Array.isArray(s))throw new Error(`expected array, found ${typeof s}: ${s}`);if(1!=s.length)return e(t[s[0]],s.slice(1),r);t[s]=r}};const Rt=Wt;class Ot{constructor(e){if(null==e)throw new Error("shape required");if(!(e instanceof Rt))throw new Error(`IntTuple shape expected, found ${typeof e}: shape`);this.shape=e,this.done=!1,this.idx=[],e.forEach((e=>{this.idx.push(0)}))}next(){const e=this.shape;for(let t=0;t<e.length;t++){const s=e.length-1-t;if(this.idx[s]<e.get(s)-1)return void this.idx[s]++;if(0==s)return void(this.done=!0);this.idx[s]=0}}static shapeForEach(e,t){const s=new Ot(e);for(;!s.done;)t(s.idx),s.next()}}const jt=Bt,Nt=Ot,Ht=Wt;class Ut{constructor(e={}){const t=e.engine;if(null==t)throw new Error("engine required to create tensor");this.engine=t;const s=e.shape;if(null==s)throw new Error("shape required to create tensor");if(s instanceof Ht)this.shape=s;else{if(!Array.isArray(s))throw new Error(`invalid shape type ${typeof s}: ${s}`);this.shape=t.intTuple(s)}this.order=this.shape.length;const r=jt.numelOfShape(this.shape);this.numel=r;const i=e.slot;if(r>0&&null==i)throw new Error("memory slot required to create tensor");this.slot=e.slot;const n=e.stride;if(null!=n){if(!(n instanceof Ht))throw new Error(`expected IntTuple stride, found ${typeof n}: ${n}`);this.stride=n}else this.setDefaultStride()}get ptr(){return this.slot.ptr}get wasmInstance(){return this.engine.wasmInstance}isScalar(){return 0==this.order}fill_(e){this.wasmInstance.exports.fill_(this.numel,this.ptr,e)}clamp_(e={}){const t=e.min,s=e.max;this.wasmInstance.exports.clamp(this.numel,this.ptr,this.ptr,t,s,null!=t,null!=s)}zero_(){this.fill_(0)}flattenIdx(e){let t,s,r=!1;if(Array.isArray(e)&&(t=this.engine.intTuple(e),r=!0),!(t instanceof Ht))throw new Error(`cannot handle ${typeof t}: ${t}`);return s=this.engine.wasmInstance.exports.flatten_idx(this.order,t.slot.ptr,this.stride.slot.ptr),r&&t.dispose(),s}typedArray(){return this.slot.f32()}toArray(){if(0==this.numel)return[];const e=jt.makeNdArray(this.shape,0);return this.forEach((t=>{const s=this.get(t);jt.setArrElem(e,t,s)})),e}get(e){const t=this.flattenIdx(e);return this.typedArray()[t]}item(){if(!this.isScalar())throw new Error(`item() only works for scalars, found tensor with shape ${this.shape}`);return this.get([0])}setDefaultStride(){let e=1;const t=this.order,s=[];for(let e=0;e<t;e++)s.push(0);for(let r=0;r<t;r++){const i=t-1-r;s[i]=e,e*=this.shape.get(i)}this.stride=this.engine.intTuple(s)}setFromArray(e){if(0!=this.numel)if(this.isScalar()){if("number"!=typeof e)throw new Error(`expected number, found ${typeof e}: ${e}`);this.set([0],e)}else{if(!Array.isArray(e))throw new Error(`expected array, found ${typeof e}: ${e}`);const t=jt.inferShape(e);if(!this.shape.equal(t))throw new Error(`inconsistent shapes ${t} != ${this.shape}`);this.forEach((t=>{const s=jt.getArrElem(e,t);this.set(t,s)}))}}set(e,t){if(null==t&&Array.isArray(e))this.setFromArray(e);else{const s=this.flattenIdx(e);this.typedArray()[s]=t}}forEach(e){Nt.shapeForEach(this.shape,e)}squeeze(e){-1==e&&(e=this.shape.length-1);const t=this.shape.get(e);if(1!=t)throw new Error(`cannot squeeze a dimension that is not equal to 1, shape[${e}] = ${t}`);const s=[];for(let t=0;t<this.order;t++)e!=t&&s.push(this.shape.get(t));return new Ut({engine:this.engine,shape:s,slot:this.slot})}unsqueeze(e){-1==e&&(e=this.shape.length-1);const t=[];for(let s=0;s<this.order;s++)t.push(this.shape.get(s)),e==s&&t.push(1);return new Ut({engine:this.engine,shape:t,slot:this.slot})}add(e,t){this.engine.functional.add(this,e,t)}sum(e){this.engine.wasmInstance.exports.sum(this.numel,this.slot.ptr,e.slot.ptr)}dispose(){if(null==this.slot)throw new Error("tensor already disposed");this.slot.free(),this.slot=null,this.shape.dispose(),this.stride.dispose()}}var Xt=Ut,Gt=class{constructor(){}};const Yt=Gt;const Zt=Gt;const Jt=Gt;const Kt=Gt;const Qt=class extends Yt{constructor(e,t){super(),this.nn=e,this.layers=t}forward(e){let t=e;return this.layers.forEach((e=>{t=e.forward(t)})),t}dispose(){this.layers.forEach((e=>{e.dispose()}))}},es=class extends Zt{constructor(e,t,s){super(),this.nn=e,this.inputSize=t,this.outputSize=s;const r=this.nn.engine;this.weight=r.zeros([s,t]),this.bias=r.zeros([s]),this.output=r.zeros([s])}forward(e){const t=this.nn.engine.functional;return t.matvec(this.weight,e,this.output),t.add(this.output,this.bias,this.output),this.output}dispose(){this.weight.dispose(),this.bias.dispose(),this.output.dispose()}},ts=class extends Jt{constructor(e){super(),this.nn=e,this.output=null}forward(e){const t=this.nn.engine;return null==this.output&&(this.output=t.zerosLike(e)),t.functional.relu(e,this.output),this.output}dispose(){null!=this.output&&this.output.dispose()}},ss=class extends Kt{constructor(e){super(),this.nn=e,this.output=null}forward(e){const t=this.nn.engine;return null==this.output&&(this.output=t.zerosLike(e)),t.functional.tanh(e,this.output),this.output}dispose(){null!=this.output&&this.output.dispose()}},rs=Pt,is=Bt,ns=Xt,os=Wt,ls=class{constructor(e={}){const t=this.engine=e.engine;this.wasmInstance=t.wasmInstance}matvec(e,t,s){const r=e.shape.get(0),i=e.shape.get(1),n=t.shape.get(0),o=s.shape.get(0);if(r!=o)throw new Error(`inconsistent output size ${r} != ${o}`);if(i!=n)throw new Error(`inconsistent input size ${i} != ${n}`);this.wasmInstance.exports.matvec(r,i,e.stride.ptr,e.ptr,t.stride.ptr,t.ptr,s.stride.ptr,s.ptr)}mm(e,t,s){const r=e.shape.get(0),i=e.shape.get(1),n=t.shape.get(1);this.wasmInstance.exports.mm(r,i,n,e.stride.ptr,e.ptr,t.stride.ptr,t.ptr,s.stride.ptr,s.ptr)}relu(e,t){this.wasmInstance.exports.relu(e.numel,e.ptr,t.ptr)}tanh(e,t){const s=e.numel,r=e.typedArray(),i=t.typedArray();for(let e=0;e<s;e++)i[e]=Math.tanh(r[e])}add(e,t,s){this.wasmInstance.exports.add(e.numel,e.ptr,t.ptr,s.ptr)}sum(e,t){this.wasmInstance.exports.sum(e.numel,e.ptr,t.ptr)}sumBackward(e,t,s,r){this.wasmInstance.exports.sum_backward(e.numel,e.ptr,t.ptr,s.ptr,r.ptr)}},hs=class{constructor(e={}){null!=e.wasmInstance&&this.init(e)}init(e={}){if(null==e.wasmInstance)throw new Error("wasmInstance required");this.wasmInstance=e.wasmInstance;const t=e.wasmInstance.exports.memory.buffer,s=new rs.MemoryManager(t,e.wasmInstance.exports.__heap_base);this.mgr=s,this.functional=this.F=new ls({engine:this}),this.nn=new class{constructor(e={}){this.engine=e.engine}Linear(e,t){return new es(this,e,t)}ReLU(){return new ts(this)}Tanh(){return new ss(this)}Sequential(){const e=Array.from(arguments);return new Qt(this,e)}}({engine:this}),this._mergeF()}_mergeF(){Object.getOwnPropertyNames(Object.getPrototypeOf(this.F)).forEach((e=>{"constructor"!=e&&(this[e]=this.F[e])}))}tensor(e){const t=is.inferShape(e),s=this.intTuple(t),r=is.numelOfShape(t),i=this.mgr.malloc32(r),n=new ns({engine:this,shape:s,slot:i});return n.setFromArray(e),n}intTuple(e){if(!Array.isArray(e))throw new Error(`expected array, found ${typeof e}: ${e}`);const t=e.length,s=this.mgr.malloc32(t),r=new os({engine:this,length:t,slot:s});for(let s=0;s<t;s++)r.set(s,e[s]);return r}zerosLike(e){if(!(e instanceof ns))throw new Error(`expected tensor, found ${typeof e}: ${e}`);return this.zeros(e.shape.toArray())}empty(e){let t;if(e instanceof os)t=e;else{if(!Array.isArray(e))throw new Error(`expected array, found ${typeof e}: ${e}`);t=this.intTuple(e)}const s=is.numelOfShape(t),r=this.mgr.malloc32(s);return new ns({engine:this,shape:t,slot:r})}zeros(e){const t=this.empty(e);return t.zero_(),t}ones(e){const t=this.empty(e);return t.fill_(1),t}};var as={engine:function(e={}){return new hs({wasmInstance:e.wasmInstance})},Engine:hs,Tensor:Xt,mmgr:Pt,utils:Bt},cs=class{constructor(e={}){const t=e.ten;if(null==t)throw new Error("ten required");this.ten=t,this.spaceDim=e.spaceDim??2,this.vertexMass=e.vertexMass??6.0714287757873535,this.pos0=null,this.pos1=null,this.vel0=null,this.vel1=null,this.posGrad=null,this.posTmp=null,this._fixedVertexId=null}toStepArgs(){const e=this.numVertices,t=this.vertexMass,s=this.fixedVertexId;return[e,0==e?0:this.pos0.ptr,0==e?0:this.vel0.ptr,t,-1==s?0:this._fixedVertexId.ptr,0==e?0:this.pos1.ptr,0==e?0:this.posGrad.ptr,0==e?0:this.posTmp.ptr,0==e?0:this.vel1.ptr]}setVertexPos(e,t){for(let s=0;s<this.spaceDim;s++)this.pos.set([e,s],t[s])}getVertexPos(e){const t=[];for(let s=0;s<this.spaceDim;s++)t.push(this.pos.get([e,s]));return t}get fixedVertexId(){return null==this._fixedVertexId?-1:this._fixedVertexId.u32()[0]}fixVertex(e){null==this._fixedVertexId&&(this._fixedVertexId=this.ten.mgr.malloc32(1)),this._fixedVertexId.u32().set([e])}freeVertex(){null!=this._fixedVertexId&&(this._fixedVertexId.free(),this._fixedVertexId=null)}get pos(){return this.pos0}get vel(){return this.vel0}get numVertices(){return null==this.pos0?0:this.pos0.shape.get(0)}updateTmpBuffers(){if(null==this.pos0)throw new Error("pos0 required");const e=this.numVertices,t=this.spaceDim,s=this.ten,r=s.zeros([e,t]);null!=this.posGrad&&this.posGrad.dispose(),this.posGrad=r;const i=s.zeros([e,t]);null!=this.posTmp&&this.posTmp.dispose(),this.posTmp=i}get wasmInstance(){return this.ten.wasmInstance}get memoryManager(){return this.ten.mgr}set(e){const t=this.ten,s=this.spaceDim;if(null==e)throw new Error("pos required");const r=e.length,i=t.tensor(e);null!=this.pos0&&this.pos0.dispose(),this.pos0=i;const n=t.zeros([r,s]);null!=this.pos1&&this.pos1.dispose(),this.pos1=n;const o=t.zeros([r,s]);null!=this.vel0&&this.vel0.dispose(),this.vel0=o;const l=t.zeros([r,s]);null!=this.vel1&&this.vel1.dispose(),this.vel1=l,this.updateTmpBuffers()}addVertex(e={}){const t=this.ten,s=this.numVertices,r=this.spaceDim,i=t.empty([s+1,r]),n=t.empty([s+1,r]),o=t.empty([s+1,r]),l=t.empty([s+1,r]);for(let e=0;e<s;e++)for(let t=0;t<r;t++)i.set([e,t],this.pos0.get([e,t])),n.set([e,t],this.vel0.get([e,t])),o.set([e,t],this.pos1.get([e,t])),l.set([e,t],this.vel1.get([e,t]));const h=e.pos??[0,0],a=e.vel??[0,0];for(let e=0;e<r;e++)i.set([s,e],h[e]),o.set([s,e],h[e]),n.set([s,e],a[e]),l.set([s,e],a[e]);null!=this.pos0&&this.pos0.dispose(),this.pos0=i,null!=this.vel0&&this.vel0.dispose(),this.vel0=n,null!=this.pos1&&this.pos1.dispose(),this.pos1=o,null!=this.vel1&&this.vel1.dispose(),this.vel1=l,this.updateTmpBuffers()}dispose(){null!=this._fixedVertexId&&(this._fixedVertexId.free(),this._fixedVertexId=null),null!=this.pos0&&(this.pos0.dispose(),this.pos0=null),null!=this.pos1&&(this.pos1.dispose(),this.pos1=null),null!=this.vel0&&(this.vel0.dispose(),this.vel0=null),null!=this.vel1&&(this.vel1.dispose(),this.vel1=null),null!=this.posGrad&&(this.posGrad.dispose(),this.posGrad=null),null!=this.posTmp&&(this.posTmp.dispose(),this.posTmp=null)}};const ds=as,us=cs,ms=class{constructor(e={}){const t=e.ten;if(null==t)throw new Error("ten required");this.ten=t,this.indices=null,this.k=Math.fround(90),this.l0=null,this.a=null}get wasmInstance(){return this.ten.wasmInstance}get memoryManager(){return this.ten.mgr}get numMuscles(){return null==this.indices?0:this.indices.u32().length/2}set(e={}){if(null==e.indices)throw new Error("indices required");const t=e.indices,s=t.length,r=this.numMuscles,i=this.memoryManager,n=this.ten;null!=e.k&&(this.k=e.k);const o=i.malloc32(2*s);null!=this.indices&&this.indices.free(),this.indices=o;const l=o.u32();if(t.forEach(((e,t)=>{const s=2*t;l[s]=e[0],l[s+1]=e[1]})),null!=this.l0&&this.l0.dispose(),this.l0=null,0!=s){const t=n.zeros([s]);this.l0=t,null==e.l0?this.wasmInstance.exports.l0_of_pos(this.numVertices,e.pos.ptr,s,this.indices.ptr,this.l0.ptr):this.l0.set(e.l0)}const h=e.keepA??!1;if(s!=r){if(h)throw new Error(`keepA can only be true when the number of muscles is the same (${s} != ${r})`);if(null!=this.a&&(this.a.dispose(),this.a=null),0!=s){const e=n.zeros([s]);this.a=e,e.fill_(1)}}else 0==s?(null!=this.a&&this.a.dispose(),this.a=null):h||this.a.fill_(1)}toStepArgs(){const e=this.numMuscles;return[e,0==e?0:this.indices.ptr,this.k,0==e?0:this.a.ptr,0==e?0:this.l0.ptr]}dispose(){null!=this.indices&&(this.indices.free(),this.indices=null),null!=this.l0&&(this.l0.dispose(),this.l0=null),null!=this.a&&(this.a.dispose(),this.a=null)}};function ps(e){return[e[0],e[1]]}function fs(e,t){e[0]*=t,e[1]*=t}function gs(e){return e[0]*e[0]+e[1]*e[1]}function ws(e){return Math.sqrt(gs(e))}function ys(e){const t=ws(e);0!==t&&fs(e,1/t)}var xs={clone:ps,add:function(e,t){return[e[0]+t[0],e[1]+t[1]]},add_:function(e,t){e[0]+=t[0],e[1]+=t[1]},mulScalar_:fs,mulScalar:function(e,t){const s=ps(e);return fs(s,t),s},sub:function(e,t){return[e[0]-t[0],e[1]-t[1]]},quadrance:gs,norm:ws,normalize:function(e){const t=[...e];return ys(t),t},normalize_:ys,dot:function(e,t){return e[0]*t[0]+e[1]*t[1]}};class vs{constructor(e,t,s,r){this.m00=e,this.m01=t,this.m10=s,this.m11=r}get(e,t){return this[`m${e}${t}`]}set(e,t,s,r){this.m00=e,this.m01=t,this.m10=s,this.m11=r}toArray(){return[[this.m00,this.m01],[this.m10,this.m11]]}negate(){return new vs(-this.m00,-this.m01,-this.m10,-this.m11)}apply(e){return[this.m00*e[0]+this.m01*e[1],this.m10*e[0]+this.m11*e[1]]}det(){return this.m00*this.m11-this.m10*this.m01}inv(){const e=this.det();return new vs(this.m11/e,-this.m01/e,-this.m10/e,this.m00/e)}mm(e){const t=this.m00,s=this.m01,r=this.m10,i=this.m11,n=e.m00,o=e.m01,l=e.m10,h=e.m11;return new vs(t*n+s*l,t*o+s*h,r*n+i*l,r*o+i*h)}t(){return new vs(this.m00,this.m10,this.m01,this.m11)}static fromArray(e){return new vs(e[0][0],e[0][1],e[1][0],e[1][1])}}var Es=vs;const bs=Es,Ss=xs;class Vs{constructor(){this.translation=[0,0],this.linear=new bs(1,0,0,1)}inferScale(){return this.linear.m00}apply(e){return Ss.add(this.linear.apply(e),this.translation)}inv(){const e=new Vs;return e.linear=this.linear.inv(),e.translation=e.linear.negate().apply(this.translation),e}toColumnMajorArray(){return[this.linear.get(0,0),this.linear.get(1,0),this.linear.get(0,1),this.linear.get(1,1),this.translation[0],this.translation[1]]}}var Is={Vec2:xs,Matrix2x2:Es,Transform2d:Vs,AABB:class{constructor(e={}){if(null==e.x0)throw new Error("x0 required");if(null==e.y0)throw new Error("y0 required");this._x0=e.x0,this._y0=e.y0;let t=null;if(null!=e.width)t=this._x0+e.width;else{if(null==e.x1)throw new Error("x1 required");t=e.x1}this._x1=t;let s=null;if(null!=e.height)s=this._y0+e.height;else{if(null==e.y1)throw new Error("y1 required");s=e.y1}this._y1=s}get x0(){return this._x0}get x1(){return this._x1}get y0(){return this._y0}get y1(){return this._y1}get width(){return this._x1-this._x0}get height(){return this._y1-this._y0}get center(){return[.5*(this.x0+this.x1),.5*(this.y0+this.y1)]}}};const Cs=Is;var As={PointShader:class{constructor(){}renderPoint(e={}){const t=e.ctx,s=e.p;t.beginPath(),t.arc(s[0],s[1],3,0,2*Math.PI),t.fill()}},LineShader:class{constructor(){}renderLine(e={}){const t=e.ctx,s=e.a,r=e.b;t.beginPath(),t.strokeStyle="red",t.lineWidth=5,t.moveTo(s[0],s[1]),t.lineTo(r[0],r[1]),t.closePath(),t.stroke()}},TriangleShader:class{constructor(){}renderTriangle(e={}){const t=e.ctx,s=e.a,r=e.b,i=e.c;t.save(),t.beginPath(),t.strokeStyle="black",t.moveTo(s[0],s[1]),t.lineTo(r[0],r[1]),t.lineTo(i[0],i[1]),t.closePath(),t.stroke(),t.restore()}}};const Ms=Is,Ts=As;var _s=class{constructor(e={}){this.scene=e.scene,this.id=e.id,this.x=[],this.triangles=[],this.lines=[],this.pointShader=new Ts.PointShader({}),this.lineShader=new Ts.LineShader({}),this.triangleShader=new Ts.TriangleShader({}),this.customAttributes={}}get pos(){return this.x}set pos(e){this.x=e}numVertices(){return this.pos.length}numTriangles(){return this.triangles.length}numLines(){return this.lines.length}setCustomAttribute(e,t){this.customAttributes[e]=t}getCustomAttribute(e){return this.customAttributes[e]}computeAABB(){let e=null,t=null,s=null,r=null;return this.pos.forEach((i=>{const n=i[0],o=i[1];(null==e||n<e)&&(e=n),(null==t||n>t)&&(t=n),(null==s||o<s)&&(s=o),(null==r||o>r)&&(r=o)})),new Ms.AABB({x0:e,y0:s,x1:t,y1:r})}computeCenter(){const e=this.pos.length;if(0==e)throw new Error("no vertices to compute center");let t=[0,0];for(let s=0;s<e;s++){const e=this.pos[s];Ms.Vec2.add_(t,e)}return Ms.Vec2.mulScalar_(t,1/e),t}};const ks=_s;const zs=_s;var Ls={Camera:class{constructor(){this.transform=new Cs.Transform2d}domToWorldSpace(e){if(!Array.isArray(e))throw new Error("array expected, found "+typeof e);if(2!=e.length)throw new Error(`array with 2 elements expected, found ${e.length}`);return this.transform.inv().apply(e)}inferScale(){return this.transform.inferScale()}center(e={}){let t=e.viewportWidth,s=e.viewportHeight;const r=e.renderer;if((null==t||null==s)&&null==r)throw new Error("renderer required");if(null!=r&&(t=r.width,s=r.height),null==t)throw new Error("viewportWidth required");if(null==s)throw new Error("viewportHeight required");let i,n=e.zoom??1;if(null!=e.worldWidth&&(n=t/e.worldWidth),this.transform.linear=new Cs.Matrix2x2(n,0,0,-n),null!=e.worldCenter){const r=e.worldCenter;i=[.5*t-r[0]*n,.5*s+r[1]*n]}else i=[.5*t,.5*s];this.transform.translation=i}},Mesh:_s,Renderer:class{constructor(e={}){const t=e.headless??!1;if(this.headless=t,!t){const e=document.createElement("canvas");this.domElement=e,this.ctx=e.getContext("2d")}this.setSize({width:200,height:200})}setSize(e){const t=e.width;if(null==t)throw new Error("width required to setSize");const s=e.height;if(null==s)throw new Error("height required to setSize");let r=e.viewportWidth;null==r&&(r=t);let i=e.viewportHeight;if(null==i&&(i=s),this.width=t,this.height=s,this.viewportWidth=r,this.viewportHeight=i,!this.headless){const e=this.domElement;e.width=r,e.height=i,e.style.width=`${t}px`,e.style.height=`${s}px`}}renderPoint(e,t,s,r,i){const n=this.ctx;let o;if(!(t instanceof ks))throw new Error("invalid mesh");o=t.pos[r];const l=s.transform.apply(o);n.save(),t.pointShader.renderPoint({ctx:n,renderer:e,mesh:t,camera:s,id:r,p:l,custom:i}),n.restore()}renderLine(e,t,s,r,i){const n=this.ctx,o=t.lines[r],l=s.transform.apply(t.pos[o[0]]),h=s.transform.apply(t.pos[o[1]]);n.save(),t.lineShader.renderLine({ctx:n,renderer:e,mesh:t,camera:s,id:r,a:l,b:h,custom:i}),n.restore()}renderTriangle(e,t,s,r,i){const n=this.ctx,o=t.triangles[r],l=o[0],h=o[1],a=o[2];let c,d,u;if(t.pos instanceof Float32Array){const e=2;c=[t.pos[l*e],t.pos[l*e+1]],d=[t.pos[h*e],t.pos[h*e+1]],u=[t.pos[a*e],t.pos[a*e+1]]}else c=t.pos[l],d=t.pos[h],u=t.pos[a];const m=s.transform.apply(c),p=s.transform.apply(d),f=s.transform.apply(u);n.save(),t.triangleShader.renderTriangle({ctx:n,renderer:e,mesh:t,camera:s,id:r,a:m,b:p,c:f,custom:i}),n.restore()}renderMesh(e,t,s,r={}){const i=t.sortedElements;if(null==i){for(let i=0;i<t.triangles.length;i++)this.renderTriangle(e,t,s,i,r);for(let i=0;i<t.lines.length;i++)this.renderLine(e,t,s,i,r);for(let i=0;i<t.pos.length;i++)this.renderPoint(e,t,s,i,r)}else i.forEach((i=>{if(null==i.order)throw new Error(`invalid element, order not defined ${i}`);if(1==i.order)this.renderPoint(e,t,s,i.id,r);else if(2==i.order)this.renderLine(e,t,s,i.id,r);else{if(3!=i.order)throw new Error(`invalid element ${i}`);this.renderTriangle(e,t,s,i.id,r)}}))}render(e,t,s={}){this.ctx.clearRect(0,0,this.viewportWidth,this.viewportHeight),e.meshes.forEach((e=>{this.renderMesh(this,e,t,s)}))}},Scene:class{constructor(){this.meshes=new Map}clean(){this.meshes=new Map}numMeshes(){return this.meshes.size}addMesh(){const e=this.meshes.size,t=new zs({scene:this,id:e});return this.meshes.set(e,t),t}}},Ds={computeDomCursor:function(e,t){let s,r;if(null==e.touches)s=e.clientX,r=e.clientY;else{if(0==e.touches.length)return null;const t=e.touches[0];s=t.clientX,r=t.clientY}let i=new DOMMatrix,n=t;for(;null!=n;){const e=window.getComputedStyle(n);i=new DOMMatrix(e.transform).multiply(i),n=n.parentElement}const o=i.inverse(),l=new DOMPointReadOnly(s,r).matrixTransform(o),h=t.getBoundingClientRect(),a=new DOMPointReadOnly(h.left,h.top).matrixTransform(o);return[l.x-a.x,l.y-a.y]}};const $s=Ds;var Ps={cursorUtils:Ds,DragBehavior:class{constructor(e={}){this._dragging=!1,this.onDomCursorDown=e.onDomCursorDown,this.onDragProgress=e.onDragProgress,this.onDomCursorUp=e.onDomCursorUp,this.domElement=null}beginDrag(){this._dragging=!0}endDrag(){this._dragging=!1}dragging(){return this._dragging}domCursorDown(e,t){null!=this.onDomCursorDown&&this.onDomCursorDown(e,t)}domCursorMove(e,t){this.dragging()&&(t.preventDefault(),null!=this.onDragProgress&&this.onDragProgress(e,t))}domCursorUp(e,t){this.endDrag(),null!=this.onDomCursorUp&&this.onDomCursorUp(e,t)}linkToDom(e,t=null){if(null!=this.domElement)throw new Error("already linked to DOM");this.domElement=e;const s=t=>{const s=$s.computeDomCursor(t,e);this.domCursorDown(s,t)};e.addEventListener("mousedown",s,{passive:!1}),e.addEventListener("touchstart",s,{passive:!1});const r=t=>{const s=$s.computeDomCursor(t,e);this.domCursorMove(s,t)};null==t&&(t=e),t.addEventListener("mousemove",r,{passive:!1}),t.addEventListener("touchmove",r,{passive:!1});const i=t=>{const s=$s.computeDomCursor(t,e);this.domCursorUp(s,t)};window.addEventListener("mouseup",i),window.addEventListener("touchend",i),window.addEventListener("touchcancel",i)}}};class qs{constructor(e={}){if(null==e.scene)throw new Error("scene required");const t=null==e.color?"rgba(0, 0, 0, 0.30)":e.color,s=this.mesh=e.scene.addMesh();this.set(e),s.setCustomAttribute("translation",[0,0]),s.pointShader.renderPoint=()=>{},s.lineShader.renderLine=qs.makeGridLineShader({color:t})}get numVertices(){return this.mesh.x.length}get numLines(){return this.mesh.lines.length}set(e={}){const t=null==e.cellSize?1:e.cellSize,s=null==e.innerCells?3:e.innerCells,r=null==e.rows?3:e.rows,i=null==e.cols?4:e.cols,n=null==e.x0?-2:e.x0,o=null==e.y0?0:e.y0,l=null==e.primaryLineWidth?.03:e.primaryLineWidth,h=null==e.secondaryLineWidth?.008:e.secondaryLineWidth,a=this.mesh,{x:c,lineIndices:d,lineWidths:u}=function(e={}){const t=null==e.cellSize?1:e.cellSize,s=null==e.innerCells?3:e.innerCells,r=null==e.rows?3:e.rows,i=null==e.cols?4:e.cols,n=null==e.x0?-2:e.x0,o=null==e.y0?0:e.y0,l=null==e.primaryLineWidth?.022:e.primaryLineWidth,h=null==e.secondaryLineWidth?.008:e.secondaryLineWidth,a=[],c=[],d=[],u=o+r*t,m=n+i*t;function p(e,t){for(let r=0;r<e+1;r++){const i=r==e?1:s;for(let e=0;e<i;e++){const s=2*c.length;t(r,e,i,a),c.push([s,s+1]),0==e?d.push(l):d.push(h)}}}return p(r,((e,s,r,i)=>{const l=s/r,h=(o+e*t)*(1-l)+(o+(e+1)*t)*l;i.push([n,h]),i.push([m,h])})),p(i,((e,s,r,i)=>{const l=s/r,h=(n+e*t)*(1-l)+(n+(e+1)*t)*l;i.push([h,o]),i.push([h,u])})),{x:a,lineIndices:c,lineWidths:d}}({cellSize:t,innerCells:s,rows:r,cols:i,x0:n,y0:o,primaryLineWidth:l,secondaryLineWidth:h});a.pos=c,a.lines=d,a.setCustomAttribute("lineWidths",u)}static makeGridLineShader(e={}){const t=null==e.color?"black":e.color;return e=>{const s=e.ctx,r=e.a,i=e.b,n=e.camera,o=e.mesh,l=n.inferScale();s.beginPath(),s.strokeStyle=t;const h=o.getCustomAttribute("lineWidths");if(null==h)throw new Error("custom attribute lineWidths missing");const a=h[e.id],c=o.getCustomAttribute("translation"),d=[l*c[0],l*c[1]];s.lineWidth=a*l,s.moveTo(r[0]+d[0],r[1]+d[1]),s.lineTo(i[0]+d[0],i[1]+d[1]),s.closePath(),s.stroke()}}}var Ws={Grid:qs,Background:class{constructor(e={}){if(null==e.scene)throw new Error("scene required");const t=this.mesh=e.scene.addMesh();t.pos=[[0,0]];const s=null==e.color1?"#fcfcfc":e.color1,r=null==e.color2?"#d7d8d8":e.color2;t.pointShader.renderPoint=(e={})=>{const t=e.renderer.width,i=e.renderer.height,n=e.ctx,o=n.createRadialGradient(.5*t,.5*i,.05*t,.5*t,.5*i,.5*t);o.addColorStop(0,s),o.addColorStop(1,r),n.fillStyle=o,n.fillRect(0,0,t,i)}}}},Fs=class{constructor(e,t){if(null==e)throw new Error("id required to create simplex");this.order=t.length,this.id=e,this.vertexIds=t}};const Bs=Fs;function Rs(e){return e.sort(),e.join("_")}var Os=class{constructor(e={}){if(null==e.order)throw new Error("order required");this.order=e.order,this.simplicesByHash=new Map}forEach(e){this.simplicesByHash.forEach(e)}size(){return this.simplicesByHash.size}has(e){return this.simplicesByHash.has(Rs(e.vertexIds))}add(e,t){let s=null;if(Array.isArray(e)){if(null==t)throw new Error("id required");s=e,e=new Bs(t,s)}else{if(s=e.vertexIds,null==s)throw new Error(`vertexIds required ${e}`);t=e.id}if(s.length!=this.order)throw new Error(`expected ${this.order} vertices, found ${s.length}`);const r=Rs(s);return this.simplicesByHash.set(r,e),e}};const js=Os,Ns=Os;var Hs=class{constructor(e={}){this.vertices=new Map,this.edges=new Ns({order:2}),this.triangles=new Ns({order:3}),(e.edges??[]).forEach(((e,t)=>{this.addEdge(t,e)})),(e.triangles??[]).forEach(((e,t)=>{this.addTriangle(t,e)}))}numVertices(){return this.vertices.size}numEdges(){return this.edges.size()}numTriangles(){return this.triangles.size()}getVertexById(e,t=!1){let s=this.vertices.get(e);return null==s&&t&&(s=new class{constructor(e){this.id=e,this.edges=new js({order:2}),this.triangles=new js({order:3})}addTriangle(e,t){this.triangles.add(e,t)}addEdge(e,t){this.edges.add(e,t)}}(e),this.vertices.set(e,s)),s}addEdge(e,t){const s=this.edges.add(t,e);return t.forEach((e=>{this.getVertexById(e,!0).addEdge(s)})),s}addTriangle(e,t){const s=this.triangles.add(t,e);return t.forEach((e=>{this.getVertexById(e,!0).addTriangle(s)})),s}};const Us=Hs,Xs=Os;var Gs={math:Is,ui:Ps,shaders:As,background:Ws,sorted:{makeSortedElements:function(e={}){if(null==e.sortedVertexIds)throw new Error("sortedVertexIds required");if(null==e.triangles)throw new Error("triangles required");if(null==e.edges)throw new Error("edges required");const t=e.sortedVertexIds,s=new Map;t.forEach(((e,t)=>{s.set(e,t)}));const r=new Us({triangles:e.triangles}),i=new Us({edges:e.edges}),n=[],o=new Xs({order:3}),l=new Xs({order:2});return t.forEach((e=>{const t=r.getVertexById(e,!0).triangles,h=i.getVertexById(e,!0).edges,a=[];t.forEach((e=>{a.push(e)})),h.forEach((e=>{a.push(e)})),a.sort(((e,t)=>{const r=e.vertexIds.map((e=>s.get(e))),i=t.vertexIds.map((e=>s.get(e))),n=Math.max(...r),o=Math.max(...i);return n<o?1:n==o?0:-1})),a.forEach((e=>{if(2==e.order){const t=e;l.has(t)||(n.push(t),l.add(t))}else{const t=e;o.has(t)||(n.push(t),o.add(t))}})),n.push({order:1,id:e})})),n},MeshTopology:Hs,Simplex:Fs,Simplices:Os},core:Ls,Renderer:Ls.Renderer,Camera:Ls.Camera,Scene:Ls.Scene},Ys=class{constructor(e={}){this.targetCenterX=null,this.currentCenterX=null,this.active=!0,this.visibleWorldWidth=e.visibleWorldWidth??3.8,this.targetCenterY=e.targetCenterY??1,this.offsetX=e.offsetX??0,this.fullGrid=!1,this.centeringSpeedFactor=.5}step(e={}){if(!this.active)return;const t=e.renderer,s=e.camera,r=e.mesh,i=e.floor,n=e.grid;let o=[0,0];r.pos.length>0&&(o=r.computeCenter());const l=o[0]+this.offsetX;isNaN(l)||(this.targetCenterX=l),null==this.currentCenterX?this.currentCenterX=this.targetCenterX:this.currentCenterX+=(this.targetCenterX-this.currentCenterX)*this.centeringSpeedFactor;const h=[this.currentCenterX,this.targetCenterY];s.center({worldCenter:h,worldWidth:this.visibleWorldWidth,viewportWidth:t.width,viewportHeight:t.height});const a=s.domToWorldSpace([t.width,0]),c=s.domToWorldSpace([0,t.height]),[d,u]=c,m=Math.floor(d)-1;let p=Math.floor(u);this.fullGrid||p<0&&(p=0);const[f,g]=a,w=f,y=w-m,x=g-p,v=Math.ceil(x)+1,E=Math.ceil(y)+1;n.set({x0:m,y0:p,rows:v,cols:E,innerCells:n.innerCells,primaryLineWidth:n.primaryLineWidth,secondaryLineWidth:n.secondaryLineWidth}),i.mesh.pos=[[m,0],[w,0]]}};class Zs{constructor(e={}){if(null==e.scene)throw new Error("scene required");const t=this.scene=e.scene,s=this.mesh=t.addMesh();s.pos=[[-10,0],[10,0]],s.lines=[[0,1]],s.lineShader.renderLine=Zs.makeFloorLineShaderFunction({width:e.width,color:e.color}),s.pointShader.renderPoint=()=>{},s.setCustomAttribute("translation",[0,0])}static makeFloorLineShaderFunction(e={}){const t=e.width??.055,s=e.color??"black";return e=>{const r=e.ctx,i=e.a,n=e.b,o=e.camera,l=e.mesh,h=o.inferScale(),a=l.getCustomAttribute("translation"),c=[h*a[0],h*a[1]];r.strokeStyle=s,r.lineWidth=h*t,r.beginPath(),r.moveTo(i[0]+c[0],i[1]+c[1]),r.lineTo(n[0]+c[0],n[1]+c[1]),r.stroke()}}}var Js=Zs;const Ks=Gs;var Qs=class{constructor(e={}){this.system=e.system,this.renderVertexIds=e.renderVertexIds??!1,this.radius=e.radius??.028,this.borderColor=e.borderColor??"black",this.fillColor=e.fillColor??"white",this.borderWidth=e.borderWidth??.023}renderVertex(e={}){const t=this.radius,s=this.borderColor,r=this.fillColor,i=this.borderWidth,n=e.ctx,o=e.p,l=e.camera.inferScale();if(function(e,t,s,r,i,n,o){const l=(r+.5*i)*t;e.fillStyle=o,e.beginPath(),e.arc(s[0],s[1],l,0,2*Math.PI),e.fill(),e.lineWidth=i*t,e.strokeStyle=n,e.stroke()}(n,l,o,t,i,s,r),this.renderVertexIds){n.beginPath(),n.fillStyle="rgba(255, 255, 255, 0.8)",n.arc(o[0],o[1],.1*l,0,2*Math.PI),n.fill();const t=Math.floor(.15*l);n.font=`${t}px monospace`,n.fillStyle="black",n.textAlign="center",n.textBaseline="middle",n.fillText(e.id,o[0],o[1])}}getVertexPos(e){const t=this.system.pos.slot.f32(),s=e*this.system.spaceDim;return[t[s],t[s+1]]}get numVertices(){return this.system.numVertices}hitTest(e,t=.31){const s=this.numVertices;if(0==s)return null;let r=null,i=1/0;const n=t*t;for(let t=0;t<s;t++){const s=this.getVertexPos(t),o=Ks.math.Vec2.sub(s,e),l=Ks.math.Vec2.quadrance(o);l<n&&l<i&&(r=t,i=l)}return r}setVertexPos(e,t){if(null==e)throw new Error("vertex id required");const s=this.system.pos.slot.f32(),r=2*e;s[r]=t[0],s[r+1]=t[1]}setVertexVel(e,t){const s=this.system.vel.slot.f32(),r=2*e;s[r]=t[0],s[r+1]=t[1]}},er=class{constructor(e={}){this.system=e.system}makeEdgesFromTriangles(e){const t=new Map;function s(e,s){const r=((i=[e,s]).sort(),i.join("_"));var i;t.set(r,[e,s])}return e.forEach((e=>{s(e[0],e[1]),s(e[1],e[2]),s(e[0],e[2])})),Array.from(t.values())}makeLineShaderFunction(e={}){const t=e.activeMuscleColor??[255,0,0],s=e.inactiveMuscleColor??[0,0,255],r=e.borderColor??"black";return(e={})=>{const i=e.ctx,n=e.a,o=e.b,l=e.camera.inferScale(),h=e.mesh.getCustomAttribute("lineIdToMuscleId");let a=null;if(null!=h&&(a=h[e.id]),null==a)!function(e,t,s,r,i,n){e.beginPath(),e.lineJoin="round",e.lineCap="round",e.strokeStyle=n,e.lineWidth=.029*t,e.moveTo(s[0],s[1]),e.lineTo(r[0],r[1]),e.closePath(),e.stroke()}(i,l,n,o,0,r);else{const h=t,c=s,d=.065,u=.017,m="muscleIntensity",p=e.mesh.getCustomAttribute(m);if(null==p)throw new Error(`muscle intensity attribute (${m}) not found, call setCustomAttribute("${m}", value) before rendering.`);if(!Array.isArray(p))throw new Error("muscle intensity attribute must be an array with values for each fiber, found "+typeof p);!function(e,t,s,r,i,n,o,l,h,a){e.beginPath(),e.lineCap="butt",e.strokeStyle=l,e.lineWidth=(n+2*o)*t,e.moveTo(s[0],s[1]),e.lineTo(r[0],r[1]),e.stroke(),e.beginPath();const c=(1-i)*h[0]+i*a[0],d=(1-i)*h[1]+i*a[1],u=(1-i)*h[2]+i*a[2];e.strokeStyle=`rgb(${c}, ${d}, ${u})`,e.lineWidth=n*t,e.moveTo(s[0],s[1]),e.lineTo(r[0],r[1]),e.stroke()}(i,l,n,o,p[a],d,u,r,h,c)}}}},tr=class{constructor(e={}){this.fillColor=e.fillColor??"white"}renderTriangle(e={}){const t=e.ctx,s=e.a,r=e.b,i=e.c;t.beginPath(),t.fillStyle=this.fillColor,t.moveTo(...s),t.lineTo(...r),t.lineTo(...i),t.closePath(),t.fill()}};const sr=Gs,rr=Ys,ir=Js,nr=Qs,or=er,lr=tr;function hr(e){return e.sort(),e.join("_")}function ar(e){if(7!=e.length)throw new Error(`invalid hex string ${e}`);if("#"!=e[0])throw new Error(`invalid hex string ${e}, expected #, found ${e[0]}`);return e=e.substring(1),[parseInt(e.substring(0,2),16),parseInt(e.substring(2,4),16),parseInt(e.substring(4,6),16)]}var cr={SystemViewport:class{constructor(e={}){if(null==e.system)throw new Error("system required");this.system=e.system;const t=e.sortedVertexIds;this.sortedVertexIds=t,null!=e.vertexDepths&&this.setSortedVertexIdsFromVertexDepths(e.vertexDepths);const s=e.headless??!1,r=e.borderColor??"black",i=r,n=e.fillColor??"white",o=e.gridColor??"#acadad";this.vertices=new nr({system:this.system,renderVertexIds:e.renderVertexIds??!1,borderColor:r,fillColor:n}),this.lines=new or({system:this.system});const l=new sr.Renderer({headless:s});this.renderer=l,this.domElement=l.domElement,this.setSize({width:e.width??400,height:e.height??400});const h=new sr.Scene;this.scene=h;const a=new sr.Camera;this.camera=a;let c,d,u=e.activeMuscleColor??[255,0,0],m=e.inactiveMuscleColor??[250,190,190];"string"==typeof u&&(u=ar(u)),"string"==typeof m&&(m=ar(m)),null!=e.backgroundColor?(c=e.backgroundColor,d=e.backgroundColor):(c=e.backgroundCenterColor??"#fcfcfc",d=e.backgroundOuterColor??"#d7d8d8"),new sr.background.Background({scene:h,color1:c,color2:d});const p=this.grid=new sr.background.Grid({scene:h,x0:-3,y0:0,rows:4,cols:10,innerCells:2,primaryLineWidth:.022,secondaryLineWidth:.005,color:o});p.innerCells=2,p.primaryLineWidth=.022,p.secondaryLineWidth=.005,this.floor=new ir({scene:h,color:i});const f=h.addMesh();if(this.mesh=f,f.pointShader.renderPoint=e=>{this.vertices.renderVertex(e)},this.triangleRenderer=new lr({fillColor:n}),f.triangleShader.renderTriangle=(e={})=>{this.triangleRenderer.renderTriangle(e)},f.lineShader.renderLine=this.lines.makeLineShaderFunction({activeMuscleColor:u,inactiveMuscleColor:m,borderColor:r}),e.draggable??1){const t=this.dragBehavior=new sr.ui.DragBehavior({onDomCursorDown:(e,s)=>{if("button"in s&&0!=s.button)return;const r=this.system,i=a.domToWorldSpace(e),n=this.hitTestVertex(i);null!=n&&(s.preventDefault(),this.fixVertex(n),t.beginDrag(),this.setVertexPos(r.vertices.fixedVertexId,[i[0],Math.max(0,i[1])]))},onDragProgress:e=>{const t=this.system,s=a.domToWorldSpace(e);this.setVertexPos(t.vertices.fixedVertexId,[s[0],Math.max(0,s[1])])},onDomCursorUp:()=>{this.freeVertex()}});if(!s){const s=e.domElementForMoveEvents??null;t.linkToDom(l.domElement,s)}}this.tracker=new rr}setSortedVertexIdsFromVertexDepths(e){if(e.length!=this.system.numVertices)throw new Error(`invalid size for depths, found ${e.length}, expected ${this.system.numVertices}`);const t=e.map(((e,t)=>({depth:e,index:t})));t.sort(((e,t)=>t.depth-e.depth));const s=t.map((e=>e.index));this.sortedVertexIds=s}setSize(e={}){this.renderer.setSize({width:e.width,height:e.height})}render(){(null==this.needsMeshUpdate||this.needsMeshUpdate)&&(this._updateMesh({triangles:this.system.getTrianglesArray(),muscles:this.system.getMusclesArray()}),this.needsMeshUpdate=!1);const e=this.renderer,t=this.scene,s=this.camera,r=this.mesh;this._updateFromSystem(),null!=this.dragBehavior&&this.dragBehavior.dragging()||this.tracker.step({mesh:r,camera:s,floor:this.floor,grid:this.grid,renderer:this.renderer}),e.render(t,s)}_updateMesh(e){const t=this.mesh,s=this.system.numVertices;if(!Number.isInteger(s)||s<0)throw new Error(`invalid number of vertices ${s}`);null!=e.pos&&(t.pos=e.pos),t.triangles=e.triangles;const r=this.lines;t.lines=r.makeEdgesFromTriangles(e.triangles),Array.prototype.push.apply(t.lines,e.muscles);const i=new Map;e.muscles.forEach(((e,t)=>{i.set(hr(e),t)}));const n=[];t.setCustomAttribute("lineIdToMuscleId",n),t.lines.forEach((e=>{const t=hr(e),s=i.get(t);n.push(s)}));let o=this.sortedVertexIds;if(null==o){o=[];for(let e=0;e<s;e++)o.push(e)}if(o.length!=s)throw new Error(`invalid size for sortedVertexIds, found ${o.length}, expected ${s}`);t.sortedElements=sr.sorted.makeSortedElements({sortedVertexIds:o,triangles:t.triangles,edges:t.lines});const l=[],h=this.system.numMuscles;for(let e=0;e<h;e++)l.push(1);t.setCustomAttribute("muscleIntensity",l)}_updateFromSystem(){this._updateVertexPositionsFromSystem(),this._updateMuscleIntensityFromSystem()}_updateVertexPositionsFromSystem(){const e=this.mesh,t=this.system;if(0==t.numVertices)e.pos=[];else{const s=t.pos.toArray();e.pos=s}}_updateMuscleIntensityFromSystem(){const e=this.mesh,t=this.system,s=t.numMuscles;if(!Number.isInteger(s)||s<0)throw new Error(`invalid number of muscles ${s}`);let r=[];if(s>0)if(t.a){const e=t.a.slot.f32();for(let t=0;t<s;t++)r.push(e[t])}else r=new Array(s).fill(1);e.setCustomAttribute("muscleIntensity",r)}hitTestVertex(e,t=.31){return this.vertices.hitTest(e,t)}setVertexPos(e,t){this.vertices.setVertexPos(e,t)}setVertexVel(e,t){this.vertices.setVertexVel(e,t)}fixVertex(e){const t=this.system;this.setVertexVel(e,[0,0]),null==e&&(e=-1),t.vertices.fixVertex(e)}freeVertex(){this.system.vertices.freeVertex()}},VertexRenderer:Qs,LineRenderer:er,TriangleRenderer:tr,Tracker:Ys};function dr(e,t){const s=1-Math.random(),r=Math.random();return e+Math.sqrt(-2*Math.log(s))*Math.cos(2*Math.PI*r)*t}var ur=function(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}({System:class{constructor(e={}){let t;if(null==e.ten){if(null==e.wasmInstance)throw new Error("wasmInstance required");t=new ds.Engine({wasmInstance:e.wasmInstance}),this.ten=t}else t=e.ten,this.ten=t;this.h=.033,this.g=9.8,this.spaceDim=e.spaceDim??2,this.vertices=new us({ten:this.ten,vertexMass:e.vertexMass,spaceDim:this.spaceDim}),this.muscles=new ms({ten:this.ten}),this.triangles=new class{constructor(e={}){const t=e.ten;if(null==t)throw new Error("ten required");this.ten=t,this.simplexOrder=e.simplexOrder??3,this.indices=null,this.rsi=null,this.mu=null,this.lambda=null}get wasmInstance(){return this.ten.wasmInstance}get memoryManager(){return this.ten.mgr}get numElements(){return null==this.indices?0:this.indices.u32().length/this.simplexOrder}get numTriangles(){return this.numElements}toStepArgs(){const e=this.numElements;return[e,0==e?0:this.indices.ptr,0==e?0:this.rsi.ptr,0==e?0:this.mu.ptr,0==e?0:this.lambda.ptr]}set(e={}){const t=e.indices,s=e.rsi,r=t?t.length:this.numTriangles;if(null==t&&(!s||s.length!==r))throw new Error("rsi is not consistent with the number of indices");const i=this.memoryManager,n=this.ten,o=t?i.malloc32(r*this.simplexOrder):this.indices;if(t&&null!=this.indices&&this.indices.free(),this.indices=o,null!=t){const e=o.u32();t.forEach(((t,s)=>{const r=s*this.simplexOrder;for(let s=0;s<this.simplexOrder;s++)e[r+s]=t[s]}))}if(null!=this.rsi&&this.rsi.dispose(),this.rsi=n.zeros([r,this.simplexOrder-1,this.simplexOrder-1]),null==s){let t=null,s=!1;if(null!=e.pos)if(Array.isArray(e.pos))t=n.tensor(e.pos),s=!0;else if(t=e.pos,null==t.ptr)throw new Error("invalid pos");this.wasmInstance.exports.rsi_of_pos(this.numVertices,t.ptr,r,this.indices.ptr,this.rsi.ptr),s&&t.dispose()}else this.rsi.set(s);null!=this.mu&&this.mu.dispose(),this.mu=n.zeros([r]),this.mu.fill_(Math.fround(500)),null!=this.lambda&&this.lambda.dispose(),this.lambda=n.zeros([r]),this.lambda.fill_(Math.fround(50))}dispose(){null!=this.indices&&(this.indices.free(),this.indices=null),null!=this.rsi&&(this.rsi.dispose(),this.rsi=null),null!=this.mu&&(this.mu.dispose(),this.mu=null),null!=this.lambda&&(this.lambda.dispose(),this.lambda=null)}}({ten:this.ten,simplexOrder:this.spaceDim+1}),this.friction={k:Math.fround(300)},this.collision={k:Math.fround(14e3)}}set fixedVertexId(e){throw new Error("System.fixedVertexId setter is deprecated, use System.vertices.fixedVertexId instead")}get fixedVertexId(){throw new Error("System.fixedVertexId getter is deprecated, use System.vertices.fixedVertexId instead")}get wasmInstance(){return this.ten.wasmInstance}get memoryManager(){return this.ten.mgr}get vertexMass(){return this.vertices.vertexMass}get rsi(){return this.triangles.rsi}set rsi(e){this.triangles.rsi=e}get k(){return this.muscles.k}set k(e){this.muscles.k=e}get pos0(){return this.vertices.pos}get vel0(){return this.vertices.vel0}get pos(){return this.vertices.pos}get vel(){return this.vertices.vel}get numVertices(){return this.vertices.numVertices}get numTriangles(){return this.triangles.numTriangles}get numMuscles(){return this.muscles.numMuscles}get a(){return this.muscles.a}set a(e){this.muscles.a=e}get l0(){return this.muscles.l0}set l0(e){this.muscles.l0=e}setVertices(e){this.vertices.set(e)}setMuscles(e={}){this.muscles.set({...e,pos:e.pos??this.pos0})}setTriangles(e={}){this.triangles.set({...e,pos:e.pos??this.pos0})}getMusclesArray(){if(0==this.numMuscles)return[];const e=this.numMuscles,t=this.muscles.indices.u32(),s=[];for(let r=0;r<e;r++){const e=2*r;s.push([t[e],t[e+1]])}return s}getTrianglesArray(){if(0==this.numTriangles)return[];const e=this.numTriangles,t=this.triangles.indices.u32(),s=[];for(let r=0;r<e;r++){const e=3*r;s.push([t[e],t[e+1],t[e+2]])}return s}set(e){this.setVertices(e.pos),this.setMuscles({indices:e.muscles??[],l0:e.musclesL0,k:e.musclesK}),this.setTriangles({indices:e.triangles??[],rsi:e.trianglesRsi})}toStepArgs(){return[this.spaceDim,this.g,this.h,...this.vertices.toStepArgs(),...this.muscles.toStepArgs(),...this.triangles.toStepArgs(),this.friction.k,this.collision.k]}step(){const e=this.toStepArgs();this.wasmInstance.exports.backward_euler_update(...e),0!=this.numVertices&&(this.vertices.pos0.slot.f32().set(this.vertices.pos1.slot.f32()),this.vertices.vel0.slot.f32().set(this.vertices.vel1.slot.f32()))}dispose(){this.vertices.dispose(),this.muscles.dispose(),this.triangles.dispose()}},Vertices:cs,mmgrten:as,SystemViewport:cr.SystemViewport,mm2d:Gs,render:cr,nn:{NeuralFramePolicy:class{constructor(e={}){if(null==e.system)throw new Error("system required to create policy");this.system=e.system,this.ten=this.system.ten,this.active=e.active??!1,this.stochastic=e.stochastic??!1,this.stdDev=e.stdDev??.05;const t=this.system,s=this.ten,r=this.numVertices=e.numVertices??t.numVertices,i=this.numMuscles=e.numMuscles??t.numMuscles,n=t.spaceDim;this.vertexIdOffset=e.vertexIdOffset??0,this.muscleIdOffset=e.muscleIdOffset??0,this.projectedPos=s.zeros([r,n]),this.projectedVel=s.zeros([r,n]);const o=r*n*2,l=i;this.input=s.zeros([o]),this.clockwise=!1;const h=s.nn;this.model=h.Sequential(h.Linear(o,32),h.ReLU(),h.Linear(32,l),h.Tanh())}get spaceDim(){return this.system.spaceDim}step(e={}){const t=this.system,s=this.ten.wasmInstance,r=this.vertexIdOffset*this.spaceDim*4;s.exports.make_neural_policy_input(this.numVertices,t.pos.ptr+r,t.vel.ptr+r,this.centerVertexId,this.forwardVertexId,this.projectedPos.ptr,this.projectedVel.ptr,this.input.ptr,this.clockwise);const i=this.model.forward(this.input),n=this.minA,o=this.maxAbsDa,l=this.system.a,h=i.slot.f32(),a=this.numMuscles;for(let e=0;e<a;e++){let t;this.active?(t=i.get([e]),this.stochastic&&(t+=dr(0,this.stdDev))):t=1,h[e]=t}const c=e.trace;null!=c&&(c.policyInput=this.input.toArray(),c.policyOutput=i.toArray()),i.clamp_({min:-o,max:o});const d=l.slot.f32();for(let e=0;e<a;e++)d[this.muscleIdOffset+e]+=h[e];l.clamp_({min:n,max:1})}loadData(e){const t=this.model.layers[0];t.weight.set(e.fc1.weight),t.bias.set(e.fc1.bias);const s=this.model.layers[2];s.weight.set(e.fc2.weight),s.bias.set(e.fc2.bias),this.minA=e.min_a??(()=>{throw new Error("min_a required")})(),this.maxAbsDa=e.max_abs_da??(()=>{throw new Error("max_abs_da required")})(),this.centerVertexId=e.center_vertex_id??(()=>{throw new Error("center_vertex_id required")})(),this.forwardVertexId=e.forward_vertex_id??(()=>{throw new Error("forward_vertex_id required")})()}dispose(){null!=this.projectedPos&&this.projectedPos.dispose(),null!=this.projectedVel&&this.projectedVel.dispose(),null!=this.input&&this.input.dispose(),this.model.dispose()}}}});class mr{constructor(e={}){if(!e.mm2d)throw new Error("mm2d required");this.mm2d=e.mm2d,this.shapeColor=e.shapeColor??"white",this.size=e.size??50,this.worldWidth=e.worldWidth??5.2,this.initContainer(),this.initRenderer(),this.initMesh(e),this.setupShaders(),this.render(),this.setActive(!1)}initContainer(){this.domElement=document.createElement("div"),this.domElement.style.borderRadius="50px",this.domElement.style.width=`${this.size}px`,this.domElement.style.height=`${this.size}px`,this.domElement.style.pointerEvents="auto"}initRenderer(){this.renderer=new this.mm2d.Renderer,this.renderer.setSize({width:this.size,height:this.size}),this.scene=new this.mm2d.Scene,this.camera=new this.mm2d.Camera,this.domElement.appendChild(this.renderer.domElement)}initMesh(e){this.mesh=this.scene.addMesh(),this.mesh.pos=e.pos||[],this.mesh.triangles=e.triangles||[]}setupShaders(){this.mesh.pointShader.renderPoint=()=>{},this.mesh.triangleShader.renderTriangle=e=>{this.renderTriangle(e)}}renderTriangle(e){const t=e.ctx,[s,r,i]=[e.a,e.b,e.c],n=e.camera.inferScale();t.beginPath(),t.lineJoin="round",t.lineCap="round",t.strokeStyle=this.shapeColor,t.lineWidth=.058*n,t.moveTo(s[0],s[1]),t.lineTo(r[0],r[1]),t.lineTo(i[0],i[1]),t.closePath(),t.stroke(),t.beginPath(),t.fillStyle=this.shapeColor,t.moveTo(s[0],s[1]),t.lineTo(r[0],r[1]),t.lineTo(i[0],i[1]),t.closePath(),t.fill()}updateMesh({pos:e,triangles:t}){e&&(this.mesh.pos=e),t&&(this.mesh.triangles=t),this.render()}setActive(e=!0){this.domElement.style.backgroundColor=e?"rgba(0, 0, 0, 1)":"rgba(0, 0, 0, 0.2)"}setColor(e){this.shapeColor=e,this.render()}render(){if(this.mesh.pos&&this.mesh.pos.length>0){const e=this.mesh.computeCenter();this.camera.center({worldCenter:e,worldWidth:this.worldWidth,viewportWidth:this.renderer.width,viewportHeight:this.renderer.height})}this.renderer.render(this.scene,this.camera)}}class pr{constructor(e,t,s="data"){this.system=e,this.algovivo=t,this.dataRoot=s,this.currentAgent=null,this.policy=null,this.agents=["quadruped","biped"],this.meshCache=new Map,this.policyCache=new Map}async loadMeshData(e){if(this.meshCache.has(e))return this.meshCache.get(e);const t=await fetch(`${this.dataRoot}/${e}/mesh.json`),s=await t.json();return this.meshCache.set(e,s),s}async loadPolicyData(e){if(this.policyCache.has(e))return this.policyCache.get(e);const t=await fetch(`${this.dataRoot}/${e}/policy.json`),s=await t.json();return this.policyCache.set(e,s),s}async preloadAllData(){await Promise.all(this.agents.map((e=>Promise.all([this.loadMeshData(e),this.loadPolicyData(e)]))))}async switchToAgent(e){if(this.currentAgent===e)return;const[t,s]=await Promise.all([this.loadMeshData(e),this.loadPolicyData(e)]);let r=t.pos;if(null!==this.policy&&null!=this.policy.centerVertexId){const e=this.system.vertices.getVertexPos(this.policy.centerVertexId),i=t.pos[s.center_vertex_id],n=e[0]-i[0];r=t.pos.map((e=>[e[0]+n,e[1]]))}const i=!!this.policy&&this.policy.active;return this.dispose(),this.system.set({pos:r,muscles:t.muscles,musclesL0:t.l0,triangles:t.triangles,trianglesRsi:t.rsi}),this.policy=new this.algovivo.nn.NeuralFramePolicy({system:this.system,stochastic:!0,active:i}),this.policy.loadData(s),this.currentAgent=e,{meshData:t,policyData:s}}dispose(){null!=this.policy&&(this.policy.dispose(),this.policy=null),this.system.dispose()}togglePolicy(){return!!this.policy&&(this.policy.active=!this.policy.active,this.policy.active)}getCurrentAgent(){return this.currentAgent}isActive(){return this.policy&&this.policy.active}}class fr{constructor({system:e,algovivo:t,dataRoot:s="data"}){this.system=e,this.agentManager=new pr(e,t,s),this.viewport=null,this.initContainer(),this.initMiniButtons(t)}initContainer(){this.domElement=document.createElement("div"),this.domElement.style.position="relative",this.domElement.style.display="inline-block",this.domElement.style.borderRadius="10px",this.domElement.style.border="2px solid #c9c9c9",this.domElement.style.boxShadow="0 0 10px rgba(0, 0, 0, 0.1)",this.domElement.style.overflow="hidden",this.initResponsiveSize()}initResponsiveSize(){const e=window.matchMedia("(max-width: 410px)"),t=()=>{const t=e.matches?{width:300,height:350}:{width:400,height:400};this.domElement.style.width=`${t.width}px`,this.domElement.style.height=`${t.height}px`,this.viewport&&this.viewport.setSize(t)};e.addEventListener("change",t),t()}initMiniButtons(e){this.miniContainer=document.createElement("div"),this.miniContainer.style.position="absolute",this.miniContainer.style.top="14px",this.miniContainer.style.right="14px",this.miniContainer.style.zIndex="10",this.miniContainer.style.display="flex",this.miniContainer.style.flexDirection="column",this.miniContainer.style.gap="8px",this.miniButtons={};this.miniButtons.quadruped=new mr({mm2d:e.mm2d,pos:[0,0],triangles:[],size:40}),this.miniButtons.quadruped.domElement.style.cursor="pointer",this.miniButtons.quadruped.domElement.addEventListener("click",(()=>{this.switchToAgent("quadruped")})),this.miniButtons.biped=new mr({mm2d:e.mm2d,pos:[0,0],triangles:[],size:40}),this.miniButtons.biped.domElement.style.cursor="pointer",this.miniButtons.biped.domElement.addEventListener("click",(()=>{this.switchToAgent("biped")})),this.miniContainer.appendChild(this.miniButtons.biped.domElement),this.miniContainer.appendChild(this.miniButtons.quadruped.domElement),this.domElement.appendChild(this.miniContainer)}async preloadMiniButtonData(){await this.agentManager.preloadAllData();for(const e of this.agentManager.agents)try{const t=this.agentManager.meshCache.get(e);this.miniButtons[e]&&t&&this.miniButtons[e].updateMesh({pos:t.pos,triangles:t.triangles})}catch(t){console.warn(`Failed to preload mesh data for ${e}:`,t)}}async switchToAgent(e){if(this.agentManager.getCurrentAgent()!==e)try{const{meshData:t}=await this.agentManager.switchToAgent(e);this.viewport?(this.viewport.needsMeshUpdate=!0,null!=t.depth?this.viewport.setSortedVertexIdsFromVertexDepths(t.depth):null!=t.sorted_vertex_ids&&(this.viewport.sortedVertexIds=t.sorted_vertex_ids)):(this.viewport=new ur.render.SystemViewport({system:this.system,sortedVertexIds:t.sorted_vertex_ids,vertexDepths:t.depth,domElementForMoveEvents:this.domElement}),this.viewport.tracker.targetCenterY=1.1,this.domElement.insertBefore(this.viewport.domElement,this.miniContainer),this.initResponsiveSize()),this.updateMiniButtonStates(e)}catch(t){console.error(`Failed to switch to agent ${e}:`,t)}}updateMiniButtonStates(e){Object.keys(this.miniButtons).forEach((t=>{this.miniButtons[t].setActive(t===e)}))}togglePolicy(){return this.agentManager.togglePolicy()}render(){this.viewport&&this.viewport.render()}dispose(){this.agentManager.dispose()}getCurrentAgent(){return this.agentManager.getCurrentAgent()}isActive(){return this.agentManager.isActive()}}class gr{constructor(e,t){this.domElement=document.createElement("div"),this.domElement.style.textAlign="left",this.domElement.style.color="#666",this.domElement.style.fontSize="14px",this.domElement.style.padding="22px",this.domElement.style.paddingRight="26px",this.domElement.style.paddingLeft="26px",this.domElement.style.paddingBottom="45px",this.domElement.style.width="100%",this.domElement.style.display="flex",this.domElement.style.justifyContent="center";const s=document.createElement("div");s.style.maxWidth="600px",this.domElement.appendChild(s);const r=document.createElement("h2");this.header=r,r.style.color="black",r.style.fontSize="25px",r.style.padding="10px",r.style.borderBottom="2px solid black",r.textContent=e;const i=document.createElement("div");i.innerHTML=t,s.appendChild(r),s.appendChild(i)}setStyle1(){this.domElement.style.backgroundColor="black",this.domElement.style.color="rgb(199, 199, 199)",this.domElement.style.boxShadow="rgba(0, 0, 0, 0.3) 0px 0px 10px",this.header.style.color="white",this.header.style.borderBottom="2px solid white"}}class wr{constructor(){let e;this.domElement=document.createElement("div"),this.domElement.style.marginTop="16px",this.domElement.style.textAlign="left",this.domElement.style.color="#666",this.domElement.style.fontSize="14px",this.domElement.style.width="100%",this.domElement.style.display="flex",this.domElement.style.flexDirection="column",e=this.addSection("energy-based models for virtual creatures",'<div style="display: flex; flex-direction: column">\n<a href="https://direct.mit.edu/isal/proceedings/isal2024/36/30/123447" style="padding-top: 25px; display: flex; flex-direction: column; align-items: center">\n  <img src="icons/doc.svg" style="width: 30px"></img>\n  <div>paper [ALIFE 2024]</div>\n</a>\n<p>\nPotential energy minimization is one of the <a href="https://youtu.be/c8iFtaltX-s?si=MDUb20nFhumn1Q3n&t=3553">most basic forms of goal-directed behavior</a>.\nA deformable object that tends to recover its original shape can be understood as a system whose goal is to minimize its elastic potential energy.\nIn the context of <a href="https://youtu.be/MiqLoAZFRSE?t=2177">energy-based models</a>, &ldquo;energy&rdquo; is used to define implicit functions that capture dependencies between variables.\nThis more general notion of energy is consistent with potential energy, and is also useful to model inertia, friction, neuromuscular control and many other goal-directed behaviors that may or may not be conventionally considered <a href="https://youtu.be/lIHUWOv4nkE?t=629">&ldquo;just physics&rdquo;</a>.\n</p>\n</div>'),e.setStyle1(),e=this.addSection("no forces, just energy functions","<p>\nMuch like the loss function encapsulates in a single scalar value the objective of a neural network during training, potential energy functions offer a scalar representation of the objective of a mechanical system in a dissipative process.\nIn practice, just as we typically do not compute neural network gradients by hand, we can also avoid computing forces by hand if we use automatic differentiation.\nThe force is just the negative gradient of the potential energy.\nFor more general energy functions, which extend beyond potential energy, the negative gradient might not directly represent a force, but it is useful for gradient-based optimization.\n</p>"),e=this.addSection("six energy functions",'<p>\nThis implementation defines six energy functions. Some are plain potential energy functions; that is, functions of vertex positions <span class="code">E(pos)</span>. Actuation mechanisms are modeled with an action-dependent energy function <span class="code">E(pos, a)</span>. Other energy functions may also depend on the previous state, given by vertex positions and velocities <span class="code">(pos0, vel0)</span>.\n</p>\n\n<ul>\n<li>\n  <a href="https://github.com/juniorrojas/algovivo/blob/main/csrc/modules/gravity.h">gravity</a>\n  <span class="code">E(pos)</span>\n</li>\n<li>\n  <a href="https://github.com/juniorrojas/algovivo/blob/main/csrc/modules/collision.h">collision</a>\n  <span class="code">E(pos)</span>\n</li>\n<li>\n  <a href="https://github.com/juniorrojas/algovivo/blob/main/csrc/modules/muscles.h">muscles</a>\n  <span class="code">E(pos, a)</span>\n</li>\n<li>\n  <a href="https://github.com/juniorrojas/algovivo/blob/main/csrc/modules/triangles.h">triangles</a>\n  <span class="code">E(pos)</span>\n</li>\n<li>\n  <a href="https://github.com/juniorrojas/algovivo/blob/main/csrc/modules/friction.h">friction</a>\n  <span class="code">E(pos, pos0)</span>\n</li>\n<li>\n  <a href="https://github.com/juniorrojas/algovivo/blob/main/csrc/dynamics/inertia.h">inertia</a>\n  <span class="code">E(pos, pos0, vel0)</span>\n</li>\n</ul>'),e.setStyle1(),e=this.addSection("no differential equations, just energy minimization",'<p>\nThis implementation uses the backward Euler method, which is conventionally presented as an implicit <a class="a2" href="https://github.com/juniorrojas/springs-integration-pytorch">numerical integration</a> method, derived as a numerical solution to a differential equation like f = ma (Newtonian mechanics).\nHowever, what we actually implement in practice to solve the resulting non-linear root finding problem in a reliable manner is a gradient-based optimization method that finds a local minimum of a function that consists of the sum of the six energy functions mentioned before:\n</p>\n\n<span class="code2" style="white-space: normal">pos1 = argmin((pos) => E(pos, pos0, vel0, a))</span>\n\n<p>\nThe velocity is then updated with a simple update rule:\n</p>\n\n<span class="code2">vel1 = (pos1 - pos0) / dt</span>\n\n<p>\nMany other implicit numerical integration methods share a similar form, where the next state is found by minimizing an energy function.\nWhile the inertial energy term and velocity update rule may vary depending on the specific method used, energy minimization remains central to explaining state transitions.\nInstead of viewing these methods as numerical solutions to differential equations, we can view them as energy-based models that capture Newton\'s first law of motion in an inertial energy term.\n</p>'),e=this.addSection("no Lagrangians, no Hamiltonians, just energy",'<p>\nRecall that in this context &ldquo;energy&rdquo; is any <a href="https://youtu.be/MiqLoAZFRSE?t=2177">scalar-valued function that measures incompatibility between variables</a>.\nWhen we say inertial energy, we do not mean kinetic energy.\nWhen we say energy minimization, we do not mean Hamiltonian minimization.\nIt is actually possible to implement <a href="https://github.com/juniorrojas/springs-integration-pytorch?tab=readme-ov-file#total-energy-hamiltonian-conservation">Hamiltonian-preserving methods</a> by &ldquo;energy&rdquo; minimization.\nEnergy-based models can also easily describe dissipative systems.\n<a href="https://www.youtube.com/watch?v=7fRfxiyTKS0">Lagrangians and Hamiltonians cannot really describe dissipative systems</a>.\nWhen we say energy minimization, we mean something akin to the least action principle, except that &ldquo;action&rdquo; has a very specific definition in Lagrangian mechanics, and we are not using that definition here.\nWe also want to reserve the word &ldquo;action&rdquo; to refer to actuation mechanisms, such as muscle control, which are modeled as action-dependent energy functions.\nWhatever variable or function names you prefer to use in your code, the important thing is to have a <a href="https://github.com/juniorrojas/algovivo">working implementation</a> that goes beyond just words and mathematical formulas that may not even be computable.\n</p>'),e.setStyle1()}addSection(e,t){const s=new gr(e,t);return this.domElement.appendChild(s.domElement),s}}class yr{constructor(){const e=document.createElement("div");var t;this.domElement=e,(t=e.style).display="flex",t.flexDirection="column",t.alignItems="center",t.color="white",t.width="100%",t.backgroundColor="#000000",t.paddingTop="20px",t.paddingBottom="20px",t.paddingRight="50px",t.paddingLeft="50px",t.marginBottom="30px",t.boxShadow="0 0 10px rgba(0, 0, 0, 0.3)";const s=document.createElement("h1");s.textContent="algovivo",e.appendChild(s),(e=>{e.fontSize="33px",e.color="white"})(s.style);const r=document.createElement("h2");r.textContent="an energy-based formulation for soft-bodied virtual creatures",e.appendChild(r),(e=>{e.textAlign="center",e.fontSize="18px",e.color="#c7c7c7"})(r.style)}}!async function(){document.body.style.background="rgb(248, 248, 248)",document.body.style.display="flex",document.body.style.flexDirection="column",function(){const e=document.createElement("a");document.body.appendChild(e),e.href="https://github.com/juniorrojas/algovivo",e.innerHTML='<svg style="cursor: pointer; position: absolute; top: 0; border: 0; right: 0; margin: 10px 7px;" viewBox="0 0 98 96" width="40" height="40" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M48.854 0C21.839 0 0 22 0 49.217c0 21.756 13.993 40.172 33.405 46.69 2.427.49 3.316-1.059 3.316-2.362 0-1.141-.08-5.052-.08-9.127-13.59 2.934-16.42-5.867-16.42-5.867-2.184-5.704-5.42-7.17-5.42-7.17-4.448-3.015.324-3.015.324-3.015 4.934.326 7.523 5.052 7.523 5.052 4.367 7.496 11.404 5.378 14.235 4.074.404-3.178 1.699-5.378 3.074-6.6-10.839-1.141-22.243-5.378-22.243-24.283 0-5.378 1.94-9.778 5.014-13.2-.485-1.222-2.184-6.275.486-13.038 0 0 4.125-1.304 13.426 5.052a46.97 46.97 0 0 1 12.214-1.63c4.125 0 8.33.571 12.213 1.63 9.302-6.356 13.427-5.052 13.427-5.052 2.67 6.763.97 11.816.485 13.038 3.155 3.422 5.015 7.822 5.015 13.2 0 18.905-11.404 23.06-22.324 24.283 1.78 1.548 3.316 4.481 3.316 9.126 0 6.6-.08 11.897-.08 13.526 0 1.304.89 2.853 3.316 2.364 19.412-6.52 33.405-24.935 33.405-46.691C97.707 22 75.788 0 48.854 0z" fill="#fff"/></svg>'}();const e=new yr;document.body.appendChild(e.domElement);const t=document.createElement("div");t.style.display="flex",t.style.flexDirection="column",t.style.alignItems="center",t.style.width="100%",document.body.appendChild(t),document.documentElement.style.height="100%",document.body.style.height="100%",document.body.style.display="flex",document.body.style.flexDirection="column",document.body.style.margin=0,document.body.style.padding=0,document.body.style.alignItems="center";const s=await async function(){const e=await fetch("algovivo.wasm");return(await WebAssembly.instantiateStreaming(e)).instance}(),r=new wt.System({wasmInstance:s}),i=new fr({system:r,algovivo:wt,dataRoot:"data"});t.appendChild(i.domElement),await i.preloadMiniButtonData(),await i.switchToAgent("biped");const n=new yt;n.domElement.style.marginTop="8px",n.domElement.style.marginBottom="16px",n.domElement.addEventListener("click",(()=>{i.togglePolicy()?n.setActiveStyle():n.setInactiveStyle()})),t.appendChild(n.domElement);const o=new wr;t.appendChild(o.domElement),i.render(),setInterval((()=>{null!=i.agentManager.policy&&i.agentManager.policy.step(),r.step(),i.render()}),1e3/30),window.system=r}();
