function e(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}class t{constructor(e,t){this.list=e,this.data=t,this.next=null,this.prev=null}append(e){const s=new t(this.list,e);return this.list.last==this&&(this.list.last=s),s.next=this.next,s.prev=this,null!=this.next&&(this.next.prev=s),this.next=s,this.list.size++,s}prepend(e){const s=new t(this.list,e);return this.list.first==this&&(this.list.first=s),s.next=this,s.prev=this.prev,null!=this.prev&&(this.prev.next=s),this.prev=s,this.list.size++,s}remove(){null!=this.prev&&(this.prev.next=this.next),null!=this.next&&(this.next.prev=this.prev),this.list.first==this&&(this.list.first=this.next),this.list.last==this&&(this.list.last=this.prev),this.list.size--,this.next=null,this.prev=null}}var s=t;const i=s;class r{constructor(e){this.list=e,this.nextNode=this.list.first}next(){if(null==this.nextNode)return{done:!0};{const e={done:!1,value:this.nextNode.data};return this.nextNode=this.nextNode.next,e}}}class n{constructor(){this.first=null,this.last=null,this.size=0}isEmpty(){if(null==this.first&&null!=this.last||null!=this.first&&null==this.last)throw Error("inconsistent first last state");return null==this.first}append(e){return this.isEmpty()?this.setSingleton(e):this.last.append(e)}prepend(e){return this.isEmpty()?this.setSingleton(e):this.first.prepend(e)}setSingleton(e){const t=new i(this,e);return this.first=t,this.last=t,this.size=1,t}iter(){return new r(this)}*[Symbol.iterator](){const e=this.iter();let t=e.next();for(;!t.done;)yield t.value,t=e.next()}}var o,l,h,a,d,c,u={List:n,Node:s};function m(){if(l)return o;l=1;const e=p();return o=class extends e{constructor(e={}){super(e)}isFree(){return!1}free(){let e=this.appendFree(this.ptr,this.size);this.remove();const t=e.prev(),s=e.next();return null!=t&&t.isFree()&&(e=t.merge(e)),null!=s&&s.isFree()&&(e=e.merge(s)),e}}}function p(){if(a)return h;a=1;return h=class{constructor(e={}){this.manager=e.manager,this.ptr=e.ptr,this.size=e.size,this.node=e.node}numBytes(){return this.size}prev(){const e=this.node.prev;return null!=e?e.data:null}next(){const e=this.node.next;return null!=e?e.data:null}appendReserved(e,t){const s=m(),i=this.node.append(null),r=new s({manager:this.manager,ptr:e,size:t,node:i});return i.data=r,this.manager._addReservedSlot(r),r}appendFree(e,t){const s=g(),i=this.node.append(null),r=new s({manager:this.manager,ptr:e,size:t,node:i});return i.data=r,this.manager._addFreeSlot(r),r}remove(){this.node.remove(),this.node.data=null,this.node=null,this.isFree()?this.manager._removeFreeSlot(this):this.manager._removeReservedSlot(this)}toTypedArray(e){const t=this.size,s=e.BYTES_PER_ELEMENT;if(t%s!=0)throw new Error(`size in bytes must be a multiple of ${s}, found ${t}`);const i=this.ptr;return new e(this.manager.array,i,t/s)}f32(){return this.toTypedArray(Float32Array)}u32(){return this.toTypedArray(Uint32Array)}},h}function g(){if(c)return d;c=1;const e=p();return d=class extends e{constructor(e={}){super(e)}isFree(){return!0}reserve(e){const t=this.numBytes();if(e>t)throw new Error(`cannot reserve ${e} bytes, only ${t} bytes are available`);const s=this.appendReserved(this.ptr,e);return s.appendFree(this.ptr+e,t-e),this.remove(),s}merge(e){if(!this.isFree()||!e.isFree())throw new Error("only free slots can be merged");if(this.next()!=e)throw new Error("only adjacent slots can be merged");const t=e.appendFree(this.ptr,this.size+e.size);return this.remove(),e.remove(),t}}}const f=u,y=g();var w={linked:u,MemoryManager:class{constructor(e,t){this.array=e,null==t&&(t=0),this.ptrToSlot=new Map,this.slots=new f.List,this.freeSlots=new f.List,this.reservedSlots=new f.List;const s=new y({manager:this,ptr:t,size:e.byteLength-t}),i=this.slots.append();i.data=s,s.node=i;const r=this.freeSlots.append();r.data=s,s.freeNode=r}numReservedSlots(){return this.reservedSlots.size}numFreeSlots(){return this.freeSlots.size}numFreeBytes(){let e=0;const t=this.freeSlots.iter();let s=t.next();for(;!s.done;){e+=s.value.size,s=t.next()}return e}numReservedBytes(){let e=0;const t=this.reservedSlots.iter();let s=t.next();for(;!s.done;){e+=s.value.size,s=t.next()}return e}mallocBytes(e){return this._malloc(e)}malloc32(e){return this.mallocBytes(4*e)}_addReservedSlot(e){const t=this.reservedSlots.append(e);e.reservedNode=t}_removeReservedSlot(e){if(null==e.reservedNode)throw new Error("reservedNode cannot be null");e.reservedNode.remove()}_addFreeSlot(e){const t=this.freeSlots.append(e);e.freeNode=t}_removeFreeSlot(e){if(null==e.freeNode)throw new Error("freeNode cannot be null");e.freeNode.remove()}_malloc(e){if(!Number.isInteger(e))throw new Error(`expected integer, found ${e}`);let t=null;const s=this.freeSlots.iter();let i=s.next();for(;!i.done;){const r=i.value;if(r.size>=e){t=r;break}i=s.next()}if(null==t)throw new Error("no valid free slot available");return t.reserve(e)}malloc(e){const t=this._malloc(e);return this.ptrToSlot.set(t.ptr,t),t.ptr}free(e){this.ptrToSlot.get(e).free()}},FreeSlot:g(),ReservedSlot:m()};class v{constructor(e={}){const t=e.engine;if(null==t)throw new Error("engine required to create IntTuple");this.engine=t;const s=e.slot;if(null==s)throw new Error("slot required to create IntTuple");this.slot=s,this.ptr=s.ptr,this.length=e.length}forEach(e){for(let t=0;t<this.length;t++)e(this.get(t),t)}equal(e){if(e instanceof v){for(let t=0;t<this.length;t++){if(this.get(t)!=e.get(t))return!1}return!0}if(Array.isArray(e)){for(let t=0;t<this.length;t++){if(this.get(t)!=e[t])return!1}return!0}return!1}toString(){return this.slot.u32().toString()}toArray(){const e=[];return this.forEach((t=>{e.push(t)})),e}typedArray(){return this.slot.u32()}set(e,t){this.typedArray()[e]=t}get(e){return this.typedArray()[e]}dispose(){this.slot.free()}}var x=v;function E(e,t,s,i){if(t==s.length-1)for(let r=0;r<s[t];r++)e.push(i);else for(let r=0;r<s[t];r++){const r=[];e.push(r),E(r,t+1,s,i)}}var b={inferShape:function(e){const t=[];let s=e;for(;Array.isArray(s);)t.push(s.length),s=s[0];return t},makeNdArray:function(e,t){let s=e;e instanceof x&&(s=e.toArray());const i=[];return E(i,0,s,t),i},numelOfShape:function(e){let t=1;return e.forEach((e=>{t*=e})),t},getArrElem:function e(t,s){if(!Array.isArray(s))throw new Error(`expected array, found ${typeof s}: ${s}`);return 0==s.length?t:e(t[s[0]],s.slice(1))},setArrElem:function e(t,s,i){if(!Array.isArray(s))throw new Error(`expected array, found ${typeof s}: ${s}`);if(1!=s.length)return e(t[s[0]],s.slice(1),i);t[s]=i}};const S=x;class C{constructor(e){if(null==e)throw new Error("shape required");if(!(e instanceof S))throw new Error(`IntTuple shape expected, found ${typeof e}: shape`);this.shape=e,this.done=!1,this.idx=[],e.forEach((e=>{this.idx.push(0)}))}next(){const e=this.shape;for(let t=0;t<e.length;t++){const s=e.length-1-t;if(this.idx[s]<e.get(s)-1)return void this.idx[s]++;if(0==s)return void(this.done=!0);this.idx[s]=0}}static shapeForEach(e,t){const s=new C(e);for(;!s.done;)t(s.idx),s.next()}}const V=b,A=C,M=x;class I{constructor(e={}){const t=e.engine;if(null==t)throw new Error("engine required to create tensor");this.engine=t;const s=e.shape;if(null==s)throw new Error("shape required to create tensor");if(s instanceof M)this.shape=s;else{if(!Array.isArray(s))throw new Error(`invalid shape type ${typeof s}: ${s}`);this.shape=t.intTuple(s)}this.order=this.shape.length;const i=V.numelOfShape(this.shape);this.numel=i;const r=e.slot;if(i>0&&null==r)throw new Error("memory slot required to create tensor");this.slot=e.slot;const n=e.stride;if(null!=n){if(!(n instanceof M))throw new Error(`expected IntTuple stride, found ${typeof n}: ${n}`);this.stride=n}else this.setDefaultStride()}get ptr(){return this.slot.ptr}get wasmInstance(){return this.engine.wasmInstance}isScalar(){return 0==this.order}fill_(e){this.wasmInstance.exports.fill_(this.numel,this.ptr,e)}clamp_(e={}){const t=e.min,s=e.max;this.wasmInstance.exports.clamp(this.numel,this.ptr,this.ptr,t,s,null!=t,null!=s)}zero_(){this.fill_(0)}flattenIdx(e){let t,s,i=!1;if(Array.isArray(e)&&(t=this.engine.intTuple(e),i=!0),!(t instanceof M))throw new Error(`cannot handle ${typeof t}: ${t}`);return s=this.engine.wasmInstance.exports.flatten_idx(this.order,t.slot.ptr,this.stride.slot.ptr),i&&t.dispose(),s}typedArray(){return this.slot.f32()}toArray(){if(0==this.numel)return[];const e=V.makeNdArray(this.shape,0);return this.forEach((t=>{const s=this.get(t);V.setArrElem(e,t,s)})),e}get(e){const t=this.flattenIdx(e);return this.typedArray()[t]}item(){if(!this.isScalar())throw new Error(`item() only works for scalars, found tensor with shape ${this.shape}`);return this.get([0])}setDefaultStride(){let e=1;const t=this.order,s=[];for(let e=0;e<t;e++)s.push(0);for(let i=0;i<t;i++){const r=t-1-i;s[r]=e,e*=this.shape.get(r)}this.stride=this.engine.intTuple(s)}setFromArray(e){if(0==this.numel)return;if(this.isScalar()){if("number"!=typeof e)throw new Error(`expected number, found ${typeof e}: ${e}`);this.set([0],e)}else{if(!Array.isArray(e))throw new Error(`expected array, found ${typeof e}: ${e}`);const t=V.inferShape(e);if(!this.shape.equal(t))throw new Error(`inconsistent shapes ${t} != ${this.shape}`);this.forEach((t=>{const s=V.getArrElem(e,t);this.set(t,s)}))}}set(e,t){if(null==t&&Array.isArray(e))this.setFromArray(e);else{const s=this.flattenIdx(e);this.typedArray()[s]=t}}forEach(e){A.shapeForEach(this.shape,e)}squeeze(e){-1==e&&(e=this.shape.length-1);const t=this.shape.get(e);if(1!=t)throw new Error(`cannot squeeze a dimension that is not equal to 1, shape[${e}] = ${t}`);const s=[];for(let t=0;t<this.order;t++)e!=t&&s.push(this.shape.get(t));return new I({engine:this.engine,shape:s,slot:this.slot})}unsqueeze(e){-1==e&&(e=this.shape.length-1);const t=[];for(let s=0;s<this.order;s++)t.push(this.shape.get(s)),e==s&&t.push(1);return new I({engine:this.engine,shape:t,slot:this.slot})}add(e,t){this.engine.functional.add(this,e,t)}sum(e){this.engine.wasmInstance.exports.sum(this.numel,this.slot.ptr,e.slot.ptr)}dispose(){if(null==this.slot)throw new Error("tensor already disposed");this.slot.free(),this.slot=null,this.shape.dispose(),this.stride.dispose()}}var T=I;var L=class{constructor(e={}){const t=this.engine=e.engine;this.wasmInstance=t.wasmInstance}matvec(e,t,s){const i=e.shape.get(0),r=e.shape.get(1),n=t.shape.get(0),o=s.shape.get(0);if(i!=o)throw new Error(`inconsistent output size ${i} != ${o}`);if(r!=n)throw new Error(`inconsistent input size ${r} != ${n}`);this.wasmInstance.exports.matvec(i,r,e.stride.ptr,e.ptr,t.stride.ptr,t.ptr,s.stride.ptr,s.ptr)}mm(e,t,s){const i=e.shape.get(0),r=e.shape.get(1),n=t.shape.get(1);this.wasmInstance.exports.mm(i,r,n,e.stride.ptr,e.ptr,t.stride.ptr,t.ptr,s.stride.ptr,s.ptr)}relu(e,t){this.wasmInstance.exports.relu(e.numel,e.ptr,t.ptr)}tanh(e,t){const s=e.numel,i=e.typedArray(),r=t.typedArray();for(let e=0;e<s;e++)r[e]=Math.tanh(i[e])}add(e,t,s){this.wasmInstance.exports.add(e.numel,e.ptr,t.ptr,s.ptr)}sum(e,t){this.wasmInstance.exports.sum(e.numel,e.ptr,t.ptr)}sumBackward(e,t,s,i){this.wasmInstance.exports.sum_backward(e.numel,e.ptr,t.ptr,s.ptr,i.ptr)}};var _=class{constructor(){}};const z=_;var k=class extends z{constructor(e,t){super(),this.nn=e,this.layers=t}forward(e){let t=e;return this.layers.forEach((e=>{t=e.forward(t)})),t}dispose(){this.layers.forEach((e=>{e.dispose()}))}};const D=_;var P=class extends D{constructor(e,t,s){super(),this.nn=e,this.inputSize=t,this.outputSize=s;const i=this.nn.engine;this.weight=i.zeros([s,t]),this.bias=i.zeros([s]),this.output=i.zeros([s])}forward(e){const t=this.nn.engine.functional;return t.matvec(this.weight,e,this.output),t.add(this.output,this.bias,this.output),this.output}dispose(){this.weight.dispose(),this.bias.dispose(),this.output.dispose()}};const q=_;var $=class extends q{constructor(e){super(),this.nn=e,this.output=null}forward(e){const t=this.nn.engine;return null==this.output&&(this.output=t.zerosLike(e)),t.functional.relu(e,this.output),this.output}dispose(){null!=this.output&&this.output.dispose()}};const W=_;var B=class extends W{constructor(e){super(),this.nn=e,this.output=null}forward(e){const t=this.nn.engine;return null==this.output&&(this.output=t.zerosLike(e)),t.functional.tanh(e,this.output),this.output}dispose(){null!=this.output&&this.output.dispose()}};const F=k,j=P,R=$,H=B;const O=w,N=b,U=T,X=x,G=L,Y=class{constructor(e={}){this.engine=e.engine}Linear(e,t){return new j(this,e,t)}ReLU(){return new R(this)}Tanh(){return new H(this)}Sequential(){const e=Array.from(arguments);return new F(this,e)}};const Z=class{constructor(e={}){null!=e.wasmInstance&&this.init(e)}init(e={}){if(null==e.wasmInstance)throw new Error("wasmInstance required");this.wasmInstance=e.wasmInstance;const t=e.wasmInstance.exports.memory.buffer,s=new O.MemoryManager(t,e.wasmInstance.exports.__heap_base);this.mgr=s,this.functional=this.F=new G({engine:this}),this.nn=new Y({engine:this}),this._mergeF()}_mergeF(){Object.getOwnPropertyNames(Object.getPrototypeOf(this.F)).forEach((e=>{"constructor"!=e&&(this[e]=this.F[e])}))}tensor(e){const t=N.inferShape(e),s=this.intTuple(t),i=N.numelOfShape(t),r=this.mgr.malloc32(i),n=new U({engine:this,shape:s,slot:r});return n.setFromArray(e),n}intTuple(e){if(!Array.isArray(e))throw new Error(`expected array, found ${typeof e}: ${e}`);const t=e.length,s=this.mgr.malloc32(t),i=new X({engine:this,length:t,slot:s});for(let s=0;s<t;s++)i.set(s,e[s]);return i}zerosLike(e){if(!(e instanceof U))throw new Error(`expected tensor, found ${typeof e}: ${e}`);return this.zeros(e.shape.toArray())}empty(e){let t;if(e instanceof X)t=e;else{if(!Array.isArray(e))throw new Error(`expected array, found ${typeof e}: ${e}`);t=this.intTuple(e)}const s=N.numelOfShape(t),i=this.mgr.malloc32(s);return new U({engine:this,shape:t,slot:i})}zeros(e){const t=this.empty(e);return t.zero_(),t}ones(e){const t=this.empty(e);return t.fill_(1),t}};var J={engine:function(e={}){return new Z({wasmInstance:e.wasmInstance})},Engine:Z,Tensor:T,mmgr:w,utils:b};var K=class{constructor(e={}){const t=e.ten;if(null==t)throw new Error("ten required");this.ten=t,this.spaceDim=e.spaceDim??2,this.vertexMass=e.vertexMass??6.0714287757873535,this.pos0=null,this.pos1=null,this.vel0=null,this.vel1=null,this.posGrad=null,this.posTmp=null,this._fixedVertexId=null}toStepArgs(){const e=this.numVertices,t=this.vertexMass,s=this.fixedVertexId;return[e,0==e?0:this.pos0.ptr,0==e?0:this.vel0.ptr,t,-1==s?0:this._fixedVertexId.ptr,0==e?0:this.pos1.ptr,0==e?0:this.posGrad.ptr,0==e?0:this.posTmp.ptr,0==e?0:this.vel1.ptr]}setVertexPos(e,t){for(let s=0;s<this.spaceDim;s++)this.pos.set([e,s],t[s])}getVertexPos(e){const t=[];for(let s=0;s<this.spaceDim;s++)t.push(this.pos.get([e,s]));return t}get fixedVertexId(){return null==this._fixedVertexId?-1:this._fixedVertexId.u32()[0]}fixVertex(e){null==this._fixedVertexId&&(this._fixedVertexId=this.ten.mgr.malloc32(1)),this._fixedVertexId.u32().set([e])}freeVertex(){null!=this._fixedVertexId&&(this._fixedVertexId.free(),this._fixedVertexId=null)}get pos(){return this.pos0}get vel(){return this.vel0}get numVertices(){return null==this.pos0?0:this.pos0.shape.get(0)}updateTmpBuffers(){if(null==this.pos0)throw new Error("pos0 required");const e=this.numVertices,t=this.spaceDim,s=this.ten,i=s.zeros([e,t]);null!=this.posGrad&&this.posGrad.dispose(),this.posGrad=i;const r=s.zeros([e,t]);null!=this.posTmp&&this.posTmp.dispose(),this.posTmp=r}get wasmInstance(){return this.ten.wasmInstance}get memoryManager(){return this.ten.mgr}set(e){const t=this.ten,s=this.spaceDim;if(null==e)throw new Error("pos required");const i=e.length,r=t.tensor(e);null!=this.pos0&&this.pos0.dispose(),this.pos0=r;const n=t.zeros([i,s]);null!=this.pos1&&this.pos1.dispose(),this.pos1=n;const o=t.zeros([i,s]);null!=this.vel0&&this.vel0.dispose(),this.vel0=o;const l=t.zeros([i,s]);null!=this.vel1&&this.vel1.dispose(),this.vel1=l,this.updateTmpBuffers()}addVertex(e={}){const t=this.ten,s=this.numVertices,i=this.spaceDim,r=t.empty([s+1,i]),n=t.empty([s+1,i]),o=t.empty([s+1,i]),l=t.empty([s+1,i]);for(let e=0;e<s;e++)for(let t=0;t<i;t++)r.set([e,t],this.pos0.get([e,t])),n.set([e,t],this.vel0.get([e,t])),o.set([e,t],this.pos1.get([e,t])),l.set([e,t],this.vel1.get([e,t]));const h=e.pos??[0,0],a=e.vel??[0,0];for(let e=0;e<i;e++)r.set([s,e],h[e]),o.set([s,e],h[e]),n.set([s,e],a[e]),l.set([s,e],a[e]);null!=this.pos0&&this.pos0.dispose(),this.pos0=r,null!=this.vel0&&this.vel0.dispose(),this.vel0=n,null!=this.pos1&&this.pos1.dispose(),this.pos1=o,null!=this.vel1&&this.vel1.dispose(),this.vel1=l,this.updateTmpBuffers()}dispose(){null!=this._fixedVertexId&&(this._fixedVertexId.free(),this._fixedVertexId=null),null!=this.pos0&&(this.pos0.dispose(),this.pos0=null),null!=this.pos1&&(this.pos1.dispose(),this.pos1=null),null!=this.vel0&&(this.vel0.dispose(),this.vel0=null),null!=this.vel1&&(this.vel1.dispose(),this.vel1=null),null!=this.posGrad&&(this.posGrad.dispose(),this.posGrad=null),null!=this.posTmp&&(this.posTmp.dispose(),this.posTmp=null)}};var Q=class{constructor(e={}){const t=e.ten;if(null==t)throw new Error("ten required");this.ten=t,this.indices=null,this.k=Math.fround(90),this.l0=null,this.a=null}get wasmInstance(){return this.ten.wasmInstance}get memoryManager(){return this.ten.mgr}get numMuscles(){return null==this.indices?0:this.indices.u32().length/2}set(e={}){if(null==e.indices)throw new Error("indices required");const t=e.indices,s=t.length,i=this.numMuscles,r=this.memoryManager,n=this.ten;null!=e.k&&(this.k=e.k);const o=r.malloc32(2*s);null!=this.indices&&this.indices.free(),this.indices=o;const l=o.u32();if(t.forEach(((e,t)=>{const s=2*t;l[s]=e[0],l[s+1]=e[1]})),null!=this.l0&&this.l0.dispose(),this.l0=null,0!=s){const t=n.zeros([s]);if(this.l0=t,null==e.l0){const t=e.pos;if(null==t)throw new Error("pos required to compute l0");if(null==t.ptr)throw new Error("pos.ptr not available");this.wasmInstance.exports.l0_of_pos(this.numVertices,t.ptr,s,this.indices.ptr,this.l0.ptr)}else this.l0.set(e.l0)}const h=e.keepA??!1;if(s!=i){if(h)throw new Error(`keepA can only be true when the number of muscles is the same (${s} != ${i})`);if(null!=this.a&&(this.a.dispose(),this.a=null),0!=s){const e=n.zeros([s]);this.a=e,e.fill_(1)}}else 0==s?(null!=this.a&&this.a.dispose(),this.a=null):h||this.a.fill_(1)}toStepArgs(){const e=this.numMuscles;return[e,0==e?0:this.indices.ptr,this.k,0==e?0:this.a.ptr,0==e?0:this.l0.ptr]}dispose(){null!=this.indices&&(this.indices.free(),this.indices=null),null!=this.l0&&(this.l0.dispose(),this.l0=null),null!=this.a&&(this.a.dispose(),this.a=null)}};const ee=J,te=K,se=Q,ie=class{constructor(e={}){const t=e.ten;if(null==t)throw new Error("ten required");this.ten=t,this.simplexOrder=e.simplexOrder??3,this.indices=null,this.rsi=null,this.mu=null,this.lambda=null}get wasmInstance(){return this.ten.wasmInstance}get memoryManager(){return this.ten.mgr}get numElements(){return null==this.indices?0:this.indices.u32().length/this.simplexOrder}get numTriangles(){return this.numElements}toStepArgs(){const e=this.numElements;return[e,0==e?0:this.indices.ptr,0==e?0:this.rsi.ptr,0==e?0:this.mu.ptr,0==e?0:this.lambda.ptr]}set(e={}){const t=e.indices,s=e.rsi,i=t?t.length:this.numTriangles;if(null==t&&(!s||s.length!==i))throw new Error("rsi is not consistent with the number of indices");const r=this.memoryManager,n=this.ten,o=t?r.malloc32(i*this.simplexOrder):this.indices;if(t&&null!=this.indices&&this.indices.free(),this.indices=o,null!=t){const e=o.u32();t.forEach(((t,s)=>{const i=s*this.simplexOrder;for(let s=0;s<this.simplexOrder;s++)e[i+s]=t[s]}))}if(null!=this.rsi&&this.rsi.dispose(),this.rsi=n.zeros([i,this.simplexOrder-1,this.simplexOrder-1]),null==s){let t=null,s=!1;if(null!=e.pos)if(Array.isArray(e.pos))t=n.tensor(e.pos),s=!0;else if(t=e.pos,null==t.ptr)throw new Error("invalid pos");this.wasmInstance.exports.rsi_of_pos(this.numVertices,t.ptr,i,this.indices.ptr,this.rsi.ptr),s&&t.dispose()}else this.rsi.set(s);null!=this.mu&&this.mu.dispose(),this.mu=n.zeros([i]),this.mu.fill_(Math.fround(500)),null!=this.lambda&&this.lambda.dispose(),this.lambda=n.zeros([i]),this.lambda.fill_(Math.fround(50))}dispose(){null!=this.indices&&(this.indices.free(),this.indices=null),null!=this.rsi&&(this.rsi.dispose(),this.rsi=null),null!=this.mu&&(this.mu.dispose(),this.mu=null),null!=this.lambda&&(this.lambda.dispose(),this.lambda=null)}};var re=class{constructor(e={}){let t;if(null==e.ten){if(null==e.wasmInstance)throw new Error("wasmInstance required");t=new ee.Engine({wasmInstance:e.wasmInstance}),this.ten=t}else t=e.ten,this.ten=t;this.h=.033,this.g=9.8,this.spaceDim=e.spaceDim??2,this.vertices=new te({ten:this.ten,vertexMass:e.vertexMass,spaceDim:this.spaceDim}),this.muscles=new se({ten:this.ten}),this.triangles=new ie({ten:this.ten,simplexOrder:this.spaceDim+1}),this.friction={k:Math.fround(300)},this.collision={k:Math.fround(14e3)}}set fixedVertexId(e){throw new Error("System.fixedVertexId setter is deprecated, use System.vertices.fixedVertexId instead")}get fixedVertexId(){throw new Error("System.fixedVertexId getter is deprecated, use System.vertices.fixedVertexId instead")}get wasmInstance(){return this.ten.wasmInstance}get memoryManager(){return this.ten.mgr}get vertexMass(){return this.vertices.vertexMass}get rsi(){return this.triangles.rsi}set rsi(e){this.triangles.rsi=e}get k(){return this.muscles.k}set k(e){this.muscles.k=e}get pos0(){return this.vertices.pos}get vel0(){return this.vertices.vel0}get pos(){return this.vertices.pos}get vel(){return this.vertices.vel}get numVertices(){return this.vertices.numVertices}get numTriangles(){return this.triangles.numTriangles}get numMuscles(){return this.muscles.numMuscles}get a(){return this.muscles.a}set a(e){this.muscles.a=e}get l0(){return this.muscles.l0}set l0(e){this.muscles.l0=e}setVertices(e){this.vertices.set(e)}setMuscles(e={}){this.muscles.set({...e,pos:e.pos??this.pos0})}setTriangles(e={}){this.triangles.set({...e,pos:e.pos??this.pos0})}getMusclesArray(){if(0==this.numMuscles)return[];const e=this.numMuscles,t=this.muscles.indices.u32(),s=[];for(let i=0;i<e;i++){const e=2*i;s.push([t[e],t[e+1]])}return s}getTrianglesArray(){if(0==this.numTriangles)return[];const e=this.numTriangles,t=this.triangles.indices.u32(),s=[];for(let i=0;i<e;i++){const e=3*i;s.push([t[e],t[e+1],t[e+2]])}return s}set(e){this.setVertices(e.pos),this.setMuscles({indices:e.muscles??[],l0:e.musclesL0,k:e.musclesK}),this.setTriangles({indices:e.triangles??[],rsi:e.trianglesRsi})}toStepArgs(){return[this.spaceDim,this.g,this.h,...this.vertices.toStepArgs(),...this.muscles.toStepArgs(),...this.triangles.toStepArgs(),this.friction.k,this.collision.k]}step(){const e=this.toStepArgs();this.wasmInstance.exports.backward_euler_update(...e),0!=this.numVertices&&(this.vertices.pos0.slot.f32().set(this.vertices.pos1.slot.f32()),this.vertices.vel0.slot.f32().set(this.vertices.vel1.slot.f32()))}dispose(){this.vertices.dispose(),this.muscles.dispose(),this.triangles.dispose()}};function ne(e){return[e[0],e[1]]}function oe(e,t){e[0]*=t,e[1]*=t}function le(e){return e[0]*e[0]+e[1]*e[1]}function he(e){return Math.sqrt(le(e))}function ae(e){const t=he(e);0!==t&&oe(e,1/t)}var de={clone:ne,add:function(e,t){return[e[0]+t[0],e[1]+t[1]]},add_:function(e,t){e[0]+=t[0],e[1]+=t[1]},mulScalar_:oe,mulScalar:function(e,t){const s=ne(e);return oe(s,t),s},sub:function(e,t){return[e[0]-t[0],e[1]-t[1]]},quadrance:le,norm:he,normalize:function(e){const t=[...e];return ae(t),t},normalize_:ae,dot:function(e,t){return e[0]*t[0]+e[1]*t[1]}};class ce{constructor(e,t,s,i){this.m00=e,this.m01=t,this.m10=s,this.m11=i}get(e,t){return this[`m${e}${t}`]}set(e,t,s,i){this.m00=e,this.m01=t,this.m10=s,this.m11=i}toArray(){return[[this.m00,this.m01],[this.m10,this.m11]]}negate(){return new ce(-this.m00,-this.m01,-this.m10,-this.m11)}apply(e){return[this.m00*e[0]+this.m01*e[1],this.m10*e[0]+this.m11*e[1]]}det(){return this.m00*this.m11-this.m10*this.m01}inv(){const e=this.det();return new ce(this.m11/e,-this.m01/e,-this.m10/e,this.m00/e)}mm(e){const t=this.m00,s=this.m01,i=this.m10,r=this.m11,n=e.m00,o=e.m01,l=e.m10,h=e.m11;return new ce(t*n+s*l,t*o+s*h,i*n+r*l,i*o+r*h)}t(){return new ce(this.m00,this.m10,this.m01,this.m11)}static fromArray(e){return new ce(e[0][0],e[0][1],e[1][0],e[1][1])}}var ue=ce;const me=ue,pe=de;class ge{constructor(){this.translation=[0,0],this.linear=new me(1,0,0,1)}inferScale(){return this.linear.m00}apply(e){return pe.add(this.linear.apply(e),this.translation)}inv(){const e=new ge;return e.linear=this.linear.inv(),e.translation=e.linear.negate().apply(this.translation),e}toColumnMajorArray(){return[this.linear.get(0,0),this.linear.get(1,0),this.linear.get(0,1),this.linear.get(1,1),this.translation[0],this.translation[1]]}}var fe=ge;var ye={Vec2:de,Matrix2x2:ue,Transform2d:fe,AABB:class{constructor(e={}){if(null==e.x0)throw new Error("x0 required");if(null==e.y0)throw new Error("y0 required");this._x0=e.x0,this._y0=e.y0;let t=null;if(null!=e.width)t=this._x0+e.width;else{if(null==e.x1)throw new Error("x1 required");t=e.x1}this._x1=t;let s=null;if(null!=e.height)s=this._y0+e.height;else{if(null==e.y1)throw new Error("y1 required");s=e.y1}this._y1=s}get x0(){return this._x0}get x1(){return this._x1}get y0(){return this._y0}get y1(){return this._y1}get width(){return this._x1-this._x0}get height(){return this._y1-this._y0}get center(){return[.5*(this.x0+this.x1),.5*(this.y0+this.y1)]}}};const we=ye;var ve=class{constructor(){this.transform=new we.Transform2d}domToWorldSpace(e){if(!Array.isArray(e))throw new Error("array expected, found "+typeof e);if(2!=e.length)throw new Error(`array with 2 elements expected, found ${e.length}`);return this.transform.inv().apply(e)}inferScale(){return this.transform.inferScale()}center(e={}){let t=e.viewportWidth,s=e.viewportHeight;const i=e.renderer;if((null==t||null==s)&&null==i)throw new Error("renderer required");if(null!=i&&(t=i.width,s=i.height),null==t)throw new Error("viewportWidth required");if(null==s)throw new Error("viewportHeight required");let r,n=e.zoom??1;if(null!=e.worldWidth&&(n=t/e.worldWidth),this.transform.linear=new we.Matrix2x2(n,0,0,-n),null!=e.worldCenter){const i=e.worldCenter;r=[.5*t-i[0]*n,.5*s+i[1]*n]}else r=[.5*t,.5*s];this.transform.translation=r}};var xe=class{constructor(){}renderPoint(e={}){const t=e.ctx,s=e.p;t.beginPath(),t.arc(s[0],s[1],3,0,2*Math.PI),t.fill()}};var Ee=class{constructor(){}renderLine(e={}){const t=e.ctx,s=e.a,i=e.b;t.beginPath(),t.strokeStyle="red",t.lineWidth=5,t.moveTo(s[0],s[1]),t.lineTo(i[0],i[1]),t.closePath(),t.stroke()}};var be={PointShader:xe,LineShader:Ee,TriangleShader:class{constructor(){}renderTriangle(e={}){const t=e.ctx,s=e.a,i=e.b,r=e.c;t.save(),t.beginPath(),t.strokeStyle="black",t.moveTo(s[0],s[1]),t.lineTo(i[0],i[1]),t.lineTo(r[0],r[1]),t.closePath(),t.stroke(),t.restore()}}};const Se=ye,Ce=be;var Ve=class{constructor(e={}){this.scene=e.scene,this.id=e.id,this.x=[],this.triangles=[],this.lines=[],this.pointShader=new Ce.PointShader({}),this.lineShader=new Ce.LineShader({}),this.triangleShader=new Ce.TriangleShader({}),this.customAttributes={}}get pos(){return this.x}set pos(e){this.x=e}numVertices(){return this.pos.length}numTriangles(){return this.triangles.length}numLines(){return this.lines.length}setCustomAttribute(e,t){this.customAttributes[e]=t}getCustomAttribute(e){return this.customAttributes[e]}computeAABB(){let e=null,t=null,s=null,i=null;return this.pos.forEach((r=>{const n=r[0],o=r[1];(null==e||n<e)&&(e=n),(null==t||n>t)&&(t=n),(null==s||o<s)&&(s=o),(null==i||o>i)&&(i=o)})),new Se.AABB({x0:e,y0:s,x1:t,y1:i})}computeCenter(){const e=this.pos.length;if(0==e)throw new Error("no vertices to compute center");let t=[0,0];for(let s=0;s<e;s++){const e=this.pos[s];Se.Vec2.add_(t,e)}return Se.Vec2.mulScalar_(t,1/e),t}};const Ae=Ve;var Me=class{constructor(e={}){const t=e.headless??!1;if(this.headless=t,!t){const e=document.createElement("canvas");this.domElement=e,this.ctx=e.getContext("2d")}this.setSize({width:200,height:200})}setSize(e){const t=e.width;if(null==t)throw new Error("width required to setSize");const s=e.height;if(null==s)throw new Error("height required to setSize");let i=e.viewportWidth;null==i&&(i=t);let r=e.viewportHeight;if(null==r&&(r=s),this.width=t,this.height=s,this.viewportWidth=i,this.viewportHeight=r,!this.headless){const e=this.domElement;e.width=i,e.height=r,e.style.width=`${t}px`,e.style.height=`${s}px`}}renderPoint(e,t,s,i,r){const n=this.ctx;let o;if(!(t instanceof Ae))throw new Error("invalid mesh");o=t.pos[i];const l=s.transform.apply(o);n.save(),t.pointShader.renderPoint({ctx:n,renderer:e,mesh:t,camera:s,id:i,p:l,custom:r}),n.restore()}renderLine(e,t,s,i,r){const n=this.ctx,o=t.lines[i],l=s.transform.apply(t.pos[o[0]]),h=s.transform.apply(t.pos[o[1]]);n.save(),t.lineShader.renderLine({ctx:n,renderer:e,mesh:t,camera:s,id:i,a:l,b:h,custom:r}),n.restore()}renderTriangle(e,t,s,i,r){const n=this.ctx,o=t.triangles[i],l=o[0],h=o[1],a=o[2];let d,c,u;if(t.pos instanceof Float32Array){const e=2;d=[t.pos[l*e],t.pos[l*e+1]],c=[t.pos[h*e],t.pos[h*e+1]],u=[t.pos[a*e],t.pos[a*e+1]]}else d=t.pos[l],c=t.pos[h],u=t.pos[a];const m=s.transform.apply(d),p=s.transform.apply(c),g=s.transform.apply(u);n.save(),t.triangleShader.renderTriangle({ctx:n,renderer:e,mesh:t,camera:s,id:i,a:m,b:p,c:g,custom:r}),n.restore()}renderMesh(e,t,s,i={}){const r=t.sortedElements;if(null==r){for(let r=0;r<t.triangles.length;r++)this.renderTriangle(e,t,s,r,i);for(let r=0;r<t.lines.length;r++)this.renderLine(e,t,s,r,i);for(let r=0;r<t.pos.length;r++)this.renderPoint(e,t,s,r,i)}else r.forEach((r=>{if(null==r.order)throw new Error(`invalid element, order not defined ${r}`);if(1==r.order)this.renderPoint(e,t,s,r.id,i);else if(2==r.order)this.renderLine(e,t,s,r.id,i);else{if(3!=r.order)throw new Error(`invalid element ${r}`);this.renderTriangle(e,t,s,r.id,i)}}))}render(e,t,s={}){this.ctx.clearRect(0,0,this.viewportWidth,this.viewportHeight),e.meshes.forEach((e=>{this.renderMesh(this,e,t,s)}))}};const Ie=Ve;var Te={Camera:ve,Mesh:Ve,Renderer:Me,Scene:class{constructor(){this.meshes=new Map}clean(){this.meshes=new Map}numMeshes(){return this.meshes.size}addMesh(){const e=this.meshes.size,t=new Ie({scene:this,id:e});return this.meshes.set(e,t),t}}};var Le={computeDomCursor:function(e,t){let s,i;if(null==e.touches)s=e.clientX,i=e.clientY;else{if(0==e.touches.length)return null;const t=e.touches[0];s=t.clientX,i=t.clientY}let r=new DOMMatrix,n=t;for(;null!=n;){const e=window.getComputedStyle(n);r=new DOMMatrix(e.transform).multiply(r),n=n.parentElement}const o=r.inverse(),l=new DOMPointReadOnly(s,i).matrixTransform(o),h=t.getBoundingClientRect(),a=new DOMPointReadOnly(h.left,h.top).matrixTransform(o);return[l.x-a.x,l.y-a.y]}};const _e=Le;var ze={cursorUtils:Le,DragBehavior:class{constructor(e={}){this._dragging=!1,this.onDomCursorDown=e.onDomCursorDown,this.onDragProgress=e.onDragProgress,this.onDomCursorUp=e.onDomCursorUp,this.domElement=null}beginDrag(){this._dragging=!0}endDrag(){this._dragging=!1}dragging(){return this._dragging}domCursorDown(e,t){null!=this.onDomCursorDown&&this.onDomCursorDown(e,t)}domCursorMove(e,t){this.dragging()&&(t.preventDefault(),null!=this.onDragProgress&&this.onDragProgress(e,t))}domCursorUp(e,t){this.endDrag(),null!=this.onDomCursorUp&&this.onDomCursorUp(e,t)}linkToDom(e,t=null){if(null!=this.domElement)throw new Error("already linked to DOM");this.domElement=e;const s=t=>{const s=_e.computeDomCursor(t,e);this.domCursorDown(s,t)};e.addEventListener("mousedown",s,{passive:!1}),e.addEventListener("touchstart",s,{passive:!1});const i=t=>{const s=_e.computeDomCursor(t,e);this.domCursorMove(s,t)};null==t&&(t=e),t.addEventListener("mousemove",i,{passive:!1}),t.addEventListener("touchmove",i,{passive:!1});const r=t=>{const s=_e.computeDomCursor(t,e);this.domCursorUp(s,t)};window.addEventListener("mouseup",r),window.addEventListener("touchend",r),window.addEventListener("touchcancel",r)}}};class ke{constructor(e={}){if(null==e.scene)throw new Error("scene required");const t=null==e.color?"rgba(0, 0, 0, 0.30)":e.color,s=this.mesh=e.scene.addMesh();this.set(e),s.setCustomAttribute("translation",[0,0]),s.pointShader.renderPoint=()=>{},s.lineShader.renderLine=ke.makeGridLineShader({color:t})}get numVertices(){return this.mesh.x.length}get numLines(){return this.mesh.lines.length}set(e={}){const t=null==e.cellSize?1:e.cellSize,s=null==e.innerCells?3:e.innerCells,i=null==e.rows?3:e.rows,r=null==e.cols?4:e.cols,n=null==e.x0?-2:e.x0,o=null==e.y0?0:e.y0,l=null==e.primaryLineWidth?.03:e.primaryLineWidth,h=null==e.secondaryLineWidth?.008:e.secondaryLineWidth,a=this.mesh,{x:d,lineIndices:c,lineWidths:u}=function(e={}){const t=null==e.cellSize?1:e.cellSize,s=null==e.innerCells?3:e.innerCells,i=null==e.rows?3:e.rows,r=null==e.cols?4:e.cols,n=null==e.x0?-2:e.x0,o=null==e.y0?0:e.y0,l=null==e.primaryLineWidth?.022:e.primaryLineWidth,h=null==e.secondaryLineWidth?.008:e.secondaryLineWidth,a=[],d=[],c=[],u=o+i*t,m=n+r*t;function p(e,t){for(let i=0;i<e+1;i++){const r=i==e?1:s;for(let e=0;e<r;e++){const s=2*d.length;t(i,e,r,a),d.push([s,s+1]),0==e?c.push(l):c.push(h)}}}return p(i,((e,s,i,r)=>{const l=s/i,h=(o+e*t)*(1-l)+(o+(e+1)*t)*l;r.push([n,h]),r.push([m,h])})),p(r,((e,s,i,r)=>{const l=s/i,h=(n+e*t)*(1-l)+(n+(e+1)*t)*l;r.push([h,o]),r.push([h,u])})),{x:a,lineIndices:d,lineWidths:c}}({cellSize:t,innerCells:s,rows:i,cols:r,x0:n,y0:o,primaryLineWidth:l,secondaryLineWidth:h});a.pos=d,a.lines=c,a.setCustomAttribute("lineWidths",u)}static makeGridLineShader(e={}){const t=null==e.color?"black":e.color;return e=>{const s=e.ctx,i=e.a,r=e.b,n=e.camera,o=e.mesh,l=n.inferScale();s.beginPath(),s.strokeStyle=t;const h=o.getCustomAttribute("lineWidths");if(null==h)throw new Error("custom attribute lineWidths missing");const a=h[e.id],d=o.getCustomAttribute("translation"),c=[l*d[0],l*d[1]];s.lineWidth=a*l,s.moveTo(i[0]+c[0],i[1]+c[1]),s.lineTo(r[0]+c[0],r[1]+c[1]),s.closePath(),s.stroke()}}}var De=ke;var Pe={Grid:De,Background:class{constructor(e={}){if(null==e.scene)throw new Error("scene required");const t=this.mesh=e.scene.addMesh();t.pos=[[0,0]];const s=null==e.color1?"#fcfcfc":e.color1,i=null==e.color2?"#d7d8d8":e.color2;t.pointShader.renderPoint=(e={})=>{const t=e.renderer.width,r=e.renderer.height,n=e.ctx,o=n.createRadialGradient(.5*t,.5*r,.05*t,.5*t,.5*r,.5*t);o.addColorStop(0,s),o.addColorStop(1,i),n.fillStyle=o,n.fillRect(0,0,t,r)}}}};var qe=class{constructor(e,t){if(null==e)throw new Error("id required to create simplex");this.order=t.length,this.id=e,this.vertexIds=t}};const $e=qe;function We(e){return e.sort(),e.join("_")}var Be=class{constructor(e={}){if(null==e.order)throw new Error("order required");this.order=e.order,this.simplicesByHash=new Map}forEach(e){this.simplicesByHash.forEach(e)}size(){return this.simplicesByHash.size}has(e){return this.simplicesByHash.has(We(e.vertexIds))}add(e,t){let s=null;if(Array.isArray(e)){if(null==t)throw new Error("id required");s=e,e=new $e(t,s)}else{if(s=e.vertexIds,null==s)throw new Error(`vertexIds required ${e}`);t=e.id}if(s.length!=this.order)throw new Error(`expected ${this.order} vertices, found ${s.length}`);const i=We(s);return this.simplicesByHash.set(i,e),e}};const Fe=Be;const je=Be,Re=class{constructor(e){this.id=e,this.edges=new Fe({order:2}),this.triangles=new Fe({order:3})}addTriangle(e,t){this.triangles.add(e,t)}addEdge(e,t){this.edges.add(e,t)}};var He=class{constructor(e={}){this.vertices=new Map,this.edges=new je({order:2}),this.triangles=new je({order:3});(e.edges??[]).forEach(((e,t)=>{this.addEdge(t,e)}));(e.triangles??[]).forEach(((e,t)=>{this.addTriangle(t,e)}))}numVertices(){return this.vertices.size}numEdges(){return this.edges.size()}numTriangles(){return this.triangles.size()}getVertexById(e,t=!1){let s=this.vertices.get(e);return null==s&&t&&(s=new Re(e),this.vertices.set(e,s)),s}addEdge(e,t){const s=this.edges.add(t,e);return t.forEach((e=>{this.getVertexById(e,!0).addEdge(s)})),s}addTriangle(e,t){const s=this.triangles.add(t,e);return t.forEach((e=>{this.getVertexById(e,!0).addTriangle(s)})),s}};const Oe=He,Ne=Be;var Ue={math:ye,ui:ze,shaders:be,background:Pe,sorted:{makeSortedElements:function(e={}){if(null==e.sortedVertexIds)throw new Error("sortedVertexIds required");if(null==e.triangles)throw new Error("triangles required");if(null==e.edges)throw new Error("edges required");const t=e.sortedVertexIds,s=new Map;t.forEach(((e,t)=>{s.set(e,t)}));const i=new Oe({triangles:e.triangles}),r=new Oe({edges:e.edges}),n=[],o=new Ne({order:3}),l=new Ne({order:2});return t.forEach((e=>{const t=i.getVertexById(e,!0).triangles,h=r.getVertexById(e,!0).edges,a=[];t.forEach((e=>{a.push(e)})),h.forEach((e=>{a.push(e)})),a.sort(((e,t)=>{const i=e.vertexIds.map((e=>s.get(e))),r=t.vertexIds.map((e=>s.get(e))),n=Math.max(...i),o=Math.max(...r);return n<o?1:n==o?0:-1})),a.forEach((e=>{if(2==e.order){const t=e;l.has(t)||(n.push(t),l.add(t))}else{const t=e;o.has(t)||(n.push(t),o.add(t))}})),n.push({order:1,id:e})})),n},MeshTopology:He,Simplex:qe,Simplices:Be},core:Te,Renderer:Te.Renderer,Camera:Te.Camera,Scene:Te.Scene};var Xe=class{constructor(e={}){this.targetCenterX=null,this.currentCenterX=null,this.active=!0,this.visibleWorldWidth=e.visibleWorldWidth??3.8,this.targetCenterY=e.targetCenterY??1,this.offsetX=e.offsetX??0,this.fullGrid=!1,this.centeringSpeedFactor=.5}step(e={}){if(!this.active)return;const t=e.renderer,s=e.camera,i=e.mesh,r=e.floor,n=e.grid;let o=[0,0];i.pos.length>0&&(o=i.computeCenter());const l=o[0]+this.offsetX;isNaN(l)||(this.targetCenterX=l),null==this.currentCenterX?this.currentCenterX=this.targetCenterX:this.currentCenterX+=(this.targetCenterX-this.currentCenterX)*this.centeringSpeedFactor;const h=[this.currentCenterX,this.targetCenterY];s.center({worldCenter:h,worldWidth:this.visibleWorldWidth,viewportWidth:t.width,viewportHeight:t.height});const a=s.domToWorldSpace([t.width,0]),d=s.domToWorldSpace([0,t.height]),[c,u]=d,m=Math.floor(c)-1;let p=Math.floor(u);this.fullGrid||p<0&&(p=0);const[g,f]=a,y=g,w=y-m,v=f-p,x=Math.ceil(v)+1,E=Math.ceil(w)+1;n.set({x0:m,y0:p,rows:x,cols:E,innerCells:n.innerCells,primaryLineWidth:n.primaryLineWidth,secondaryLineWidth:n.secondaryLineWidth}),r.mesh.pos=[[m,0],[y,0]]}};class Ge{constructor(e={}){if(null==e.scene)throw new Error("scene required");const t=this.scene=e.scene,s=this.mesh=t.addMesh();s.pos=[[-10,0],[10,0]],s.lines=[[0,1]],s.lineShader.renderLine=Ge.makeFloorLineShaderFunction({width:e.width,color:e.color}),s.pointShader.renderPoint=()=>{},s.setCustomAttribute("translation",[0,0])}static makeFloorLineShaderFunction(e={}){const t=e.width??.055,s=e.color??"black";return e=>{const i=e.ctx,r=e.a,n=e.b,o=e.camera,l=e.mesh,h=o.inferScale(),a=l.getCustomAttribute("translation"),d=[h*a[0],h*a[1]];i.strokeStyle=s,i.lineWidth=h*t,i.beginPath(),i.moveTo(r[0]+d[0],r[1]+d[1]),i.lineTo(n[0]+d[0],n[1]+d[1]),i.stroke()}}}var Ye=Ge;const Ze=Ue;var Je=class{constructor(e={}){this.system=e.system,this.renderVertexIds=e.renderVertexIds??!1,this.radius=e.radius??.028,this.borderColor=e.borderColor??"black",this.fillColor=e.fillColor??"white",this.borderWidth=e.borderWidth??.023}renderVertex(e={}){const t=this.radius,s=this.borderColor,i=this.fillColor,r=this.borderWidth,n=e.ctx,o=e.p,l=e.camera.inferScale();if(function(e,t,s,i,r,n,o){const l=(i+.5*r)*t;e.fillStyle=o,e.beginPath(),e.arc(s[0],s[1],l,0,2*Math.PI),e.fill(),e.lineWidth=r*t,e.strokeStyle=n,e.stroke()}(n,l,o,t,r,s,i),this.renderVertexIds){n.beginPath(),n.fillStyle="rgba(255, 255, 255, 0.8)",n.arc(o[0],o[1],.1*l,0,2*Math.PI),n.fill();const t=Math.floor(.15*l);n.font=`${t}px monospace`,n.fillStyle="black",n.textAlign="center",n.textBaseline="middle",n.fillText(e.id,o[0],o[1])}}getVertexPos(e){const t=this.system.pos.slot.f32(),s=e*this.system.spaceDim;return[t[s],t[s+1]]}get numVertices(){return this.system.numVertices}hitTest(e,t=.31){const s=this.numVertices;if(0==s)return null;let i=null,r=1/0;const n=t*t;for(let t=0;t<s;t++){const s=this.getVertexPos(t),o=Ze.math.Vec2.sub(s,e),l=Ze.math.Vec2.quadrance(o);l<n&&l<r&&(i=t,r=l)}return i}setVertexPos(e,t){if(null==e)throw new Error("vertex id required");const s=this.system.pos.slot.f32(),i=2*e;s[i]=t[0],s[i+1]=t[1]}setVertexVel(e,t){const s=this.system.vel.slot.f32(),i=2*e;s[i]=t[0],s[i+1]=t[1]}};var Ke=class{constructor(e={}){this.system=e.system}makeEdgesFromTriangles(e){const t=new Map;function s(e,s){const i=((r=[e,s]).sort(),r.join("_"));var r;t.set(i,[e,s])}return e.forEach((e=>{s(e[0],e[1]),s(e[1],e[2]),s(e[0],e[2])})),Array.from(t.values())}makeLineShaderFunction(e={}){const t=e.activeMuscleColor??[255,0,0],s=e.inactiveMuscleColor??[0,0,255],i=e.borderColor??"black";return(e={})=>{const r=e.ctx,n=e.a,o=e.b,l=e.camera.inferScale(),h=e.mesh.getCustomAttribute("lineIdToMuscleId");let a=null;if(null!=h&&(a=h[e.id]),null==a){!function(e,t,s,i,r,n){e.beginPath(),e.lineJoin="round",e.lineCap="round",e.strokeStyle=n,e.lineWidth=r*t,e.moveTo(s[0],s[1]),e.lineTo(i[0],i[1]),e.closePath(),e.stroke()}(r,l,n,o,.029,i)}else{const h=t,d=s,c=.065,u=.017,m="muscleIntensity",p=e.mesh.getCustomAttribute(m);if(null==p)throw new Error(`muscle intensity attribute (${m}) not found, call setCustomAttribute("${m}", value) before rendering.`);if(!Array.isArray(p))throw new Error("muscle intensity attribute must be an array with values for each fiber, found "+typeof p);!function(e,t,s,i,r,n,o,l,h,a){e.beginPath(),e.lineCap="butt",e.strokeStyle=l,e.lineWidth=(n+2*o)*t,e.moveTo(s[0],s[1]),e.lineTo(i[0],i[1]),e.stroke(),e.beginPath();const d=(1-r)*h[0]+r*a[0],c=(1-r)*h[1]+r*a[1],u=(1-r)*h[2]+r*a[2];e.strokeStyle=`rgb(${d}, ${c}, ${u})`,e.lineWidth=n*t,e.moveTo(s[0],s[1]),e.lineTo(i[0],i[1]),e.stroke()}(r,l,n,o,p[a],c,u,i,h,d)}}}};var Qe=class{constructor(e={}){this.fillColor=e.fillColor??"white"}renderTriangle(e={}){const t=e.ctx,s=e.a,i=e.b,r=e.c;t.beginPath(),t.fillStyle=this.fillColor,t.moveTo(...s),t.lineTo(...i),t.lineTo(...r),t.closePath(),t.fill()}};const et=Ue,tt=Xe,st=Ye,it=Je,rt=Ke,nt=Qe;function ot(e){return e.sort(),e.join("_")}function lt(e){if(7!=e.length)throw new Error(`invalid hex string ${e}`);if("#"!=e[0])throw new Error(`invalid hex string ${e}, expected #, found ${e[0]}`);e=e.substring(1);return[parseInt(e.substring(0,2),16),parseInt(e.substring(2,4),16),parseInt(e.substring(4,6),16)]}var ht=class{constructor(e={}){if(null==e.system)throw new Error("system required");this.system=e.system;const t=e.sortedVertexIds;this.sortedVertexIds=t,null!=e.vertexDepths&&this.setSortedVertexIdsFromVertexDepths(e.vertexDepths);const s=e.headless??!1,i=e.borderColor??"black",r=i,n=e.fillColor??"white",o=e.gridColor??"#acadad";this.vertices=new it({system:this.system,renderVertexIds:e.renderVertexIds??!1,borderColor:i,fillColor:n}),this.lines=new rt({system:this.system});const l=new et.Renderer({headless:s});this.renderer=l,this.domElement=l.domElement,this.setSize({width:e.width??400,height:e.height??400});const h=new et.Scene;this.scene=h;const a=new et.Camera;this.camera=a;let d,c,u=e.activeMuscleColor??[255,0,0],m=e.inactiveMuscleColor??[250,190,190];"string"==typeof u&&(u=lt(u)),"string"==typeof m&&(m=lt(m)),null!=e.backgroundColor?(d=e.backgroundColor,c=e.backgroundColor):(d=e.backgroundCenterColor??"#fcfcfc",c=e.backgroundOuterColor??"#d7d8d8"),new et.background.Background({scene:h,color1:d,color2:c});const p=this.grid=new et.background.Grid({scene:h,x0:-3,y0:0,rows:4,cols:10,innerCells:2,primaryLineWidth:.022,secondaryLineWidth:.005,color:o});p.innerCells=2,p.primaryLineWidth=.022,p.secondaryLineWidth=.005,this.floor=new st({scene:h,color:r});const g=h.addMesh();this.mesh=g,g.pointShader.renderPoint=e=>{this.vertices.renderVertex(e)},this.triangleRenderer=new nt({fillColor:n}),g.triangleShader.renderTriangle=(e={})=>{this.triangleRenderer.renderTriangle(e)},g.lineShader.renderLine=this.lines.makeLineShaderFunction({activeMuscleColor:u,inactiveMuscleColor:m,borderColor:i});if(e.draggable??!0){const t=this.dragBehavior=new et.ui.DragBehavior({onDomCursorDown:(e,s)=>{if("button"in s&&0!=s.button)return;const i=this.system,r=a.domToWorldSpace(e),n=this.hitTestVertex(r);null!=n&&(s.preventDefault(),this.fixVertex(n),t.beginDrag(),this.setVertexPos(i.vertices.fixedVertexId,[r[0],Math.max(0,r[1])]))},onDragProgress:e=>{const t=this.system,s=a.domToWorldSpace(e);this.setVertexPos(t.vertices.fixedVertexId,[s[0],Math.max(0,s[1])])},onDomCursorUp:()=>{this.freeVertex()}});if(!s){const s=e.domElementForMoveEvents??null;t.linkToDom(l.domElement,s)}}this.tracker=new tt}setSortedVertexIdsFromVertexDepths(e){if(e.length!=this.system.numVertices)throw new Error(`invalid size for depths, found ${e.length}, expected ${this.system.numVertices}`);const t=e.map(((e,t)=>({depth:e,index:t})));t.sort(((e,t)=>t.depth-e.depth));const s=t.map((e=>e.index));this.sortedVertexIds=s}setSize(e={}){this.renderer.setSize({width:e.width,height:e.height})}render(){(null==this.needsMeshUpdate||this.needsMeshUpdate)&&(this._updateMesh({triangles:this.system.getTrianglesArray(),muscles:this.system.getMusclesArray()}),this.needsMeshUpdate=!1);const e=this.renderer,t=this.scene,s=this.camera,i=this.mesh;this._updateFromSystem(),null!=this.dragBehavior&&this.dragBehavior.dragging()||this.tracker.step({mesh:i,camera:s,floor:this.floor,grid:this.grid,renderer:this.renderer}),e.render(t,s)}_updateMesh(e){const t=this.mesh,s=this.system.numVertices;if(!Number.isInteger(s)||s<0)throw new Error(`invalid number of vertices ${s}`);null!=e.pos&&(t.pos=e.pos),t.triangles=e.triangles;const i=this.lines;t.lines=i.makeEdgesFromTriangles(e.triangles),Array.prototype.push.apply(t.lines,e.muscles);const r=new Map;e.muscles.forEach(((e,t)=>{r.set(ot(e),t)}));const n=[];t.setCustomAttribute("lineIdToMuscleId",n),t.lines.forEach((e=>{const t=ot(e),s=r.get(t);n.push(s)}));let o=this.sortedVertexIds;if(null==o){o=[];for(let e=0;e<s;e++)o.push(e)}if(o.length!=s)throw new Error(`invalid size for sortedVertexIds, found ${o.length}, expected ${s}`);t.sortedElements=et.sorted.makeSortedElements({sortedVertexIds:o,triangles:t.triangles,edges:t.lines});const l=[],h=this.system.numMuscles;for(let e=0;e<h;e++)l.push(1);t.setCustomAttribute("muscleIntensity",l)}_updateFromSystem(){this._updateVertexPositionsFromSystem(),this._updateMuscleIntensityFromSystem()}_updateVertexPositionsFromSystem(){const e=this.mesh,t=this.system;if(0==t.numVertices)e.pos=[];else{const s=t.pos.toArray();e.pos=s}}_updateMuscleIntensityFromSystem(){const e=this.mesh,t=this.system,s=t.numMuscles;if(!Number.isInteger(s)||s<0)throw new Error(`invalid number of muscles ${s}`);let i=[];if(s>0)if(t.a){const e=t.a.slot.f32();for(let t=0;t<s;t++)i.push(e[t])}else i=new Array(s).fill(1);e.setCustomAttribute("muscleIntensity",i)}hitTestVertex(e,t=.31){return this.vertices.hitTest(e,t)}setVertexPos(e,t){this.vertices.setVertexPos(e,t)}setVertexVel(e,t){this.vertices.setVertexVel(e,t)}fixVertex(e){const t=this.system;this.setVertexVel(e,[0,0]),null==e&&(e=-1),t.vertices.fixVertex(e)}freeVertex(){this.system.vertices.freeVertex()}},at={SystemViewport:ht,VertexRenderer:Je,LineRenderer:Ke,TriangleRenderer:Qe,Tracker:Xe};function dt(e,t){const s=1-Math.random(),i=Math.random();return e+Math.sqrt(-2*Math.log(s))*Math.cos(2*Math.PI*i)*t}var ct=class{constructor(e={}){if(null==e.system)throw new Error("system required to create policy");this.system=e.system,this.ten=this.system.ten,this.active=e.active??!1,this.stochastic=e.stochastic??!1,this.stdDev=e.stdDev??.05;const t=this.system,s=this.ten,i=this.numVertices=e.numVertices??t.numVertices,r=this.numMuscles=e.numMuscles??t.numMuscles,n=t.spaceDim;this.vertexIdOffset=e.vertexIdOffset??0,this.muscleIdOffset=e.muscleIdOffset??0,this.projectedPos=s.zeros([i,n]),this.projectedVel=s.zeros([i,n]);const o=i*n*2,l=r;this.input=s.zeros([o]),this.clockwise=!1;const h=s.nn;this.model=h.Sequential(h.Linear(o,32),h.ReLU(),h.Linear(32,l),h.Tanh())}get spaceDim(){return this.system.spaceDim}step(e={}){const t=this.system,s=this.ten.wasmInstance,i=this.vertexIdOffset*this.spaceDim*4;s.exports.make_neural_policy_input(this.numVertices,t.pos.ptr+i,t.vel.ptr+i,this.centerVertexId,this.forwardVertexId,this.projectedPos.ptr,this.projectedVel.ptr,this.input.ptr,this.clockwise);const r=this.model.forward(this.input),n=this.minA,o=this.maxAbsDa,l=this.system.a,h=r.slot.f32(),a=this.numMuscles;for(let e=0;e<a;e++){let t;this.active?(t=r.get([e]),this.stochastic&&(t+=dt(0,this.stdDev))):t=1,h[e]=t}const d=e.trace;null!=d&&(d.policyInput=this.input.toArray(),d.policyOutput=r.toArray()),r.clamp_({min:-o,max:o});const c=l.slot.f32();for(let e=0;e<a;e++)c[this.muscleIdOffset+e]+=h[e];l.clamp_({min:n,max:1})}loadData(e){const t=this.model.layers[0];t.weight.set(e.fc1.weight),t.bias.set(e.fc1.bias);const s=this.model.layers[2];s.weight.set(e.fc2.weight),s.bias.set(e.fc2.bias),this.minA=e.min_a??(()=>{throw new Error("min_a required")})(),this.maxAbsDa=e.max_abs_da??(()=>{throw new Error("max_abs_da required")})(),this.centerVertexId=e.center_vertex_id??(()=>{throw new Error("center_vertex_id required")})(),this.forwardVertexId=e.forward_vertex_id??(()=>{throw new Error("forward_vertex_id required")})()}dispose(){null!=this.projectedPos&&this.projectedPos.dispose(),null!=this.projectedVel&&this.projectedVel.dispose(),null!=this.input&&this.input.dispose(),this.model.dispose()}};var ut=e({System:re,Vertices:K,mmgrten:J,SystemViewport:at.SystemViewport,mm2d:Ue,render:at,nn:{NeuralFramePolicy:ct}});class mt{constructor(e={}){const t=this.domElement=document.createElement("div");t.style.userSelect="none",t.style.webkitTapHighlightColor="transparent",t.style.padding="12px",t.style.boxSizing="content-box",t.style.cursor="pointer",t.style.borderRadius="50%",t.style.minHeight=t.style.height,t.style.margin="4px",t.style.display="flex",t.style.alignItems="center",t.style.justifyContent="center",t.style.boxShadow="0 0 8px rgba(0, 0, 0, 0.2)",t.style.padding="20px",t.style.overflow="hidden",this.initSvg(),this.setSize(40),this.setInactiveStyle()}setSize(e){const t=this.domElement;t.style.width=`${e}px`,t.style.height=`${e}px`,t.style.minHeight=`${e}px`}initSvg(){const e="white",t=document.createElementNS("http://www.w3.org/2000/svg","svg");this.svg=t,t.style.width="100%",t.setAttribute("width","198"),t.setAttribute("height","217"),t.setAttribute("viewBox","0 0 198 217"),t.setAttribute("fill","none");const s=document.createElementNS("http://www.w3.org/2000/svg","path");s.setAttribute("fill-rule","evenodd"),s.setAttribute("clip-rule","evenodd"),s.setAttribute("d","M156.5 186.309L173 178.837V161.992L152.888 150.729L130.5 162.127V194.062H120.5V155.996L148 141.996V121.915L173 109.915V86.0615H183V116.208L158 128.208V142.131L177.975 153.317L197.5 142.16V76.5834L179.133 63.0079L157 75.4829L156.5 102H146.5L147 75.4371L119.5 59.4371V22.5615H129.5V53.6859L152.039 66.7998L174.42 54.185L174.077 41.482L156.5 31.2553V48.5615H146.5V13.2817L125.974 0L105 13.3103V128.519L121 117.442V89.0615H131V122.681L105 140.681V204.221L125.975 216.725L146.5 204.249V169.562H156.5V186.309Z"),s.setAttribute("fill",e),t.appendChild(s);const i=document.createElementNS("http://www.w3.org/2000/svg","path");i.setAttribute("fill-rule","evenodd"),i.setAttribute("clip-rule","evenodd"),i.setAttribute("d","M41 30.4169L24.5 37.8885V54.7333L44.6122 65.9962L67 54.5988V22.664H77V60.7291L49.5 74.7291V94.8101L24.5 106.81V130.664H14.5V100.518L39.5 88.5178V74.5946L19.5249 63.4085L0 74.5656V140.142L18.3669 153.718L40.5 141.243L41 114.725H51L50.5 141.288L78 157.288V194.164H68V163.04L45.4606 149.926L23.0796 162.54L23.4229 175.243L41 185.47V168.164H51V203.444L71.5262 216.725L92.5 203.415V88.2068L76.5 99.2837V127.664H66.5V94.0442L92.5 76.0442V12.5043L71.525 -3.05176e-05L51 12.476V47.164H41V30.4169Z"),i.setAttribute("fill",e),t.appendChild(i),this.domElement.appendChild(t)}setActiveStyle(e=!0){e?this.domElement.style.backgroundColor="black":this.setInactiveStyle()}setInactiveStyle(){this.domElement.style.backgroundColor="rgba(1, 1, 1, 0.2)"}}class pt{constructor(e={}){if(!e.mm2d)throw new Error("mm2d required");this.mm2d=e.mm2d,this.shapeColor=e.shapeColor??"white",this.size=e.size??50,this.worldWidth=e.worldWidth??5.2,this.initContainer(),this.initRenderer(),this.initMesh(e),this.initRenderers(),this.render(),this.setActive(!1)}initContainer(){this.domElement=document.createElement("div"),this.domElement.style.borderRadius="50px",this.domElement.style.width=`${this.size}px`,this.domElement.style.height=`${this.size}px`,this.domElement.style.pointerEvents="auto"}initRenderer(){this.renderer=new this.mm2d.Renderer,this.renderer.setSize({width:this.size,height:this.size}),this.scene=new this.mm2d.Scene,this.camera=new this.mm2d.Camera,this.domElement.appendChild(this.renderer.domElement)}initMesh(e){this.mesh=this.scene.addMesh(),this.mesh.pos=e.pos||[],this.mesh.triangles=e.triangles||[]}initRenderers(){this.mesh.pointShader.renderPoint=()=>{},this.mesh.triangleShader.renderTriangle=e=>{this.renderTriangle(e)}}renderTriangle(e){const t=e.ctx,[s,i,r]=[e.a,e.b,e.c],n=e.camera.inferScale();t.beginPath(),t.lineJoin="round",t.lineCap="round",t.strokeStyle=this.shapeColor,t.lineWidth=.058*n,t.moveTo(s[0],s[1]),t.lineTo(i[0],i[1]),t.lineTo(r[0],r[1]),t.closePath(),t.stroke(),t.beginPath(),t.fillStyle=this.shapeColor,t.moveTo(s[0],s[1]),t.lineTo(i[0],i[1]),t.lineTo(r[0],r[1]),t.closePath(),t.fill()}updateMesh({pos:e,triangles:t}){e&&(this.mesh.pos=e),t&&(this.mesh.triangles=t),this.render()}setActive(e=!0){this.domElement.style.backgroundColor=e?"rgba(0, 0, 0, 1)":"rgba(0, 0, 0, 0.2)"}setColor(e){this.shapeColor=e,this.render()}render(){if(this.mesh.pos&&this.mesh.pos.length>0){const e=this.mesh.computeCenter();this.camera.center({worldCenter:e,worldWidth:this.worldWidth,viewportWidth:this.renderer.width,viewportHeight:this.renderer.height})}this.renderer.render(this.scene,this.camera)}}class gt{constructor(e={}){if(null==e.algovivo)throw new Error("algovivo required");if(this.algovivo=e.algovivo,null==e.system)throw new Error("system required");this.system=e.system,this.policy=null}get numVertices(){return this.system.numVertices}set(e={}){const t=e.mesh,s=e.policy;if(null==t)throw new Error("mesh required");this.dispose(),this.system.set(t),null!=s&&(this.policy=new this.algovivo.nn.NeuralFramePolicy({system:this.system}),this.policy.loadData(s))}dispose(){null!=this.policy&&(this.policy.dispose(),this.policy=null),this.system.dispose()}}class ft{constructor(e,t,s="data",i=[]){this.algovivo=t,this.dataRoot=s,this.currentAgent=null,this.agents=i,this.meshCache=new Map,this.policyCache=new Map,this.agentSystem=new gt({algovivo:t,system:e})}get system(){return this.agentSystem.system}get policy(){return this.agentSystem.policy}async loadMeshData(e){if(this.meshCache.has(e))return this.meshCache.get(e);const t=await fetch(`${this.dataRoot}/${e}/mesh.json`),s=await t.json();return this.meshCache.set(e,s),s}async loadPolicyData(e){if(this.policyCache.has(e))return this.policyCache.get(e);const t=await fetch(`${this.dataRoot}/${e}/policy.json`),s=await t.json();return this.policyCache.set(e,s),s}async preloadAllData(){await Promise.all(this.agents.map((e=>Promise.all([this.loadMeshData(e),this.loadPolicyData(e)]))))}async switchToAgent(e){if(this.currentAgent===e)return;const[t,s]=await Promise.all([this.loadMeshData(e),this.loadPolicyData(e)]);let i=t.pos;if(null!==this.policy&&null!=this.policy.centerVertexId){const e=this.system.vertices.getVertexPos(this.policy.centerVertexId),r=t.pos[s.center_vertex_id],n=e[0]-r[0];i=t.pos.map((e=>[e[0]+n,e[1]]))}const r=!!this.policy&&this.policy.active;return this.agentSystem.set({mesh:{pos:i,muscles:t.muscles,musclesL0:t.l0,triangles:t.triangles,trianglesRsi:t.rsi},policy:s}),this.agentSystem.policy.active=r,this.currentAgent=e,{meshData:t,policyData:s}}togglePolicy(){return!!this.policy&&(this.policy.active=!this.policy.active,this.policy.active)}getCurrentAgent(){return this.currentAgent}isActive(){return this.policy&&this.policy.active}}class yt{constructor({system:e,algovivo:t,dataRoot:s="data",agentNames:i=[],headless:r=!1}){this.system=e,this.agentManager=new ft(e,t,s,i),this.viewport=null,this.algovivo=t,this.headless=r,r||(this.initContainer(),this.initMiniButtons(t))}initContainer(){this.domElement=document.createElement("div"),this.domElement.style.position="relative",this.domElement.style.display="inline-block",this.domElement.style.borderRadius="10px",this.domElement.style.border="2px solid #c9c9c9",this.domElement.style.boxShadow="0 0 10px rgba(0, 0, 0, 0.1)",this.domElement.style.overflow="hidden",this.initResponsiveSize()}initResponsiveSize(){const e=window.matchMedia("(max-width: 410px)"),t=()=>{const t=e.matches?{width:300,height:350}:{width:400,height:400};this.domElement.style.width=`${t.width}px`,this.domElement.style.height=`${t.height}px`,this.viewport&&this.viewport.setSize(t)};e.addEventListener("change",t),t()}initMiniButtons(e){this.miniContainer=document.createElement("div"),this.miniContainer.style.position="absolute",this.miniContainer.style.top="14px",this.miniContainer.style.right="14px",this.miniContainer.style.zIndex="10",this.miniContainer.style.display="flex",this.miniContainer.style.flexDirection="column",this.miniContainer.style.gap="8px",this.miniButtons={},this.agentManager.agents.forEach((t=>{this.miniButtons[t]=new pt({mm2d:e.mm2d,pos:[],triangles:[],muscles:[],size:40}),this.miniButtons[t].domElement.style.cursor="pointer",this.miniButtons[t].domElement.addEventListener("click",(()=>{this.switchToAgent(t)})),this.miniContainer.appendChild(this.miniButtons[t].domElement)})),this.domElement.appendChild(this.miniContainer)}async preloadMiniButtonData(){await this.agentManager.preloadAllData();for(const e of this.agentManager.agents)try{const t=this.agentManager.meshCache.get(e);this.miniButtons[e]&&t&&this.miniButtons[e].updateMesh({pos:t.pos,triangles:t.triangles})}catch(t){console.warn(`Failed to preload mesh data for ${e}:`,t)}}async switchToAgent(e){if(this.agentManager.getCurrentAgent()!==e)try{const{meshData:t}=await this.agentManager.switchToAgent(e);this.viewport?(this.viewport.needsMeshUpdate=!0,null!=t.depth?this.viewport.setSortedVertexIdsFromVertexDepths(t.depth):null!=t.sorted_vertex_ids&&(this.viewport.sortedVertexIds=t.sorted_vertex_ids)):(this.viewport=new this.algovivo.render.SystemViewport({system:this.system,sortedVertexIds:t.sorted_vertex_ids,vertexDepths:t.depth,domElementForMoveEvents:this.domElement}),this.viewport.tracker.targetCenterY=1.1,this.domElement.insertBefore(this.viewport.domElement,this.miniContainer),this.initResponsiveSize()),this.updateMiniButtonStates(e)}catch(t){console.error(`Failed to switch to agent ${e}:`,t)}}updateMiniButtonStates(e){Object.keys(this.miniButtons).forEach((t=>{this.miniButtons[t].setActive(t===e)}))}togglePolicy(){return this.agentManager.togglePolicy()}render(){this.viewport&&this.viewport.render()}dispose(){this.agentManager.dispose()}getCurrentAgent(){return this.agentManager.getCurrentAgent()}isActive(){return this.agentManager.isActive()}}class wt{constructor(){const e=document.createElement("div");var t;this.domElement=e,(t=e.style).display="flex",t.flexDirection="column",t.alignItems="center",t.color="white",t.width="100%",t.backgroundColor="#000000",t.paddingBottom="20px",t.marginBottom="30px",t.boxShadow="0 0 10px rgba(0, 0, 0, 0.3)";const s=document.createElement("div");e.appendChild(s),(e=>{e.maxWidth="1200px",e.width="100%",e.paddingTop="20px",e.position="relative",e.textAlign="center",e.paddingRight="50px",e.paddingLeft="50px"})(s.style);const i=document.createElement("h1");i.textContent="algovivo",s.appendChild(i),(e=>{e.fontSize="33px",e.color="white"})(i.style);const r=function(){const e=document.createElement("a");return e.href="https://github.com/juniorrojas/algovivo",e.innerHTML='<svg style="cursor: pointer; position: absolute; top: 0; border: 0; right: 0; margin: 10px 7px;" viewBox="0 0 98 96" width="40" height="40" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M48.854 0C21.839 0 0 22 0 49.217c0 21.756 13.993 40.172 33.405 46.69 2.427.49 3.316-1.059 3.316-2.362 0-1.141-.08-5.052-.08-9.127-13.59 2.934-16.42-5.867-16.42-5.867-2.184-5.704-5.42-7.17-5.42-7.17-4.448-3.015.324-3.015.324-3.015 4.934.326 7.523 5.052 7.523 5.052 4.367 7.496 11.404 5.378 14.235 4.074.404-3.178 1.699-5.378 3.074-6.6-10.839-1.141-22.243-5.378-22.243-24.283 0-5.378 1.94-9.778 5.014-13.2-.485-1.222-2.184-6.275.486-13.038 0 0 4.125-1.304 13.426 5.052a46.97 46.97 0 0 1 12.214-1.63c4.125 0 8.33.571 12.213 1.63 9.302-6.356 13.427-5.052 13.427-5.052 2.67 6.763.97 11.816.485 13.038 3.155 3.422 5.015 7.822 5.015 13.2 0 18.905-11.404 23.06-22.324 24.283 1.78 1.548 3.316 4.481 3.316 9.126 0 6.6-.08 11.897-.08 13.526 0 1.304.89 2.853 3.316 2.364 19.412-6.52 33.405-24.935 33.405-46.691C97.707 22 75.788 0 48.854 0z" fill="#fff"/></svg>',e}();s.appendChild(r);const n=document.createElement("h2");n.textContent="an energy-based formulation for soft-bodied virtual creatures",s.appendChild(n),(e=>{e.textAlign="center",e.fontSize="18px",e.color="#c7c7c7"})(n.style)}}class vt{constructor(e,t){this.domElement=document.createElement("div"),this.domElement.style.textAlign="left",this.domElement.style.color="#666",this.domElement.style.fontSize="14px",this.domElement.style.padding="22px",this.domElement.style.paddingRight="26px",this.domElement.style.paddingLeft="26px",this.domElement.style.paddingBottom="45px",this.domElement.style.width="100%",this.domElement.style.display="flex",this.domElement.style.justifyContent="center";const s=document.createElement("div");s.style.maxWidth="600px",this.domElement.appendChild(s);const i=document.createElement("h2");this.header=i,i.style.color="black",i.style.fontSize="25px",i.style.padding="10px",i.style.borderBottom="2px solid black",i.textContent=e;const r=document.createElement("div");r.innerHTML=t,s.appendChild(i),s.appendChild(r)}setStyle1(){this.domElement.style.backgroundColor="black",this.domElement.style.color="rgb(199, 199, 199)",this.domElement.style.boxShadow="rgba(0, 0, 0, 0.3) 0px 0px 10px",this.header.style.color="white",this.header.style.borderBottom="2px solid white"}}class xt{constructor(){let e;this.domElement=document.createElement("div"),this.domElement.style.marginTop="16px",this.domElement.style.textAlign="left",this.domElement.style.color="#666",this.domElement.style.fontSize="14px",this.domElement.style.width="100%",this.domElement.style.display="flex",this.domElement.style.flexDirection="column",e=this.addSection("energy-based models for virtual creatures",'<div style="display: flex; flex-direction: column">\n<a href="https://direct.mit.edu/isal/proceedings/isal2024/36/30/123447" style="padding-top: 25px; display: flex; flex-direction: column; align-items: center">\n  <img src="icons/doc.svg" style="width: 30px"></img>\n  <div>paper [ALIFE 2024]</div>\n</a>\n<p>\nPotential energy minimization is one of the <a href="https://youtu.be/c8iFtaltX-s?si=MDUb20nFhumn1Q3n&t=3553">most basic forms of goal-directed behavior</a>.\nA deformable object that tends to recover its original shape can be understood as a system whose goal is to minimize its elastic potential energy.\nIn the context of <a href="https://youtu.be/MiqLoAZFRSE?t=2177">energy-based models</a>, &ldquo;energy&rdquo; is used to define implicit functions that capture dependencies between variables.\nThis more general notion of energy is consistent with potential energy, and is also useful to model inertia, friction, neuromuscular control and many other goal-directed behaviors that may or may not be conventionally considered <a href="https://youtu.be/lIHUWOv4nkE?t=629">&ldquo;just physics&rdquo;</a>.\n</p>\n</div>'),e.setStyle1(),e=this.addSection("no forces, just energy functions","<p>\nMuch like the loss function encapsulates in a single scalar value the objective of a neural network during training, potential energy functions offer a scalar representation of the objective of a mechanical system in a dissipative process.\nIn practice, just as we typically do not compute neural network gradients by hand, we can also avoid computing forces by hand if we use automatic differentiation.\nThe force is just the negative gradient of the potential energy.\nFor more general energy functions, which extend beyond potential energy, the negative gradient might not directly represent a force, but it is useful for gradient-based optimization.\n</p>"),e=this.addSection("six energy functions",'<p>\nThis implementation defines six energy functions. Some are plain potential energy functions; that is, functions of vertex positions <span class="code">E(pos)</span>. Actuation mechanisms are modeled with an action-dependent energy function <span class="code">E(pos, a)</span>. Other energy functions may also depend on the previous state, given by vertex positions and velocities <span class="code">(pos0, vel0)</span>.\n</p>\n\n<ul>\n<li>\n  <a href="https://github.com/juniorrojas/algovivo/blob/main/codegen/algovivo_codegen/csrc/modules/gravity.h">gravity</a>\n  <span class="code">E(pos)</span>\n</li>\n<li>\n  <a href="https://github.com/juniorrojas/algovivo/blob/main/codegen/algovivo_codegen/csrc/modules/collision.h">collision</a>\n  <span class="code">E(pos)</span>\n</li>\n<li>\n  <a href="https://github.com/juniorrojas/algovivo/blob/main/codegen/algovivo_codegen/csrc/modules/muscles.h">muscles</a>\n  <span class="code">E(pos, a)</span>\n</li>\n<li>\n  <a href="https://github.com/juniorrojas/algovivo/blob/main/codegen/algovivo_codegen/csrc/modules/triangles.h">triangles</a>\n  <span class="code">E(pos)</span>\n</li>\n<li>\n  <a href="https://github.com/juniorrojas/algovivo/blob/main/codegen/algovivo_codegen/csrc/modules/friction.h">friction</a>\n  <span class="code">E(pos, pos0)</span>\n</li>\n<li>\n  <a href="https://github.com/juniorrojas/algovivo/blob/main/codegen/algovivo_codegen/csrc/dynamics/inertia.h">inertia</a>\n  <span class="code">E(pos, pos0, vel0)</span>\n</li>\n</ul>'),e.setStyle1(),e=this.addSection("no differential equations, just energy minimization",'<p>\nThis implementation uses the backward Euler method, which is conventionally presented as an implicit <a class="a2" href="https://github.com/juniorrojas/springs-integration-pytorch">numerical integration</a> method, derived as a numerical solution to a differential equation like f = ma (Newtonian mechanics).\nHowever, what we actually implement in practice to solve the resulting non-linear root finding problem in a reliable manner is a gradient-based optimization method that finds a local minimum of a function that consists of the sum of the six energy functions mentioned before:\n</p>\n\n<span class="code2" style="white-space: normal">pos1 = argmin((pos) => E(pos, pos0, vel0, a))</span>\n\n<p>\nThe velocity is then updated with a simple update rule:\n</p>\n\n<span class="code2">vel1 = (pos1 - pos0) / dt</span>\n\n<p>\nMany other implicit numerical integration methods share a similar form, where the next state is found by minimizing an energy function.\nWhile the inertial energy term and velocity update rule may vary depending on the specific method used, energy minimization remains central to explaining state transitions.\nInstead of viewing these methods as numerical solutions to differential equations, we can view them as energy-based models that capture Newton\'s first law of motion in an inertial energy term.\n</p>'),e=this.addSection("no Lagrangians, no Hamiltonians, just energy",'<p>\nRecall that in this context &ldquo;energy&rdquo; is any <a href="https://youtu.be/MiqLoAZFRSE?t=2177">scalar-valued function that measures incompatibility between variables</a>.\nWhen we say inertial energy, we do not mean kinetic energy.\nWhen we say energy minimization, we do not mean Hamiltonian minimization.\nIt is actually possible to implement <a href="https://github.com/juniorrojas/springs-integration-pytorch?tab=readme-ov-file#total-energy-hamiltonian-conservation">Hamiltonian-preserving methods</a> by &ldquo;energy&rdquo; minimization.\nEnergy-based models can also easily describe dissipative systems.\n<a href="https://www.youtube.com/watch?v=7fRfxiyTKS0">Lagrangians and Hamiltonians cannot really describe dissipative systems</a>.\nWhen we say energy minimization, we mean something akin to the least action principle, except that &ldquo;action&rdquo; has a very specific definition in Lagrangian mechanics, and we are not using that definition here.\nWe also want to reserve the word &ldquo;action&rdquo; to refer to actuation mechanisms, such as muscle control, which are modeled as action-dependent energy functions.\nWhatever variable or function names you prefer to use in your code, the important thing is to have a <a href="https://github.com/juniorrojas/algovivo">working implementation</a> that goes beyond just words and mathematical formulas that may not even be computable.\n</p>'),e.setStyle1()}addSection(e,t){const s=new vt(e,t);return this.domElement.appendChild(s.domElement),s}}class Et{constructor(){const e=document.createElement("div");e.style.paddingTop="15px",e.style.paddingBottom="15px",this.domElement=e,e.innerHTML='<a href="https://github.com/juniorrojas/algovivo" target="_blank" rel="noopener noreferrer"><svg style="cursor: pointer; margin: 10px 7px;" viewBox="0 0 98 96" width="40" height="40" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M48.854 0C21.839 0 0 22 0 49.217c0 21.756 13.993 40.172 33.405 46.69 2.427.49 3.316-1.059 3.316-2.362 0-1.141-.08-5.052-.08-9.127-13.59 2.934-16.42-5.867-16.42-5.867-2.184-5.704-5.42-7.17-5.42-7.17-4.448-3.015.324-3.015.324-3.015 4.934.326 7.523 5.052 7.523 5.052 4.367 7.496 11.404 5.378 14.235 4.074.404-3.178 1.699-5.378 3.074-6.6-10.839-1.141-22.243-5.378-22.243-24.283 0-5.378 1.94-9.778 5.014-13.2-.485-1.222-2.184-6.275.486-13.038 0 0 4.125-1.304 13.426 5.052a46.97 46.97 0 0 1 12.214-1.63c4.125 0 8.33.571 12.213 1.63 9.302-6.356 13.427-5.052 13.427-5.052 2.67 6.763.97 11.816.485 13.038 3.155 3.422 5.015 7.822 5.015 13.2 0 18.905-11.404 23.06-22.324 24.283 1.78 1.548 3.316 4.481 3.316 9.126 0 6.6-.08 11.897-.08 13.526 0 1.304.89 2.853 3.316 2.364 19.412-6.52 33.405-24.935 33.405-46.691C97.707 22 75.788 0 48.854 0z" fill="black"/></svg></a>'}}const bt=["biped","quadruped"];!async function(){document.body.style.background="rgb(248, 248, 248)",document.body.style.display="flex",document.body.style.flexDirection="column";const e=new wt;document.body.appendChild(e.domElement);const t=document.createElement("div");t.style.display="flex",t.style.flexDirection="column",t.style.alignItems="center",t.style.width="100%",document.body.appendChild(t),document.documentElement.style.height="100%",document.body.style.height="100%",document.body.style.display="flex",document.body.style.flexDirection="column",document.body.style.margin=0,document.body.style.padding=0,document.body.style.alignItems="center";const s=await async function(){const e=await fetch("algovivo.wasm");return(await WebAssembly.instantiateStreaming(e)).instance}(),i=new ut.System({wasmInstance:s}),r=new yt({system:i,algovivo:ut,dataRoot:"data",agentNames:bt});t.appendChild(r.domElement),await r.preloadMiniButtonData(),await r.switchToAgent("biped");const n=new mt;n.domElement.style.marginTop="8px",n.domElement.style.marginBottom="16px",n.domElement.addEventListener("click",(()=>{r.togglePolicy()?n.setActiveStyle():n.setInactiveStyle()})),t.appendChild(n.domElement);const o=new xt;t.appendChild(o.domElement);const l=new Et;document.body.appendChild(l.domElement),r.render(),setInterval((()=>{null!=r.agentManager.policy&&r.agentManager.policy.step(),i.step(),r.render()}),1e3/30),window.system=i}();
