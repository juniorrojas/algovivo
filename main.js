class e{constructor(e,t){this.list=e,this.data=t,this.next=null,this.prev=null}append(t){const s=new e(this.list,t);return this.list.last==this&&(this.list.last=s),s.next=this.next,s.prev=this,null!=this.next&&(this.next.prev=s),this.next=s,this.list.size++,s}prepend(t){const s=new e(this.list,t);return this.list.first==this&&(this.list.first=s),s.next=this,s.prev=this.prev,null!=this.prev&&(this.prev.next=s),this.prev=s,this.list.size++,s}remove(){null!=this.prev&&(this.prev.next=this.next),null!=this.next&&(this.next.prev=this.prev),this.list.first==this&&(this.list.first=this.next),this.list.last==this&&(this.list.last=this.prev),this.list.size--,this.next=null,this.prev=null}}var t=e;const s=t;class r{constructor(e){this.list=e,this.nextNode=this.list.first}next(){if(null==this.nextNode)return{done:!0};{const e={done:!1,value:this.nextNode.data};return this.nextNode=this.nextNode.next,e}}}class n{constructor(){this.first=null,this.last=null,this.size=0}isEmpty(){if(null==this.first&&null!=this.last||null!=this.first&&null==this.last)throw Error("inconsistent first last state");return null==this.first}append(e){return this.isEmpty()?this.setSingleton(e):this.last.append(e)}prepend(e){return this.isEmpty()?this.setSingleton(e):this.first.prepend(e)}setSingleton(e){const t=new s(this,e);return this.first=t,this.last=t,this.size=1,t}iter(){return new r(this)}*[Symbol.iterator](){const e=this.iter();let t=e.next();for(;!t.done;)yield t.value,t=e.next()}}var i,o,l,h,a,c,d={List:n,Node:t};function u(){if(o)return i;o=1;const e=p();return i=class extends e{constructor(e={}){super(e)}isFree(){return!1}free(){let e=this.appendFree(this.ptr,this.size);this.remove();const t=e.prev(),s=e.next();return null!=t&&t.isFree()&&(e=t.merge(e)),null!=s&&s.isFree()&&(e=e.merge(s)),e}}}function p(){return h||(h=1,l=class{constructor(e={}){this.manager=e.manager,this.ptr=e.ptr,this.size=e.size,this.node=e.node}numBytes(){return this.size}prev(){const e=this.node.prev;return null!=e?e.data:null}next(){const e=this.node.next;return null!=e?e.data:null}appendReserved(e,t){const s=u(),r=this.node.append(null),n=new s({manager:this.manager,ptr:e,size:t,node:r});return r.data=n,this.manager._addReservedSlot(n),n}appendFree(e,t){const s=m(),r=this.node.append(null),n=new s({manager:this.manager,ptr:e,size:t,node:r});return r.data=n,this.manager._addFreeSlot(n),n}remove(){this.node.remove(),this.node.data=null,this.node=null,this.isFree()?this.manager._removeFreeSlot(this):this.manager._removeReservedSlot(this)}toTypedArray(e){const t=this.size,s=e.BYTES_PER_ELEMENT;if(t%s!=0)throw new Error(`size in bytes must be a multiple of ${s}, found ${t}`);const r=this.ptr;return new e(this.manager.array,r,t/s)}f32(){return this.toTypedArray(Float32Array)}u32(){return this.toTypedArray(Uint32Array)}}),l}function m(){if(c)return a;c=1;const e=p();return a=class extends e{constructor(e={}){super(e)}isFree(){return!0}reserve(e){const t=this.numBytes();if(e>t)throw new Error(`cannot reserve ${e} bytes, only ${t} bytes are available`);const s=this.appendReserved(this.ptr,e);return s.appendFree(this.ptr+e,t-e),this.remove(),s}merge(e){if(!this.isFree()||!e.isFree())throw new Error("only free slots can be merged");if(this.next()!=e)throw new Error("only adjacent slots can be merged");const t=e.appendFree(this.ptr,this.size+e.size);return this.remove(),e.remove(),t}}}const g=d,f=m();var w={linked:d,MemoryManager:class{constructor(e,t){this.array=e,null==t&&(t=0),this.ptrToSlot=new Map,this.slots=new g.List,this.freeSlots=new g.List,this.reservedSlots=new g.List;const s=new f({manager:this,ptr:t,size:e.byteLength-t}),r=this.slots.append();r.data=s,s.node=r;const n=this.freeSlots.append();n.data=s,s.freeNode=n}numReservedSlots(){return this.reservedSlots.size}numFreeSlots(){return this.freeSlots.size}numFreeBytes(){let e=0;const t=this.freeSlots.iter();let s=t.next();for(;!s.done;)e+=s.value.size,s=t.next();return e}numReservedBytes(){let e=0;const t=this.reservedSlots.iter();let s=t.next();for(;!s.done;)e+=s.value.size,s=t.next();return e}mallocBytes(e){return this._malloc(e)}malloc32(e){return this.mallocBytes(4*e)}_addReservedSlot(e){const t=this.reservedSlots.append(e);e.reservedNode=t}_removeReservedSlot(e){if(null==e.reservedNode)throw new Error("reservedNode cannot be null");e.reservedNode.remove()}_addFreeSlot(e){const t=this.freeSlots.append(e);e.freeNode=t}_removeFreeSlot(e){if(null==e.freeNode)throw new Error("freeNode cannot be null");e.freeNode.remove()}_malloc(e){if(!Number.isInteger(e))throw new Error(`expected integer, found ${e}`);let t=null;const s=this.freeSlots.iter();let r=s.next();for(;!r.done;){const n=r.value;if(n.size>=e){t=n;break}r=s.next()}if(null==t)throw new Error("no valid free slot available");return t.reserve(e)}malloc(e){const t=this._malloc(e);return this.ptrToSlot.set(t.ptr,t),t.ptr}free(e){this.ptrToSlot.get(e).free()}},FreeSlot:m(),ReservedSlot:u()};class y{constructor(e={}){const t=e.engine;if(null==t)throw new Error("engine required to create IntTuple");this.engine=t;const s=e.slot;if(null==s)throw new Error("slot required to create IntTuple");this.slot=s,this.ptr=s.ptr,this.length=e.length}forEach(e){for(let t=0;t<this.length;t++)e(this.get(t),t)}equal(e){if(e instanceof y){for(let t=0;t<this.length;t++)if(this.get(t)!=e.get(t))return!1;return!0}if(Array.isArray(e)){for(let t=0;t<this.length;t++)if(this.get(t)!=e[t])return!1;return!0}return!1}toString(){return this.slot.u32().toString()}toArray(){const e=[];return this.forEach((t=>{e.push(t)})),e}typedArray(){return this.slot.u32()}set(e,t){this.typedArray()[e]=t}get(e){return this.typedArray()[e]}dispose(){this.slot.free()}}var x=y;function v(e,t,s,r){if(t==s.length-1)for(let n=0;n<s[t];n++)e.push(r);else for(let n=0;n<s[t];n++){const n=[];e.push(n),v(n,t+1,s,r)}}var E={inferShape:function(e){const t=[];let s=e;for(;Array.isArray(s);)t.push(s.length),s=s[0];return t},makeNdArray:function(e,t){let s=e;e instanceof x&&(s=e.toArray());const r=[];return v(r,0,s,t),r},numelOfShape:function(e){let t=1;return e.forEach((e=>{t*=e})),t},getArrElem:function e(t,s){if(!Array.isArray(s))throw new Error(`expected array, found ${typeof s}: ${s}`);return 0==s.length?t:e(t[s[0]],s.slice(1))},setArrElem:function e(t,s,r){if(!Array.isArray(s))throw new Error(`expected array, found ${typeof s}: ${s}`);if(1!=s.length)return e(t[s[0]],s.slice(1),r);t[s]=r}};const b=x;class S{constructor(e){if(null==e)throw new Error("shape required");if(!(e instanceof b))throw new Error(`IntTuple shape expected, found ${typeof e}: shape`);this.shape=e,this.done=!1,this.idx=[],e.forEach((e=>{this.idx.push(0)}))}next(){const e=this.shape;for(let t=0;t<e.length;t++){const s=e.length-1-t;if(this.idx[s]<e.get(s)-1)return void this.idx[s]++;if(0==s)return void(this.done=!0);this.idx[s]=0}}static shapeForEach(e,t){const s=new S(e);for(;!s.done;)t(s.idx),s.next()}}const V=E,_=S,I=x;class C{constructor(e={}){const t=e.engine;if(null==t)throw new Error("engine required to create tensor");this.engine=t;const s=e.shape;if(null==s)throw new Error("shape required to create tensor");if(s instanceof I)this.shape=s;else{if(!Array.isArray(s))throw new Error(`invalid shape type ${typeof s}: ${s}`);this.shape=t.intTuple(s)}this.order=this.shape.length;const r=V.numelOfShape(this.shape);this.numel=r;const n=e.slot;if(r>0&&null==n)throw new Error("memory slot required to create tensor");this.slot=e.slot;const i=e.stride;if(null!=i){if(!(i instanceof I))throw new Error(`expected IntTuple stride, found ${typeof i}: ${i}`);this.stride=i}else this.setDefaultStride()}get ptr(){return this.slot.ptr}get wasmInstance(){return this.engine.wasmInstance}isScalar(){return 0==this.order}fill_(e){this.wasmInstance.exports.fill_(this.numel,this.ptr,e)}clamp_(e={}){const t=e.min,s=e.max;this.wasmInstance.exports.clamp(this.numel,this.ptr,this.ptr,t,s,null!=t,null!=s)}zero_(){this.fill_(0)}flattenIdx(e){let t,s,r=!1;if(Array.isArray(e)&&(t=this.engine.intTuple(e),r=!0),!(t instanceof I))throw new Error(`cannot handle ${typeof t}: ${t}`);return s=this.engine.wasmInstance.exports.flatten_idx(this.order,t.slot.ptr,this.stride.slot.ptr),r&&t.dispose(),s}typedArray(){return this.slot.f32()}toArray(){if(0==this.numel)return[];const e=V.makeNdArray(this.shape,0);return this.forEach((t=>{const s=this.get(t);V.setArrElem(e,t,s)})),e}get(e){const t=this.flattenIdx(e);return this.typedArray()[t]}item(){if(!this.isScalar())throw new Error(`item() only works for scalars, found tensor with shape ${this.shape}`);return this.get([0])}setDefaultStride(){let e=1;const t=this.order,s=[];for(let e=0;e<t;e++)s.push(0);for(let r=0;r<t;r++){const n=t-1-r;s[n]=e,e*=this.shape.get(n)}this.stride=this.engine.intTuple(s)}setFromArray(e){if(0!=this.numel)if(this.isScalar()){if("number"!=typeof e)throw new Error(`expected number, found ${typeof e}: ${e}`);this.set([0],e)}else{if(!Array.isArray(e))throw new Error(`expected array, found ${typeof e}: ${e}`);const t=V.inferShape(e);if(!this.shape.equal(t))throw new Error(`inconsistent shapes ${t} != ${this.shape}`);this.forEach((t=>{const s=V.getArrElem(e,t);this.set(t,s)}))}}set(e,t){if(null==t&&Array.isArray(e))this.setFromArray(e);else{const s=this.flattenIdx(e);this.typedArray()[s]=t}}forEach(e){_.shapeForEach(this.shape,e)}squeeze(e){-1==e&&(e=this.shape.length-1);const t=this.shape.get(e);if(1!=t)throw new Error(`cannot squeeze a dimension that is not equal to 1, shape[${e}] = ${t}`);const s=[];for(let t=0;t<this.order;t++)e!=t&&s.push(this.shape.get(t));return new C({engine:this.engine,shape:s,slot:this.slot})}unsqueeze(e){-1==e&&(e=this.shape.length-1);const t=[];for(let s=0;s<this.order;s++)t.push(this.shape.get(s)),e==s&&t.push(1);return new C({engine:this.engine,shape:t,slot:this.slot})}add(e,t){this.engine.functional.add(this,e,t)}sum(e){this.engine.wasmInstance.exports.sum(this.numel,this.slot.ptr,e.slot.ptr)}dispose(){if(null==this.slot)throw new Error("tensor already disposed");this.slot.free(),this.slot=null,this.shape.dispose(),this.stride.dispose()}}var A=C,L=class{constructor(){}};const M=L;const T=L;const z=L;const k=L;const $=class extends M{constructor(e,t){super(),this.nn=e,this.layers=t}forward(e){let t=e;return this.layers.forEach((e=>{t=e.forward(t)})),t}dispose(){this.layers.forEach((e=>{e.dispose()}))}},D=class extends T{constructor(e,t,s){super(),this.nn=e,this.inputSize=t,this.outputSize=s;const r=this.nn.engine;this.weight=r.zeros([s,t]),this.bias=r.zeros([s]),this.output=r.zeros([s])}forward(e){const t=this.nn.engine.functional;return t.matvec(this.weight,e,this.output),t.add(this.output,this.bias,this.output),this.output}dispose(){this.weight.dispose(),this.bias.dispose(),this.output.dispose()}},P=class extends z{constructor(e){super(),this.nn=e,this.output=null}forward(e){const t=this.nn.engine;return null==this.output&&(this.output=t.zerosLike(e)),t.functional.relu(e,this.output),this.output}dispose(){null!=this.output&&this.output.dispose()}},W=class extends k{constructor(e){super(),this.nn=e,this.output=null}forward(e){const t=this.nn.engine;return null==this.output&&(this.output=t.zerosLike(e)),t.functional.tanh(e,this.output),this.output}dispose(){null!=this.output&&this.output.dispose()}},q=w,F=E,B=A,H=x,j=class{constructor(e={}){const t=this.engine=e.engine;this.wasmInstance=t.wasmInstance}matvec(e,t,s){const r=e.shape.get(0),n=e.shape.get(1),i=t.shape.get(0),o=s.shape.get(0);if(r!=o)throw new Error(`inconsistent output size ${r} != ${o}`);if(n!=i)throw new Error(`inconsistent input size ${n} != ${i}`);this.wasmInstance.exports.matvec(r,n,e.stride.ptr,e.ptr,t.stride.ptr,t.ptr,s.stride.ptr,s.ptr)}mm(e,t,s){const r=e.shape.get(0),n=e.shape.get(1),i=t.shape.get(1);this.wasmInstance.exports.mm(r,n,i,e.stride.ptr,e.ptr,t.stride.ptr,t.ptr,s.stride.ptr,s.ptr)}relu(e,t){this.wasmInstance.exports.relu(e.numel,e.ptr,t.ptr)}tanh(e,t){const s=e.numel,r=e.typedArray(),n=t.typedArray();for(let e=0;e<s;e++)n[e]=Math.tanh(r[e])}add(e,t,s){this.wasmInstance.exports.add(e.numel,e.ptr,t.ptr,s.ptr)}sum(e,t){this.wasmInstance.exports.sum(e.numel,e.ptr,t.ptr)}sumBackward(e,t,s,r){this.wasmInstance.exports.sum_backward(e.numel,e.ptr,t.ptr,s.ptr,r.ptr)}},R=class{constructor(e={}){null!=e.wasmInstance&&this.init(e),this.env={}}init(e={}){if(null==e.wasmInstance)throw new Error("wasmInstance required");this.wasmInstance=e.wasmInstance;const t=e.wasmInstance.exports.memory.buffer,s=new q.MemoryManager(t,e.wasmInstance.exports.__heap_base);this.mgr=s,this.functional=this.F=new j({engine:this}),this.nn=new class{constructor(e={}){this.engine=e.engine}Linear(e,t){return new D(this,e,t)}ReLU(){return new P(this)}Tanh(){return new W(this)}Sequential(){const e=Array.from(arguments);return new $(this,e)}}({engine:this}),this._mergeF()}_mergeF(){Object.getOwnPropertyNames(Object.getPrototypeOf(this.F)).forEach((e=>{"constructor"!=e&&(this[e]=this.F[e])}))}tensor(e){const t=F.inferShape(e),s=this.intTuple(t),r=F.numelOfShape(t),n=this.mgr.malloc32(r),i=new B({engine:this,shape:s,slot:n});return i.setFromArray(e),i}intTuple(e){if(!Array.isArray(e))throw new Error(`expected array, found ${typeof e}: ${e}`);const t=e.length,s=this.mgr.malloc32(t),r=new H({engine:this,length:t,slot:s});for(let s=0;s<t;s++)r.set(s,e[s]);return r}zerosLike(e){if(!(e instanceof B))throw new Error(`expected tensor, found ${typeof e}: ${e}`);return this.zeros(e.shape.toArray())}empty(e){let t;if(e instanceof H)t=e;else{if(!Array.isArray(e))throw new Error(`expected array, found ${typeof e}: ${e}`);t=this.intTuple(e)}const s=F.numelOfShape(t),r=this.mgr.malloc32(s);return new B({engine:this,shape:t,slot:r})}zeros(e){const t=this.empty(e);return t.zero_(),t}ones(e){const t=this.empty(e);return t.fill_(1),t}};var N={engine:function(e={}){return new R({wasmInstance:e.wasmInstance})},Engine:R,Tensor:A,mmgr:w,utils:E};const O=N,X=class{constructor(e={}){const t=e.ten;if(null==t)throw new Error("ten required");this.ten=t,this.spaceDim=2,this.vertexMass=e.vertexMass??6.0714287757873535,this.pos0=null,this.pos1=null,this.vel0=null,this.vel1=null,this.posGrad=null,this.posTmp=null,this._fixedVertexId=-1}set fixedVertexId(e){throw new Error("use fixVertex instead")}fixVertex(e){this._fixedVertexId=e}freeVertex(){this._fixedVertexId=-1}get pos(){return this.pos0}get numVertices(){return null==this.pos0?0:this.pos0.shape.get(0)}updateTmpBuffers(){if(null==this.pos0)throw new Error("pos0 required");const e=this.numVertices,t=this.spaceDim,s=this.ten,r=s.zeros([e,t]);null!=this.posGrad&&this.posGrad.dispose(),this.posGrad=r;const n=s.zeros([e,t]);null!=this.posTmp&&this.posTmp.dispose(),this.posTmp=n}get wasmInstance(){return this.ten.wasmInstance}get memoryManager(){return this.ten.mgr}set(e){const t=this.ten,s=this.spaceDim;if(null==e)throw new Error("pos required");const r=e.length,n=t.tensor(e);null!=this.pos0&&this.pos0.dispose(),this.pos0=n;const i=t.zeros([r,s]);null!=this.pos1&&this.pos1.dispose(),this.pos1=i;const o=t.zeros([r,s]);null!=this.vel0&&this.vel0.dispose(),this.vel0=o;const l=t.zeros([r,s]);null!=this.vel1&&this.vel1.dispose(),this.vel1=l,this.updateTmpBuffers()}dispose(){null!=this.pos0&&(this.pos0.dispose(),this.pos0=null),null!=this.pos1&&(this.pos1.dispose(),this.pos1=null),null!=this.posGrad&&(this.posGrad.dispose(),this.posGrad=null),null!=this.posTmp&&(this.posTmp.dispose(),this.posTmp=null),null!=this.vel0&&(this.vel0.dispose(),this.vel0=null),null!=this.vel1&&(this.vel1.dispose(),this.vel1=null)}},U=class{constructor(e={}){const t=e.ten;if(null==t)throw new Error("ten required");this.ten=t,this.muscles=null,this.k=90,this.l0=null,this.a=null}get wasmInstance(){return this.ten.wasmInstance}get memoryManager(){return this.ten.mgr}get numMuscles(){return null==this.muscles?0:this.muscles.u32().length/2}set(e={}){if(null==e.indices)throw new Error("indices required");const t=e.indices,s=t.length,r=this.numMuscles,n=this.memoryManager,i=this.ten;null!=e.k&&(this.k=e.k);const o=n.malloc32(2*s);null!=this.muscles&&this.muscles.free(),this.muscles=o;const l=o.u32();if(t.forEach(((e,t)=>{const s=2*t;l[s]=e[0],l[s+1]=e[1]})),null!=this.l0&&this.l0.dispose(),this.l0=null,0!=s){const t=i.zeros([s]);this.l0=t,null==e.l0?this.wasmInstance.exports.l0_of_pos(this.numVertices,e.pos.ptr,s,this.muscles.ptr,this.l0.ptr):this.l0.set(e.l0)}const h=e.keepA??!1;if(s!=r){if(h)throw new Error(`keepA can only be true when the number of muscles is the same (${s} != ${r})`);if(null!=this.a&&(this.a.dispose(),this.a=null),0!=s){const e=i.zeros([s]);this.a=e,e.fill_(1)}}else 0==s?(null!=this.a&&this.a.dispose(),this.a=null):h||this.a.fill_(1)}dispose(){null!=this.muscles&&(this.muscles.free(),this.muscles=null),null!=this.l0&&(this.l0.dispose(),this.l0=null),null!=this.a&&(this.a.dispose(),this.a=null)}};function G(e){return[e[0],e[1]]}function Y(e,t){e[0]*=t,e[1]*=t}function Z(e,t){const s=G(e);return Y(s,t),s}function J(e){return e[0]*e[0]+e[1]*e[1]}function K(e){return Math.sqrt(J(e))}var Q={clone:G,add:function(e,t){return[e[0]+t[0],e[1]+t[1]]},add_:function(e,t){e[0]+=t[0],e[1]+=t[1]},mulScalar_:Y,mulScalar:Z,sub:function(e,t){return[e[0]-t[0],e[1]-t[1]]},quadrance:J,norm:K,normalize:function(e){return Z(e,1/K(e))},dot:function(e,t){return e[0]*t[0]+e[1]*t[1]}};class ee{constructor(e,t,s,r){this.m00=e,this.m01=t,this.m10=s,this.m11=r}get(e,t){return this[`m${e}${t}`]}set(e,t,s,r){this.m00=e,this.m01=t,this.m10=s,this.m11=r}toArray(){return[[this.m00,this.m01],[this.m10,this.m11]]}negate(){return new ee(-this.m00,-this.m01,-this.m10,-this.m11)}apply(e){return[this.m00*e[0]+this.m01*e[1],this.m10*e[0]+this.m11*e[1]]}det(){return this.m00*this.m11-this.m10*this.m01}inv(){const e=this.det();return new ee(this.m11/e,-this.m01/e,-this.m10/e,this.m00/e)}mm(e){const t=this.m00,s=this.m01,r=this.m10,n=this.m11,i=e.m00,o=e.m01,l=e.m10,h=e.m11;return new ee(t*i+s*l,t*o+s*h,r*i+n*l,r*o+n*h)}t(){return new ee(this.m00,this.m10,this.m01,this.m11)}static fromArray(e){return new ee(e[0][0],e[0][1],e[1][0],e[1][1])}}var te=ee;const se=te,re=Q;class ne{constructor(){this.translation=[0,0],this.linear=new se(1,0,0,1)}inferScale(){return this.linear.m00}apply(e){return re.add(this.linear.apply(e),this.translation)}inv(){const e=new ne;return e.linear=this.linear.inv(),e.translation=e.linear.negate().apply(this.translation),e}toColumnMajorArray(){return[this.linear.get(0,0),this.linear.get(1,0),this.linear.get(0,1),this.linear.get(1,1),this.translation[0],this.translation[1]]}}var ie={Vec2:Q,Matrix2x2:te,Transform2d:ne,AABB:class{constructor(e={}){if(null==e.x0)throw new Error("x0 required");if(null==e.y0)throw new Error("y0 required");this._x0=e.x0,this._y0=e.y0;let t=null;if(null!=e.width)t=this._x0+e.width;else{if(null==e.x1)throw new Error("x1 required");t=e.x1}this._x1=t;let s=null;if(null!=e.height)s=this._y0+e.height;else{if(null==e.y1)throw new Error("y1 required");s=e.y1}this._y1=s}get x0(){return this._x0}get x1(){return this._x1}get y0(){return this._y0}get y1(){return this._y1}get width(){return this._x1-this._x0}get height(){return this._y1-this._y0}get center(){return[.5*(this.x0+this.x1),.5*(this.y0+this.y1)]}}};const oe=ie;var le={PointShader:class{constructor(){}renderPoint(e={}){const t=e.ctx,s=e.p;t.beginPath(),t.arc(s[0],s[1],3,0,2*Math.PI),t.fill()}},LineShader:class{constructor(){}renderLine(e={}){const t=e.ctx,s=e.a,r=e.b;t.beginPath(),t.strokeStyle="red",t.lineWidth=5,t.moveTo(s[0],s[1]),t.lineTo(r[0],r[1]),t.closePath(),t.stroke()}},TriangleShader:class{constructor(){}renderTriangle(e={}){const t=e.ctx,s=e.a,r=e.b,n=e.c;t.save(),t.beginPath(),t.strokeStyle="black",t.moveTo(s[0],s[1]),t.lineTo(r[0],r[1]),t.lineTo(n[0],n[1]),t.closePath(),t.stroke(),t.restore()}}};const he=ie,ae=le;var ce=class{constructor(e={}){this.scene=e.scene,this.id=e.id,this.x=[],this.triangles=[],this.lines=[],this.pointShader=new ae.PointShader({}),this.lineShader=new ae.LineShader({}),this.triangleShader=new ae.TriangleShader({}),this.customAttributes={}}get pos(){return this.x}set pos(e){this.x=e}numVertices(){return this.pos.length}numTriangles(){return this.triangles.length}numLines(){return this.lines.length}setCustomAttribute(e,t){this.customAttributes[e]=t}getCustomAttribute(e){return this.customAttributes[e]}computeAABB(){let e=null,t=null,s=null,r=null;return this.pos.forEach((n=>{const i=n[0],o=n[1];(null==e||i<e)&&(e=i),(null==t||i>t)&&(t=i),(null==s||o<s)&&(s=o),(null==r||o>r)&&(r=o)})),new he.AABB({x0:e,y0:s,x1:t,y1:r})}computeCenter(){const e=this.pos.length;if(0==e)throw new Error("no vertices to compute center");let t=[0,0];for(let s=0;s<e;s++){const e=this.pos[s];he.Vec2.add_(t,e)}return he.Vec2.mulScalar_(t,1/e),t}};const de=ce;const ue=ce;var pe={Camera:class{constructor(){this.transform=new oe.Transform2d}domToWorldSpace(e){if(!Array.isArray(e))throw new Error("array expected, found "+typeof e);if(2!=e.length)throw new Error(`array with 2 elements expected, found ${e.length}`);return this.transform.inv().apply(e)}inferScale(){return this.transform.inferScale()}center(e={}){let t=e.viewportWidth,s=e.viewportHeight;const r=e.renderer;if((null==t||null==s)&&null==r)throw new Error("renderer required");if(null!=r&&(t=r.width,s=r.height),null==t)throw new Error("viewportWidth required");if(null==s)throw new Error("viewportHeight required");let n,i=e.zoom??1;if(null!=e.worldWidth&&(i=t/e.worldWidth),this.transform.linear=new oe.Matrix2x2(i,0,0,-i),null!=e.worldCenter){const r=e.worldCenter;n=[.5*t-r[0]*i,.5*s+r[1]*i]}else n=[.5*t,.5*s];this.transform.translation=n}},Mesh:ce,Renderer:class{constructor(e={}){const t=e.headless??!1;if(this.headless=t,!t){const e=document.createElement("canvas");this.domElement=e,this.ctx=e.getContext("2d")}this.setSize({width:200,height:200})}setSize(e){const t=e.width;if(null==t)throw new Error("width required to setSize");const s=e.height;if(null==s)throw new Error("height required to setSize");let r=e.viewportWidth;null==r&&(r=t);let n=e.viewportHeight;if(null==n&&(n=s),this.width=t,this.height=s,this.viewportWidth=r,this.viewportHeight=n,!this.headless){const e=this.domElement;e.width=r,e.height=n,e.style.width=`${t}px`,e.style.height=`${s}px`}}renderPoint(e,t,s,r,n){const i=this.ctx;let o;if(!(t instanceof de))throw new Error("invalid mesh");o=t.pos[r];const l=s.transform.apply(o);i.save(),t.pointShader.renderPoint({ctx:i,renderer:e,mesh:t,camera:s,id:r,p:l,custom:n}),i.restore()}renderLine(e,t,s,r,n){const i=this.ctx,o=t.lines[r],l=s.transform.apply(t.pos[o[0]]),h=s.transform.apply(t.pos[o[1]]);i.save(),t.lineShader.renderLine({ctx:i,renderer:e,mesh:t,camera:s,id:r,a:l,b:h,custom:n}),i.restore()}renderTriangle(e,t,s,r,n){const i=this.ctx,o=t.triangles[r],l=o[0],h=o[1],a=o[2];let c,d,u;if(t.pos instanceof Float32Array){const e=2;c=[t.pos[l*e],t.pos[l*e+1]],d=[t.pos[h*e],t.pos[h*e+1]],u=[t.pos[a*e],t.pos[a*e+1]]}else c=t.pos[l],d=t.pos[h],u=t.pos[a];const p=s.transform.apply(c),m=s.transform.apply(d),g=s.transform.apply(u);i.save(),t.triangleShader.renderTriangle({ctx:i,renderer:e,mesh:t,camera:s,id:r,a:p,b:m,c:g,custom:n}),i.restore()}renderMesh(e,t,s,r={}){const n=t.sortedElements;if(null==n){for(let n=0;n<t.triangles.length;n++)this.renderTriangle(e,t,s,n,r);for(let n=0;n<t.lines.length;n++)this.renderLine(e,t,s,n,r);for(let n=0;n<t.pos.length;n++)this.renderPoint(e,t,s,n,r)}else n.forEach((n=>{if(null==n.order)throw new Error(`invalid element, order not defined ${n}`);if(1==n.order)this.renderPoint(e,t,s,n.id,r);else if(2==n.order)this.renderLine(e,t,s,n.id,r);else{if(3!=n.order)throw new Error(`invalid element ${n}`);this.renderTriangle(e,t,s,n.id,r)}}))}render(e,t,s={}){this.ctx.clearRect(0,0,this.viewportWidth,this.viewportHeight),e.meshes.forEach((e=>{this.renderMesh(this,e,t,s)}))}},Scene:class{constructor(){this.meshes=new Map}clean(){this.meshes=new Map}numMeshes(){return this.meshes.size}addMesh(){const e=this.meshes.size,t=new ue({scene:this,id:e});return this.meshes.set(e,t),t}}},me={computeDomCursor:function(e,t){let s,r;if(null==e.touches)s=e.clientX,r=e.clientY;else{if(0==e.touches.length)return null;const t=e.touches[0];s=t.clientX,r=t.clientY}let n=new DOMMatrix,i=t;for(;null!=i;){const e=window.getComputedStyle(i);n=new DOMMatrix(e.transform).multiply(n),i=i.parentElement}const o=n.inverse(),l=new DOMPointReadOnly(s,r).matrixTransform(o),h=t.getBoundingClientRect(),a=new DOMPointReadOnly(h.left,h.top).matrixTransform(o);return[l.x-a.x,l.y-a.y]}};const ge=me;var fe={cursorUtils:me,DragBehavior:class{constructor(e={}){this._dragging=!1,this.onDomCursorDown=e.onDomCursorDown,this.onDragProgress=e.onDragProgress,this.onDomCursorUp=e.onDomCursorUp,this.domElement=null}beginDrag(){this._dragging=!0}endDrag(){this._dragging=!1}dragging(){return this._dragging}domCursorDown(e,t){null!=this.onDomCursorDown&&this.onDomCursorDown(e,t)}domCursorMove(e,t){this.dragging()&&null!=this.onDragProgress&&this.onDragProgress(e,t)}domCursorUp(e,t){this.endDrag(),null!=this.onDomCursorUp&&this.onDomCursorUp(e,t)}linkToDom(e,t=null){if(null!=this.domElement)throw new Error("already linked to DOM");this.domElement=e;const s=t=>{t.preventDefault();const s=ge.computeDomCursor(t,e);this.domCursorDown(s,t)};e.addEventListener("mousedown",s,{passive:!1}),e.addEventListener("touchstart",s,{passive:!1});const r=t=>{const s=ge.computeDomCursor(t,e);this.domCursorMove(s,t)};null==t&&(t=e),t.addEventListener("mousemove",r,{passive:!1}),t.addEventListener("touchmove",r,{passive:!1});const n=t=>{const s=ge.computeDomCursor(t,e);this.domCursorUp(s,t)};window.addEventListener("mouseup",n),window.addEventListener("touchend",n),window.addEventListener("touchcancel",n)}}};class we{constructor(e={}){if(null==e.scene)throw new Error("scene required");const t=null==e.color?"rgba(0, 0, 0, 0.30)":e.color,s=this.mesh=e.scene.addMesh();this.set(e),s.setCustomAttribute("translation",[0,0]),s.pointShader.renderPoint=()=>{},s.lineShader.renderLine=we.makeGridLineShader({color:t})}get numVertices(){return this.mesh.x.length}get numLines(){return this.mesh.lines.length}set(e={}){const t=null==e.cellSize?1:e.cellSize,s=null==e.innerCells?3:e.innerCells,r=null==e.rows?3:e.rows,n=null==e.cols?4:e.cols,i=null==e.x0?-2:e.x0,o=null==e.y0?0:e.y0,l=null==e.primaryLineWidth?.03:e.primaryLineWidth,h=null==e.secondaryLineWidth?.008:e.secondaryLineWidth,a=this.mesh,{x:c,lineIndices:d,lineWidths:u}=function(e={}){const t=null==e.cellSize?1:e.cellSize,s=null==e.innerCells?3:e.innerCells,r=null==e.rows?3:e.rows,n=null==e.cols?4:e.cols,i=null==e.x0?-2:e.x0,o=null==e.y0?0:e.y0,l=null==e.primaryLineWidth?.022:e.primaryLineWidth,h=null==e.secondaryLineWidth?.008:e.secondaryLineWidth,a=[],c=[],d=[],u=o+r*t,p=i+n*t;function m(e,t){for(let r=0;r<e+1;r++){const n=r==e?1:s;for(let e=0;e<n;e++){const s=2*c.length;t(r,e,n,a),c.push([s,s+1]),0==e?d.push(l):d.push(h)}}}return m(r,((e,s,r,n)=>{const l=s/r,h=(o+e*t)*(1-l)+(o+(e+1)*t)*l;n.push([i,h]),n.push([p,h])})),m(n,((e,s,r,n)=>{const l=s/r,h=(i+e*t)*(1-l)+(i+(e+1)*t)*l;n.push([h,o]),n.push([h,u])})),{x:a,lineIndices:c,lineWidths:d}}({cellSize:t,innerCells:s,rows:r,cols:n,x0:i,y0:o,primaryLineWidth:l,secondaryLineWidth:h});a.pos=c,a.lines=d,a.setCustomAttribute("lineWidths",u)}static makeGridLineShader(e={}){const t=null==e.color?"black":e.color;return e=>{const s=e.ctx,r=e.a,n=e.b,i=e.camera,o=e.mesh,l=i.inferScale();s.beginPath(),s.strokeStyle=t;const h=o.getCustomAttribute("lineWidths");if(null==h)throw new Error("custom attribute lineWidths missing");const a=h[e.id],c=o.getCustomAttribute("translation"),d=[l*c[0],l*c[1]];s.lineWidth=a*l,s.moveTo(r[0]+d[0],r[1]+d[1]),s.lineTo(n[0]+d[0],n[1]+d[1]),s.closePath(),s.stroke()}}}var ye={Grid:we,Background:class{constructor(e={}){if(null==e.scene)throw new Error("scene required");const t=this.mesh=e.scene.addMesh();t.pos=[[0,0]];const s=null==e.color1?"#fcfcfc":e.color1,r=null==e.color2?"#d7d8d8":e.color2;t.pointShader.renderPoint=(e={})=>{const t=e.renderer.width,n=e.renderer.height,i=e.ctx,o=i.createRadialGradient(.5*t,.5*n,.05*t,.5*t,.5*n,.5*t);o.addColorStop(0,s),o.addColorStop(1,r),i.fillStyle=o,i.fillRect(0,0,t,n)}}}},xe=class{constructor(e,t){if(null==e)throw new Error("id required to create simplex");this.order=t.length,this.id=e,this.vertexIds=t}};const ve=xe;function Ee(e){return e.sort(),e.join("_")}var be=class{constructor(e={}){if(null==e.order)throw new Error("order required");this.order=e.order,this.simplicesByHash=new Map}forEach(e){this.simplicesByHash.forEach(e)}size(){return this.simplicesByHash.size}has(e){return this.simplicesByHash.has(Ee(e.vertexIds))}add(e,t){let s=null;if(Array.isArray(e)){if(null==t)throw new Error("id required");s=e,e=new ve(t,s)}else{if(s=e.vertexIds,null==s)throw new Error(`vertexIds required ${e}`);t=e.id}if(s.length!=this.order)throw new Error(`expected ${this.order} vertices, found ${s.length}`);const r=Ee(s);return this.simplicesByHash.set(r,e),e}};const Se=be,Ve=be;var _e=class{constructor(e={}){this.vertices=new Map,this.edges=new Ve({order:2}),this.triangles=new Ve({order:3}),(e.edges??[]).forEach(((e,t)=>{this.addEdge(t,e)})),(e.triangles??[]).forEach(((e,t)=>{this.addTriangle(t,e)}))}numVertices(){return this.vertices.size}numEdges(){return this.edges.size()}numTriangles(){return this.triangles.size()}getVertexById(e,t=!1){let s=this.vertices.get(e);return null==s&&t&&(s=new class{constructor(e){this.id=e,this.edges=new Se({order:2}),this.triangles=new Se({order:3})}addTriangle(e,t){this.triangles.add(e,t)}addEdge(e,t){this.edges.add(e,t)}}(e),this.vertices.set(e,s)),s}addEdge(e,t){const s=this.edges.add(t,e);return t.forEach((e=>{this.getVertexById(e,!0).addEdge(s)})),s}addTriangle(e,t){const s=this.triangles.add(t,e);return t.forEach((e=>{this.getVertexById(e,!0).addTriangle(s)})),s}};const Ie=_e,Ce=be;var Ae={math:ie,ui:fe,shaders:le,background:ye,sorted:{makeSortedElements:function(e={}){if(null==e.sortedVertexIds)throw new Error("sortedVertexIds required");if(null==e.triangles)throw new Error("triangles required");if(null==e.edges)throw new Error("edges required");const t=e.sortedVertexIds,s=new Map;t.forEach(((e,t)=>{s.set(e,t)}));const r=new Ie({triangles:e.triangles}),n=new Ie({edges:e.edges}),i=[],o=new Ce({order:3}),l=new Ce({order:2});return t.forEach((e=>{const t=r.getVertexById(e,!0).triangles,h=n.getVertexById(e,!0).edges,a=[];t.forEach((e=>{a.push(e)})),h.forEach((e=>{a.push(e)})),a.sort(((e,t)=>{const r=e.vertexIds.map((e=>s.get(e))),n=t.vertexIds.map((e=>s.get(e))),i=Math.max(...r),o=Math.max(...n);return i<o?1:i==o?0:-1})),a.forEach((e=>{if(2==e.order){const t=e;l.has(t)||(i.push(t),l.add(t))}else{const t=e;o.has(t)||(i.push(t),o.add(t))}})),i.push({order:1,id:e})})),i},MeshTopology:_e,Simplex:xe,Simplices:be},core:pe,Renderer:pe.Renderer,Camera:pe.Camera,Scene:pe.Scene};class Le{constructor(e={}){if(null==e.scene)throw new Error("scene required");const t=this.scene=e.scene,s=this.mesh=t.addMesh();s.pos=[[-10,0],[10,0]],s.lines=[[0,1]],s.lineShader.renderLine=Le.makeFloorLineShaderFunction({width:e.width,color:e.color}),s.pointShader.renderPoint=()=>{},s.setCustomAttribute("translation",[0,0])}static makeFloorLineShaderFunction(e={}){const t=e.width??.055,s=e.color??"black";return e=>{const r=e.ctx,n=e.a,i=e.b,o=e.camera,l=e.mesh,h=o.inferScale(),a=l.getCustomAttribute("translation"),c=[h*a[0],h*a[1]];r.strokeStyle=s,r.lineWidth=h*t,r.beginPath(),r.moveTo(n[0]+c[0],n[1]+c[1]),r.lineTo(i[0]+c[0],i[1]+c[1]),r.stroke()}}}var Me=Le;const Te=Ae;var ze=class{constructor(e={}){this.system=e.system,this.renderVertexIds=e.renderVertexIds??!1}makePointShaderFunction(e={}){const t=e.radius??.028,s=e.borderColor??"black",r=e.fillColor??"white",n=e.borderWidth??.023;return e=>{const i=e.ctx,o=e.p,l=e.camera.inferScale(),h=(t+n)*l;i.fillStyle=s,i.beginPath(),i.arc(o[0],o[1],h,0,2*Math.PI),i.fill();const a=t*l;if(i.fillStyle=r,i.beginPath(),i.arc(o[0],o[1],a,0,2*Math.PI),i.fill(),this.renderVertexIds){i.beginPath(),i.fillStyle="rgba(255, 255, 255, 0.4)",i.arc(o[0],o[1],.3*l,0,2*Math.PI),i.fill();const t=Math.floor(.4*l);i.font=`${t}px monospace`,i.fillStyle="black",i.textAlign="center",i.textBaseline="middle",i.fillText(e.id,o[0],o[1])}}}getVertexPos(e){const t=this.system.pos.slot.f32(),s=e*this.system.spaceDim;return[t[s],t[s+1]]}get numVertices(){return this.system.numVertices}hitTest(e,t=.31){const s=this.numVertices;if(0==s)return null;let r=null,n=1/0;const i=t*t;for(let t=0;t<s;t++){const s=this.getVertexPos(t),o=Te.math.Vec2.sub(s,e),l=Te.math.Vec2.quadrance(o);l<i&&l<n&&(r=t,n=l)}return r}setVertexPos(e,t){const s=this.system.pos.slot.f32(),r=2*e;s[r]=t[0],s[r+1]=t[1]}setVertexVel(e,t){const s=this.system.vel.slot.f32(),r=2*e;s[r]=t[0],s[r+1]=t[1]}};const ke=Ae,$e=class{constructor(e={}){this.targetCenterX=null,this.currentCenterX=null,this.active=!0,this.visibleWorldWidth=e.visibleWorldWidth??3.8,this.targetCenterY=e.targetCenterY??1,this.offsetX=e.offsetX??0}step(e={}){if(!this.active)return;const t=e.renderer,s=e.camera,r=e.mesh,n=e.floor,i=e.grid;let o=[0,0];r.pos.length>0&&(o=r.computeCenter());const l=o[0]+this.offsetX;isNaN(l)||(this.targetCenterX=l),null==this.currentCenterX?this.currentCenterX=this.targetCenterX:this.currentCenterX+=.5*(this.targetCenterX-this.currentCenterX);const h=[this.currentCenterX,this.targetCenterY];s.center({worldCenter:h,worldWidth:this.visibleWorldWidth,viewportWidth:t.width,viewportHeight:t.height});const a=s.domToWorldSpace([t.width,0]),c=s.domToWorldSpace([0,t.height]),[d,u]=c,p=Math.floor(d)-1;let m=Math.floor(u);m<0&&(m=0);const[g,f]=a,w=g,y=w-p,x=f-m,v=Math.ceil(x)+1,E=Math.ceil(y)+1;i.set({x0:p,y0:m,rows:v,cols:E,innerCells:i.innerCells,primaryLineWidth:i.primaryLineWidth,secondaryLineWidth:i.secondaryLineWidth}),n.mesh.x=[[p,0],[w,0]]}},De=Me,Pe=ze;function We(e){return e.sort(),e.join("_")}function qe(e){if(7!=e.length)throw new Error(`invalid hex string ${e}`);if("#"!=e[0])throw new Error(`invalid hex string ${e}, expected #, found ${e[0]}`);return e=e.substring(1),[parseInt(e.substring(0,2),16),parseInt(e.substring(2,4),16),parseInt(e.substring(4,6),16)]}var Fe={SystemViewport:class{constructor(e={}){if(null==e.system)throw new Error("system required");this.system=e.system;const t=e.sortedVertexIds;this.sortedVertexIds=t,null!=e.vertexDepths&&this.setSortedVertexIdsFromVertexDepths(e.vertexDepths);const s=e.headless??!1;this.vertices=new Pe({system:this.system,renderVertexIds:e.renderVertexIds??!1});const r=new ke.Renderer({headless:s});this.renderer=r,this.domElement=r.domElement,this.setSize({width:e.width??400,height:e.height??400});const n=new ke.Scene;this.scene=n;const i=new ke.Camera;this.camera=i;const o=e.borderColor??"black",l=o,h=e.fillColor??"white",a=e.gridColor??"#acadad";let c,d,u=e.activeMuscleColor??[255,0,0],p=e.inactiveMuscleColor??[250,190,190];"string"==typeof u&&(u=qe(u)),"string"==typeof p&&(p=qe(p)),null!=e.backgroundColor?(c=e.backgroundColor,d=e.backgroundColor):(c=e.backgroundCenterColor??"#fcfcfc",d=e.backgroundOuterColor??"#d7d8d8"),new ke.background.Background({scene:n,color1:c,color2:d});const m=this.grid=new ke.background.Grid({scene:n,x0:-3,y0:0,rows:4,cols:10,innerCells:2,primaryLineWidth:.022,secondaryLineWidth:.005,color:a});m.innerCells=2,m.primaryLineWidth=.022,m.secondaryLineWidth=.005,this.floor=new De({scene:n,color:l});const g=n.addMesh();if(this.mesh=g,g.pointShader.renderPoint=this.vertices.makePointShaderFunction({borderColor:o,fillColor:h}),g.triangleShader.renderTriangle=(e={})=>{const t=e.ctx,s=e.a,r=e.b,n=e.c;t.beginPath(),t.fillStyle=h,t.moveTo(...s),t.lineTo(...r),t.lineTo(...n),t.closePath(),t.fill()},g.lineShader.renderLine=(e={})=>{const t=e.ctx,s=e.a,r=e.b,n=e.camera.inferScale(),i=e.mesh.getCustomAttribute("lineIdToMuscleId")[e.id];if(null==i){const e=.029;t.beginPath(),t.lineJoin="round",t.lineCap="round",t.strokeStyle=o,t.lineWidth=e*n,t.moveTo(s[0],s[1]),t.lineTo(r[0],r[1]),t.closePath(),t.stroke()}else{const e=u,l=p,h=.065,a=.017,c="butt",d="muscleIntensity";t.beginPath(),t.lineCap=c,t.strokeStyle=o,t.lineWidth=(h+2*a)*n,t.moveTo(s[0],s[1]),t.lineTo(r[0],r[1]),t.stroke(),t.beginPath();const m=g.getCustomAttribute(d);if(null==m)throw new Error(`muscle intensity attribute (${d}) not found, call setCustomAttribute("${d}", value) before rendering.`);if(!Array.isArray(m))throw new Error("muscle intensity attribute must be an array with values for each fiber, found "+typeof m);const f=m[i],w=(1-f)*e[0]+f*l[0],y=(1-f)*e[1]+f*l[1],x=(1-f)*e[2]+f*l[2];t.strokeStyle=`rgb(${w}, ${y}, ${x})`,t.lineCap=c,t.lineWidth=h*n,t.moveTo(s[0],s[1]),t.lineTo(r[0],r[1]),t.stroke()}},e.draggable??1){const t=this.dragBehavior=new ke.ui.DragBehavior({onDomCursorDown:(e,s)=>{if("button"in s&&0!=s.button)return;const r=this.system,n=i.domToWorldSpace(e),o=this.hitTestVertex(n);null!=o&&(this.fixVertex(o),t.beginDrag(),this.setVertexPos(r.vertices.fixedVertexId,[n[0],Math.max(0,n[1])]))},onDragProgress:e=>{const t=this.system,s=i.domToWorldSpace(e);this.setVertexPos(t.vertices.fixedVertexId,[s[0],Math.max(0,s[1])])},onDomCursorUp:()=>{this.freeVertex()}});if(!s){const s=e.domElementForMoveEvents??null;t.linkToDom(r.domElement,s)}}this.tracker=new $e}setSortedVertexIdsFromVertexDepths(e){if(e.length!=this.system.numVertices)throw new Error(`invalid size for depths, found ${e.length}, expected ${this.system.numVertices}`);const t=e.map(((e,t)=>({depth:e,index:t})));t.sort(((e,t)=>t.depth-e.depth));const s=t.map((e=>e.index));this.sortedVertexIds=s}setSize(e={}){this.renderer.setSize({width:e.width,height:e.height})}render(){(null==this.needsMeshUpdate||this.needsMeshUpdate)&&(this._updateMesh({triangles:this.system.getTrianglesArray(),muscles:this.system.getMusclesArray()}),this.needsMeshUpdate=!1);const e=this.renderer,t=this.scene,s=this.camera,r=this.mesh;this._updateFromSystem(),null!=this.dragBehavior&&this.dragBehavior.dragging()||this.tracker.step({mesh:r,camera:s,floor:this.floor,grid:this.grid,renderer:this.renderer}),e.render(t,s)}_updateMesh(e){const t=this.mesh,s=this.system.numVertices;if(!Number.isInteger(s)||s<0)throw new Error(`invalid number of vertices ${s}`);null!=e.pos&&(t.pos=e.pos),t.triangles=e.triangles,t.lines=function(e){const t=new Map;function s(e,s){const r=We([e,s]);t.set(r,[e,s])}return e.forEach((e=>{s(e[0],e[1]),s(e[1],e[2]),s(e[0],e[2])})),Array.from(t.values())}(e.triangles),Array.prototype.push.apply(t.lines,e.muscles);const r=new Map;e.muscles.forEach(((e,t)=>{r.set(We(e),t)}));const n=[];t.setCustomAttribute("lineIdToMuscleId",n),t.lines.forEach((e=>{const t=We(e),s=r.get(t);n.push(s)}));let i=this.sortedVertexIds;if(null==i){i=[];for(let e=0;e<s;e++)i.push(e)}if(i.length!=s)throw new Error(`invalid size for sortedVertexIds, found ${i.length}, expected ${s}`);t.sortedElements=ke.sorted.makeSortedElements({sortedVertexIds:i,triangles:t.triangles,edges:t.lines});const o=[],l=this.system.numMuscles;for(let e=0;e<l;e++)o.push(1);t.setCustomAttribute("muscleIntensity",o)}_updateFromSystem(){this._updateVertexPositionsFromSystem(),this._updateMuscleIntensityFromSystem()}_updateVertexPositionsFromSystem(){const e=this.mesh,t=this.system;if(0==t.numVertices)e.pos=[];else{const s=t.pos.toArray();e.pos=s}}_updateMuscleIntensityFromSystem(){const e=this.mesh,t=this.system,s=t.numMuscles;if(!Number.isInteger(s)||s<0)throw new Error(`invalid number of muscles ${s}`);let r=[];if(s>0)if(t.a){const e=t.a.slot.f32();for(let t=0;t<s;t++)r.push(e[t])}else r=new Array(s).fill(1);e.setCustomAttribute("muscleIntensity",r)}hitTestVertex(e,t=.31){return this.vertices.hitTest(e,t)}setVertexPos(e,t){this.vertices.setVertexPos(e,t)}setVertexVel(e,t){this.vertices.setVertexVel(e,t)}fixVertex(e){const t=this.system;this.setVertexVel(e,[0,0]),null==e&&(e=-1),t.vertices.fixVertex(e)}freeVertex(){this.system.vertices.freeVertex()}},ViewportVertices:ze},Be=function(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}({System:class{constructor(e={}){let t;if(null==e.ten){if(null==e.wasmInstance)throw new Error("wasmInstance required");t=new O.Engine({wasmInstance:e.wasmInstance}),this.ten=t}else t=e.ten,this.ten=t;this.h=.033,this.g=9.8,this.spaceDim=2,this._vertices=new X({ten:this.ten,vertexMass:e.vertexMass}),this._muscles=new U({ten:this.ten}),this._triangles=new class{constructor(e={}){const t=e.ten;if(null==t)throw new Error("ten required");this.ten=t,this.triangles=null,this.rsi=null}get wasmInstance(){return this.ten.wasmInstance}get memoryManager(){return this.ten.mgr}get numTriangles(){return null==this.triangles?0:this.triangles.u32().length/3}set(e={}){const t=e.indices,s=e.rsi,r=t?t.length:this.numTriangles;if(null==t&&(!s||s.length!==r))throw new Error("rsi is not consistent with the number of indices");const n=this.memoryManager,i=this.ten,o=t?n.malloc32(3*r):this.triangles;if(t&&null!=this.triangles&&this.triangles.free(),this.triangles=o,null!=t){const e=o.u32();t.forEach(((t,s)=>{const r=3*s;e[r]=t[0],e[r+1]=t[1],e[r+2]=t[2]}))}if(null!=this.rsi&&this.rsi.dispose(),this.rsi=i.zeros([r,2,2]),null==s){let t=null,s=!1;if(null!=e.pos)if(Array.isArray(e.pos))t=i.tensor(e.pos),s=!0;else if(t=e.pos,null==t.ptr)throw new Error("invalid pos");this.wasmInstance.exports.rsi_of_pos(this.numVertices,t.ptr,r,this.triangles.ptr,this.rsi.ptr),s&&t.dispose()}else this.rsi.set(s)}dispose(){null!=this.triangles&&(this.triangles.free(),this.triangles=null),null!=this.rsi&&(this.rsi.dispose(),this.rsi=null)}}({ten:this.ten})}get vertices(){return this._vertices}set fixedVertexId(e){throw new Error("System.fixedVertexId setter is deprecated, use System.vertices.fixedVertexId instead")}get fixedVertexId(){throw new Error("System.fixedVertexId getter is deprecated, use System.vertices.fixedVertexId instead")}get wasmInstance(){return this.ten.wasmInstance}get memoryManager(){return this.ten.mgr}get vertexMass(){return this._vertices.vertexMass}get triangles(){return this._triangles.triangles}set triangles(e){this._triangles.triangles=e}get rsi(){return this._triangles.rsi}set rsi(e){this._triangles.rsi=e}get k(){return this._muscles.k}set k(e){this._muscles.k=e}get pos0(){return this._vertices.pos}get vel0(){return this._vertices.vel0}get pos(){return this.pos0}get vel(){return this.vel0}get numVertices(){return this._vertices.numVertices}get numTriangles(){return this._triangles.numTriangles}get numMuscles(){return this._muscles.numMuscles}get muscles(){return this._muscles.muscles}set muscles(e){this._muscles.muscles=e}get a(){return this._muscles.a}set a(e){this._muscles.a=e}get l0(){return this._muscles.l0}set l0(e){this._muscles.l0=e}setVertices(e){this._vertices.set(e)}setMuscles(e={}){this._muscles.set({...e,pos:e.pos??this.pos0})}setTriangles(e={}){this._triangles.set({...e,pos:e.pos??this.pos0})}getMusclesArray(){if(null==this.muscles)return[];const e=this.numMuscles,t=this.muscles.u32(),s=[];for(let r=0;r<e;r++){const e=2*r;s.push([t[e],t[e+1]])}return s}getTrianglesArray(){if(null==this.triangles)return[];const e=this.numTriangles,t=this.triangles.u32(),s=[];for(let r=0;r<e;r++){const e=3*r;s.push([t[e],t[e+1],t[e+2]])}return s}set(e){this.setVertices(e.pos),this.setMuscles({indices:e.muscles??[],l0:e.musclesL0,k:e.musclesK}),this.setTriangles({indices:e.triangles??[],rsi:e.trianglesRsi})}step(){const e=this.numVertices,t=this.numMuscles,s=this.numTriangles,r=this.vertices._fixedVertexId,n=this.vertexMass;this.wasmInstance.exports.backward_euler_update(this.g,this.h,e,0==e?0:this.pos0.ptr,0==e?0:this.vel0.ptr,n,t,0==t?0:this.muscles.ptr,this.k,0==t?0:this.a.ptr,0==t?0:this.l0.ptr,s,0==s?0:this.triangles.ptr,0==s?0:this.rsi.ptr,r,0==e?0:this._vertices.pos1.ptr,0==e?0:this._vertices.posGrad.ptr,0==e?0:this._vertices.posTmp.ptr,0==e?0:this._vertices.vel1.ptr),0!=e&&(this._vertices.pos0.slot.f32().set(this._vertices.pos1.slot.f32()),this._vertices.vel0.slot.f32().set(this._vertices.vel1.slot.f32()))}dispose(){this._vertices.dispose(),this._muscles.dispose(),this._triangles.dispose()}},mmgrten:N,SystemViewport:Fe.SystemViewport,mm2d:Ae,render:Fe});function He(e,t){const s=1-Math.random(),r=Math.random();return e+Math.sqrt(-2*Math.log(s))*Math.cos(2*Math.PI*r)*t}class je{constructor(e={}){if(null==e.system)throw new Error("system required to create policy");this.system=e.system,this.ten=this.system.ten,this.active=e.active??!1,this.stochastic=e.stochastic??!1,this.stdDev=e.stdDev??.05;const t=this.system,s=this.ten,r=t.numVertices,n=t.numMuscles,i=t.spaceDim;this.projectedPos=s.zeros([r,i]),this.projectedVel=s.zeros([r,i]);const o=r*i*2,l=n;this.input=s.zeros([o]);const h=s.nn;this.model=h.Sequential(h.Linear(o,32),h.ReLU(),h.Linear(32,l),h.Tanh())}step(){const e=this.system,t=this.ten.wasmInstance,s=e.numVertices;t.exports.make_neural_policy_input(s,e.pos.ptr,e.vel.ptr,this.centerVertexId,this.forwardVertexId,this.projectedPos.ptr,this.projectedVel.ptr,this.input.ptr);const r=this.model.forward(this.input),n=this.minA,i=this.maxAbsDa,o=this.system.a,l=r.slot.f32(),h=this.system.numMuscles;for(let e=0;e<h;e++){let t;this.active?(t=r.get([e]),this.stochastic&&(t+=He(0,this.stdDev))):t=1,l[e]=t}r.clamp_({min:-i,max:i});const a=o.slot.f32();for(let e=0;e<h;e++)a[e]+=l[e];o.clamp_({min:n,max:1})}loadData(e){const t=this.model.layers[0];t.weight.set(e.fc1.weight),t.bias.set(e.fc1.bias);const s=this.model.layers[2];s.weight.set(e.fc2.weight),s.bias.set(e.fc2.bias),this.minA=e.min_a??(()=>{throw new Error("min_a required")})(),this.maxAbsDa=e.max_abs_da??(()=>{throw new Error("max_abs_da required")})(),this.centerVertexId=e.center_vertex_id??(()=>{throw new Error("center_vertex_id required")})(),this.forwardVertexId=e.forward_vertex_id??(()=>{throw new Error("forward_vertex_id required")})()}dispose(){null!=this.projectedPos&&this.projectedPos.dispose(),null!=this.projectedVel&&this.projectedVel.dispose(),null!=this.input&&this.input.dispose(),this.model.dispose()}}class Re{constructor(e={}){const t=this.domElement=document.createElement("div");t.style.userSelect="none",t.style.webkitTapHighlightColor="transparent",t.style.padding="12px",t.style.boxSizing="content-box",t.style.cursor="pointer",t.style.borderRadius="50%",t.style.minHeight=t.style.height,t.style.margin="4px",t.style.display="flex",t.style.alignItems="center",t.style.justifyContent="center",t.style.boxShadow="0 0 8px rgba(0, 0, 0, 0.2)",t.style.padding="20px",t.style.overflow="hidden",this.initSvg(),this.setSize(40),this.setInactiveStyle()}setSize(e){const t=this.domElement;t.style.width=`${e}px`,t.style.height=`${e}px`,t.style.minHeight=`${e}px`}initSvg(){const e="white",t=document.createElementNS("http://www.w3.org/2000/svg","svg");this.svg=t,t.style.width="100%",t.setAttribute("width","198"),t.setAttribute("height","217"),t.setAttribute("viewBox","0 0 198 217"),t.setAttribute("fill","none");const s=document.createElementNS("http://www.w3.org/2000/svg","path");s.setAttribute("fill-rule","evenodd"),s.setAttribute("clip-rule","evenodd"),s.setAttribute("d","M156.5 186.309L173 178.837V161.992L152.888 150.729L130.5 162.127V194.062H120.5V155.996L148 141.996V121.915L173 109.915V86.0615H183V116.208L158 128.208V142.131L177.975 153.317L197.5 142.16V76.5834L179.133 63.0079L157 75.4829L156.5 102H146.5L147 75.4371L119.5 59.4371V22.5615H129.5V53.6859L152.039 66.7998L174.42 54.185L174.077 41.482L156.5 31.2553V48.5615H146.5V13.2817L125.974 0L105 13.3103V128.519L121 117.442V89.0615H131V122.681L105 140.681V204.221L125.975 216.725L146.5 204.249V169.562H156.5V186.309Z"),s.setAttribute("fill",e),t.appendChild(s);const r=document.createElementNS("http://www.w3.org/2000/svg","path");r.setAttribute("fill-rule","evenodd"),r.setAttribute("clip-rule","evenodd"),r.setAttribute("d","M41 30.4169L24.5 37.8885V54.7333L44.6122 65.9962L67 54.5988V22.664H77V60.7291L49.5 74.7291V94.8101L24.5 106.81V130.664H14.5V100.518L39.5 88.5178V74.5946L19.5249 63.4085L0 74.5656V140.142L18.3669 153.718L40.5 141.243L41 114.725H51L50.5 141.288L78 157.288V194.164H68V163.04L45.4606 149.926L23.0796 162.54L23.4229 175.243L41 185.47V168.164H51V203.444L71.5262 216.725L92.5 203.415V88.2068L76.5 99.2837V127.664H66.5V94.0442L92.5 76.0442V12.5043L71.525 -3.05176e-05L51 12.476V47.164H41V30.4169Z"),r.setAttribute("fill",e),t.appendChild(r),this.domElement.appendChild(t)}setActiveStyle(){this.domElement.style.backgroundColor="black"}setInactiveStyle(){this.domElement.style.backgroundColor="rgba(1, 1, 1, 0.2)"}}const Ne="#000000";class Oe extends Be.SystemViewport{constructor(e={}){super(e),this.setStyle()}setStyle(){this.domElement.style.borderRadius="10px",this.domElement.style.border="2px solid #c9c9c9",this.domElement.style.boxShadow="0 0 10px rgba(0, 0, 0, 0.1)";const e=window.matchMedia("(max-width: 410px)"),t=()=>{e.matches?this.setSize({width:300,height:350}):this.setSize({width:400,height:400})};e.addEventListener("change",(e=>{t()})),t()}}class Xe{constructor(e,t){this.domElement=document.createElement("div"),this.domElement.style.textAlign="left",this.domElement.style.color="#666",this.domElement.style.fontSize="14px",this.domElement.style.padding="22px",this.domElement.style.paddingRight="26px",this.domElement.style.paddingLeft="26px",this.domElement.style.width="100%",this.domElement.style.display="flex",this.domElement.style.justifyContent="center";const s=document.createElement("div");s.style.maxWidth="600px",this.domElement.appendChild(s);const r=document.createElement("h2");this.header=r,r.style.color="black",r.style.fontSize="25px",r.style.padding="10px",r.style.borderBottom="2px solid black",r.textContent=e;const n=document.createElement("div");n.innerHTML=t,s.appendChild(r),s.appendChild(n)}setStyle1(){this.domElement.style.backgroundColor="black",this.domElement.style.color="rgb(199, 199, 199)",this.domElement.style.boxShadow="rgba(0, 0, 0, 0.3) 0px 0px 10px",this.header.style.color="white",this.header.style.borderBottom="2px solid white"}}class Ue{constructor(){this.domElement=document.createElement("div"),this.domElement.style.marginTop="16px",this.domElement.style.textAlign="left",this.domElement.style.color="#666",this.domElement.style.fontSize="14px",this.domElement.style.width="100%",this.domElement.style.display="flex",this.domElement.style.flexDirection="column";let e=new Xe("energy-based models for virtual creatures",'<p>\nThe concept of energy minimization is useful to understand physical systems as goal-directed systems.\nA deformable object that tends to recover its rest shape can be understood as a system whose goal is to minimize its elastic potential energy.\nMore generally, energy can refer to any scalar-valued function that measures compatibility between variables as a means of implicitly capturing their dependencies through energy minimization.\nThis more general notion of energy is useful to model inertia, friction, actuation mechanisms and, potentially, many other goal-directed behaviors that may or may not be conventionally considered "just physics".\n</p>');e.setStyle1(),this.domElement.appendChild(e.domElement),e=new Xe("no forces, just energy functions","<p>\nMuch like the loss function encapsulates the objective of a neural network in a single scalar value, potential energy functions offer a scalar representation of the objective of a physical system.\nIn practice, just as we typically do not compute neural network gradients by hand, we can also avoid computing forces by hand.\nThe force can be straightforwardly derived as the negative gradient of the potential energy.\nFor general energy functions that are not plain potential energy functions, the negative gradient cannot be directly interpreted as a force, but it can still be used for gradient-based optimization and is useful for implicit numerical integration methods.\n</p>"),this.domElement.appendChild(e.domElement),e=new Xe("six energy functions",'<p>\nThis implementation defines six energy functions. Some are plain potential energy functions, that is, functions of vertex positions <span class="code">E(pos)</span>. Actuation mechanisms can be modeled with an action-dependent energy function <span class="code">E(pos, a)</span>. Other energy functions may also depend on the previous state, given by vertex positions and velocities <span class="code">(pos0, vel0)</span>.\n</p>\n\n<ul>\n<li>triangles <span class="code">E(pos)</span></li>\n<li>muscles <span class="code">E(pos, a)</span></li>\n<li>gravity <span class="code">E(pos)</span></li>\n<li>collision <span class="code">E(pos)</span></li>\n<li>friction <span class="code">E(pos, pos0)</span></li>\n<li>inertia <span class="code">E(pos, pos0, vel0)</span></li>\n</ul>'),e.setStyle1(),this.domElement.appendChild(e.domElement)}}const Ge="data";async function Ye(){const e=await fetch(`${Ge}/mesh.json`);return await e.json()}async function Ze(){const e=await fetch(`${Ge}/policy.json`);return await e.json()}!async function(){document.body.style.background="rgb(248, 248, 248)",document.body.style.display="flex",document.body.style.flexDirection="column",function(){const e=document.createElement("a");document.body.appendChild(e),e.href="https://github.com/juniorrojas/algovivo",e.innerHTML='<svg style="cursor: pointer; position: absolute; top: 0; border: 0; right: 0; margin: 10px 7px;" viewBox="0 0 98 96" width="40" height="40" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M48.854 0C21.839 0 0 22 0 49.217c0 21.756 13.993 40.172 33.405 46.69 2.427.49 3.316-1.059 3.316-2.362 0-1.141-.08-5.052-.08-9.127-13.59 2.934-16.42-5.867-16.42-5.867-2.184-5.704-5.42-7.17-5.42-7.17-4.448-3.015.324-3.015.324-3.015 4.934.326 7.523 5.052 7.523 5.052 4.367 7.496 11.404 5.378 14.235 4.074.404-3.178 1.699-5.378 3.074-6.6-10.839-1.141-22.243-5.378-22.243-24.283 0-5.378 1.94-9.778 5.014-13.2-.485-1.222-2.184-6.275.486-13.038 0 0 4.125-1.304 13.426 5.052a46.97 46.97 0 0 1 12.214-1.63c4.125 0 8.33.571 12.213 1.63 9.302-6.356 13.427-5.052 13.427-5.052 2.67 6.763.97 11.816.485 13.038 3.155 3.422 5.015 7.822 5.015 13.2 0 18.905-11.404 23.06-22.324 24.283 1.78 1.548 3.316 4.481 3.316 9.126 0 6.6-.08 11.897-.08 13.526 0 1.304.89 2.853 3.316 2.364 19.412-6.52 33.405-24.935 33.405-46.691C97.707 22 75.788 0 48.854 0z" fill="#fff"/></svg>'}(),function(){const e=document.createElement("div");var t;document.body.appendChild(e),(t=e.style).display="flex",t.flexDirection="column",t.alignItems="center",t.color="white",t.width="100%",t.backgroundColor=Ne,t.paddingTop="20px",t.paddingBottom="20px",t.paddingRight="50px",t.paddingLeft="50px",t.marginBottom="30px",t.boxShadow="0 0 10px rgba(0, 0, 0, 0.3)";const s=document.createElement("h1");s.textContent="algovivo",e.appendChild(s),(e=>{e.fontSize="33px"})(s.style);const r=document.createElement("h2");r.textContent="an energy-based formulation for soft-bodied virtual creatures",e.appendChild(r),(e=>{e.textAlign="center",e.fontSize="18px",e.color="#c7c7c7"})(r.style)}();const e=document.createElement("div");e.style.display="flex",e.style.flexDirection="column",e.style.alignItems="center",e.style.width="100%",document.body.appendChild(e);const t=await async function(){const e=await fetch("algovivo.wasm");return(await WebAssembly.instantiateStreaming(e)).instance}(),s=new Be.System({wasmInstance:t});document.documentElement.style.height="100%",document.body.style.height="100%",document.body.style.display="flex",document.body.style.margin=0,document.body.style.padding=0,document.body.style.alignItems="center";const[r,n]=await Promise.all([Ye,Ze].map((e=>e())));s.set({pos:r.pos,muscles:r.muscles,musclesL0:r.l0,triangles:r.triangles,trianglesRsi:r.rsi});const i=new Oe({system:s,sortedVertexIds:r.sorted_vertex_ids,vertexDepths:r.depth});e.appendChild(i.domElement);const o=new je({system:s,stochastic:!0});o.loadData(n),window.togglePolicy=()=>{o.active=!o.active,o.active?l.setActiveStyle():l.setInactiveStyle()};const l=new Re;l.domElement.style.marginTop="8px",l.domElement.style.marginBottom="16px",l.domElement.addEventListener("click",(()=>{togglePolicy()})),e.appendChild(l.domElement);const h=new Ue;e.appendChild(h.domElement),i.render(),setInterval((()=>{o.step(),s.step(),i.render()}),1e3/30),window.system=s}();
