class e{constructor(e,t){this.list=e,this.data=t,this.next=null,this.prev=null}append(t){const s=new e(this.list,t);return this.list.last==this&&(this.list.last=s),s.next=this.next,s.prev=this,null!=this.next&&(this.next.prev=s),this.next=s,this.list.size++,s}prepend(t){const s=new e(this.list,t);return this.list.first==this&&(this.list.first=s),s.next=this,s.prev=this.prev,null!=this.prev&&(this.prev.next=s),this.prev=s,this.list.size++,s}remove(){null!=this.prev&&(this.prev.next=this.next),null!=this.next&&(this.next.prev=this.prev),this.list.first==this&&(this.list.first=this.next),this.list.last==this&&(this.list.last=this.prev),this.list.size--,this.next=null,this.prev=null}}var t=e;const s=t;class r{constructor(e){this.list=e,this.nextNode=this.list.first}next(){if(null==this.nextNode)return{done:!0};{const e={done:!1,value:this.nextNode.data};return this.nextNode=this.nextNode.next,e}}}class i{constructor(){this.first=null,this.last=null,this.size=0}isEmpty(){if(null==this.first&&null!=this.last||null!=this.first&&null==this.last)throw Error("inconsistent first last state");return null==this.first}append(e){return this.isEmpty()?this.setSingleton(e):this.last.append(e)}prepend(e){return this.isEmpty()?this.setSingleton(e):this.first.prepend(e)}setSingleton(e){const t=new s(this,e);return this.first=t,this.last=t,this.size=1,t}iter(){return new r(this)}*[Symbol.iterator](){const e=this.iter();let t=e.next();for(;!t.done;)yield t.value,t=e.next()}}var n,o,l,h,a,c,d={List:i,Node:t};function u(){if(o)return n;o=1;const e=m();return n=class extends e{constructor(e={}){super(e)}isFree(){return!1}free(){let e=this.appendFree(this.ptr,this.size);this.remove();const t=e.prev(),s=e.next();return null!=t&&t.isFree()&&(e=t.merge(e)),null!=s&&s.isFree()&&(e=e.merge(s)),e}}}function m(){return h||(h=1,l=class{constructor(e={}){this.manager=e.manager,this.ptr=e.ptr,this.size=e.size,this.node=e.node}numBytes(){return this.size}prev(){const e=this.node.prev;return null!=e?e.data:null}next(){const e=this.node.next;return null!=e?e.data:null}appendReserved(e,t){const s=u(),r=this.node.append(null),i=new s({manager:this.manager,ptr:e,size:t,node:r});return r.data=i,this.manager._addReservedSlot(i),i}appendFree(e,t){const s=p(),r=this.node.append(null),i=new s({manager:this.manager,ptr:e,size:t,node:r});return r.data=i,this.manager._addFreeSlot(i),i}remove(){this.node.remove(),this.node.data=null,this.node=null,this.isFree()?this.manager._removeFreeSlot(this):this.manager._removeReservedSlot(this)}toTypedArray(e){const t=this.size,s=e.BYTES_PER_ELEMENT;if(t%s!=0)throw new Error(`size in bytes must be a multiple of ${s}, found ${t}`);const r=this.ptr;return new e(this.manager.array,r,t/s)}f32(){return this.toTypedArray(Float32Array)}u32(){return this.toTypedArray(Uint32Array)}}),l}function p(){if(c)return a;c=1;const e=m();return a=class extends e{constructor(e={}){super(e)}isFree(){return!0}reserve(e){const t=this.numBytes();if(e>t)throw new Error(`cannot reserve ${e} bytes, only ${t} bytes are available`);const s=this.appendReserved(this.ptr,e);return s.appendFree(this.ptr+e,t-e),this.remove(),s}merge(e){if(!this.isFree()||!e.isFree())throw new Error("only free slots can be merged");if(this.next()!=e)throw new Error("only adjacent slots can be merged");const t=e.appendFree(this.ptr,this.size+e.size);return this.remove(),e.remove(),t}}}const f=d,g=p();var y={linked:d,MemoryManager:class{constructor(e,t){this.array=e,null==t&&(t=0),this.ptrToSlot=new Map,this.slots=new f.List,this.freeSlots=new f.List,this.reservedSlots=new f.List;const s=new g({manager:this,ptr:t,size:e.byteLength-t}),r=this.slots.append();r.data=s,s.node=r;const i=this.freeSlots.append();i.data=s,s.freeNode=i}numReservedSlots(){return this.reservedSlots.size}numFreeSlots(){return this.freeSlots.size}numFreeBytes(){let e=0;const t=this.freeSlots.iter();let s=t.next();for(;!s.done;)e+=s.value.size,s=t.next();return e}numReservedBytes(){let e=0;const t=this.reservedSlots.iter();let s=t.next();for(;!s.done;)e+=s.value.size,s=t.next();return e}mallocBytes(e){return this._malloc(e)}malloc32(e){return this.mallocBytes(4*e)}_addReservedSlot(e){const t=this.reservedSlots.append(e);e.reservedNode=t}_removeReservedSlot(e){if(null==e.reservedNode)throw new Error("reservedNode cannot be null");e.reservedNode.remove()}_addFreeSlot(e){const t=this.freeSlots.append(e);e.freeNode=t}_removeFreeSlot(e){if(null==e.freeNode)throw new Error("freeNode cannot be null");e.freeNode.remove()}_malloc(e){if(!Number.isInteger(e))throw new Error(`expected integer, found ${e}`);let t=null;const s=this.freeSlots.iter();let r=s.next();for(;!r.done;){const i=r.value;if(i.size>=e){t=i;break}r=s.next()}if(null==t)throw new Error("no valid free slot available");return t.reserve(e)}malloc(e){const t=this._malloc(e);return this.ptrToSlot.set(t.ptr,t),t.ptr}free(e){this.ptrToSlot.get(e).free()}},FreeSlot:p(),ReservedSlot:u()};class w{constructor(e={}){const t=e.engine;if(null==t)throw new Error("engine required to create IntTuple");this.engine=t;const s=e.slot;if(null==s)throw new Error("slot required to create IntTuple");this.slot=s,this.ptr=s.ptr,this.length=e.length}forEach(e){for(let t=0;t<this.length;t++)e(this.get(t),t)}equal(e){if(e instanceof w){for(let t=0;t<this.length;t++)if(this.get(t)!=e.get(t))return!1;return!0}if(Array.isArray(e)){for(let t=0;t<this.length;t++)if(this.get(t)!=e[t])return!1;return!0}return!1}toString(){return this.slot.u32().toString()}toArray(){const e=[];return this.forEach((t=>{e.push(t)})),e}typedArray(){return this.slot.u32()}set(e,t){this.typedArray()[e]=t}get(e){return this.typedArray()[e]}dispose(){this.slot.free()}}var v=w;function x(e,t,s,r){if(t==s.length-1)for(let i=0;i<s[t];i++)e.push(r);else for(let i=0;i<s[t];i++){const i=[];e.push(i),x(i,t+1,s,r)}}var b={inferShape:function(e){const t=[];let s=e;for(;Array.isArray(s);)t.push(s.length),s=s[0];return t},makeNdArray:function(e,t){let s=e;e instanceof v&&(s=e.toArray());const r=[];return x(r,0,s,t),r},numelOfShape:function(e){let t=1;return e.forEach((e=>{t*=e})),t},getArrElem:function e(t,s){if(!Array.isArray(s))throw new Error(`expected array, found ${typeof s}: ${s}`);return 0==s.length?t:e(t[s[0]],s.slice(1))},setArrElem:function e(t,s,r){if(!Array.isArray(s))throw new Error(`expected array, found ${typeof s}: ${s}`);if(1!=s.length)return e(t[s[0]],s.slice(1),r);t[s]=r}};const E=v;class S{constructor(e){if(null==e)throw new Error("shape required");if(!(e instanceof E))throw new Error(`IntTuple shape expected, found ${typeof e}: shape`);this.shape=e,this.done=!1,this.idx=[],e.forEach((e=>{this.idx.push(0)}))}next(){const e=this.shape;for(let t=0;t<e.length;t++){const s=e.length-1-t;if(this.idx[s]<e.get(s)-1)return void this.idx[s]++;if(0==s)return void(this.done=!0);this.idx[s]=0}}static shapeForEach(e,t){const s=new S(e);for(;!s.done;)t(s.idx),s.next()}}const V=b,I=S,C=v;class A{constructor(e={}){const t=e.engine;if(null==t)throw new Error("engine required to create tensor");this.engine=t;const s=e.shape;if(null==s)throw new Error("shape required to create tensor");if(s instanceof C)this.shape=s;else{if(!Array.isArray(s))throw new Error(`invalid shape type ${typeof s}: ${s}`);this.shape=t.intTuple(s)}this.order=this.shape.length;const r=V.numelOfShape(this.shape);this.numel=r;const i=e.slot;if(r>0&&null==i)throw new Error("memory slot required to create tensor");this.slot=e.slot;const n=e.stride;if(null!=n){if(!(n instanceof C))throw new Error(`expected IntTuple stride, found ${typeof n}: ${n}`);this.stride=n}else this.setDefaultStride()}get ptr(){return this.slot.ptr}get wasmInstance(){return this.engine.wasmInstance}isScalar(){return 0==this.order}fill_(e){this.wasmInstance.exports.fill_(this.numel,this.ptr,e)}clamp_(e={}){const t=e.min,s=e.max;this.wasmInstance.exports.clamp(this.numel,this.ptr,this.ptr,t,s,null!=t,null!=s)}zero_(){this.fill_(0)}flattenIdx(e){let t,s,r=!1;if(Array.isArray(e)&&(t=this.engine.intTuple(e),r=!0),!(t instanceof C))throw new Error(`cannot handle ${typeof t}: ${t}`);return s=this.engine.wasmInstance.exports.flatten_idx(this.order,t.slot.ptr,this.stride.slot.ptr),r&&t.dispose(),s}typedArray(){return this.slot.f32()}toArray(){if(0==this.numel)return[];const e=V.makeNdArray(this.shape,0);return this.forEach((t=>{const s=this.get(t);V.setArrElem(e,t,s)})),e}get(e){const t=this.flattenIdx(e);return this.typedArray()[t]}item(){if(!this.isScalar())throw new Error(`item() only works for scalars, found tensor with shape ${this.shape}`);return this.get([0])}setDefaultStride(){let e=1;const t=this.order,s=[];for(let e=0;e<t;e++)s.push(0);for(let r=0;r<t;r++){const i=t-1-r;s[i]=e,e*=this.shape.get(i)}this.stride=this.engine.intTuple(s)}setFromArray(e){if(0!=this.numel)if(this.isScalar()){if("number"!=typeof e)throw new Error(`expected number, found ${typeof e}: ${e}`);this.set([0],e)}else{if(!Array.isArray(e))throw new Error(`expected array, found ${typeof e}: ${e}`);const t=V.inferShape(e);if(!this.shape.equal(t))throw new Error(`inconsistent shapes ${t} != ${this.shape}`);this.forEach((t=>{const s=V.getArrElem(e,t);this.set(t,s)}))}}set(e,t){if(null==t&&Array.isArray(e))this.setFromArray(e);else{const s=this.flattenIdx(e);this.typedArray()[s]=t}}forEach(e){I.shapeForEach(this.shape,e)}squeeze(e){-1==e&&(e=this.shape.length-1);const t=this.shape.get(e);if(1!=t)throw new Error(`cannot squeeze a dimension that is not equal to 1, shape[${e}] = ${t}`);const s=[];for(let t=0;t<this.order;t++)e!=t&&s.push(this.shape.get(t));return new A({engine:this.engine,shape:s,slot:this.slot})}unsqueeze(e){-1==e&&(e=this.shape.length-1);const t=[];for(let s=0;s<this.order;s++)t.push(this.shape.get(s)),e==s&&t.push(1);return new A({engine:this.engine,shape:t,slot:this.slot})}add(e,t){this.engine.functional.add(this,e,t)}sum(e){this.engine.wasmInstance.exports.sum(this.numel,this.slot.ptr,e.slot.ptr)}dispose(){if(null==this.slot)throw new Error("tensor already disposed");this.slot.free(),this.slot=null,this.shape.dispose(),this.stride.dispose()}}var L=A,M=class{constructor(){}};const T=M;const _=M;const z=M;const k=M;const D=class extends T{constructor(e,t){super(),this.nn=e,this.layers=t}forward(e){let t=e;return this.layers.forEach((e=>{t=e.forward(t)})),t}dispose(){this.layers.forEach((e=>{e.dispose()}))}},q=class extends _{constructor(e,t,s){super(),this.nn=e,this.inputSize=t,this.outputSize=s;const r=this.nn.engine;this.weight=r.zeros([s,t]),this.bias=r.zeros([s]),this.output=r.zeros([s])}forward(e){const t=this.nn.engine.functional;return t.matvec(this.weight,e,this.output),t.add(this.output,this.bias,this.output),this.output}dispose(){this.weight.dispose(),this.bias.dispose(),this.output.dispose()}},$=class extends z{constructor(e){super(),this.nn=e,this.output=null}forward(e){const t=this.nn.engine;return null==this.output&&(this.output=t.zerosLike(e)),t.functional.relu(e,this.output),this.output}dispose(){null!=this.output&&this.output.dispose()}},W=class extends k{constructor(e){super(),this.nn=e,this.output=null}forward(e){const t=this.nn.engine;return null==this.output&&(this.output=t.zerosLike(e)),t.functional.tanh(e,this.output),this.output}dispose(){null!=this.output&&this.output.dispose()}},P=y,F=b,j=L,B=v,H=class{constructor(e={}){const t=this.engine=e.engine;this.wasmInstance=t.wasmInstance}matvec(e,t,s){const r=e.shape.get(0),i=e.shape.get(1),n=t.shape.get(0),o=s.shape.get(0);if(r!=o)throw new Error(`inconsistent output size ${r} != ${o}`);if(i!=n)throw new Error(`inconsistent input size ${i} != ${n}`);this.wasmInstance.exports.matvec(r,i,e.stride.ptr,e.ptr,t.stride.ptr,t.ptr,s.stride.ptr,s.ptr)}mm(e,t,s){const r=e.shape.get(0),i=e.shape.get(1),n=t.shape.get(1);this.wasmInstance.exports.mm(r,i,n,e.stride.ptr,e.ptr,t.stride.ptr,t.ptr,s.stride.ptr,s.ptr)}relu(e,t){this.wasmInstance.exports.relu(e.numel,e.ptr,t.ptr)}tanh(e,t){const s=e.numel,r=e.typedArray(),i=t.typedArray();for(let e=0;e<s;e++)i[e]=Math.tanh(r[e])}add(e,t,s){this.wasmInstance.exports.add(e.numel,e.ptr,t.ptr,s.ptr)}sum(e,t){this.wasmInstance.exports.sum(e.numel,e.ptr,t.ptr)}sumBackward(e,t,s,r){this.wasmInstance.exports.sum_backward(e.numel,e.ptr,t.ptr,s.ptr,r.ptr)}},R=class{constructor(e={}){null!=e.wasmInstance&&this.init(e),this.env={}}init(e={}){if(null==e.wasmInstance)throw new Error("wasmInstance required");this.wasmInstance=e.wasmInstance;const t=e.wasmInstance.exports.memory.buffer,s=new P.MemoryManager(t,e.wasmInstance.exports.__heap_base);this.mgr=s,this.functional=this.F=new H({engine:this}),this.nn=new class{constructor(e={}){this.engine=e.engine}Linear(e,t){return new q(this,e,t)}ReLU(){return new $(this)}Tanh(){return new W(this)}Sequential(){const e=Array.from(arguments);return new D(this,e)}}({engine:this}),this._mergeF()}_mergeF(){Object.getOwnPropertyNames(Object.getPrototypeOf(this.F)).forEach((e=>{"constructor"!=e&&(this[e]=this.F[e])}))}tensor(e){const t=F.inferShape(e),s=this.intTuple(t),r=F.numelOfShape(t),i=this.mgr.malloc32(r),n=new j({engine:this,shape:s,slot:i});return n.setFromArray(e),n}intTuple(e){if(!Array.isArray(e))throw new Error(`expected array, found ${typeof e}: ${e}`);const t=e.length,s=this.mgr.malloc32(t),r=new B({engine:this,length:t,slot:s});for(let s=0;s<t;s++)r.set(s,e[s]);return r}zerosLike(e){if(!(e instanceof j))throw new Error(`expected tensor, found ${typeof e}: ${e}`);return this.zeros(e.shape.toArray())}empty(e){let t;if(e instanceof B)t=e;else{if(!Array.isArray(e))throw new Error(`expected array, found ${typeof e}: ${e}`);t=this.intTuple(e)}const s=F.numelOfShape(t),r=this.mgr.malloc32(s);return new j({engine:this,shape:t,slot:r})}zeros(e){const t=this.empty(e);return t.zero_(),t}ones(e){const t=this.empty(e);return t.fill_(1),t}};var N={engine:function(e={}){return new R({wasmInstance:e.wasmInstance})},Engine:R,Tensor:L,mmgr:y,utils:b},O=class{constructor(e={}){const t=e.ten;if(null==t)throw new Error("ten required");this.ten=t,this.spaceDim=e.spaceDim??2,this.vertexMass=e.vertexMass??6.0714287757873535,this.pos0=null,this.pos1=null,this.vel0=null,this.vel1=null,this.posGrad=null,this.posTmp=null,this._fixedVertexId=-1}getVertexPos(e){const t=[];for(let s=0;s<this.spaceDim;s++)t.push(this.pos.get([e,s]));return t}set fixedVertexId(e){throw new Error("use fixVertex instead")}get fixedVertexId(){return this._fixedVertexId}fixVertex(e){this._fixedVertexId=e}freeVertex(){this._fixedVertexId=-1}get pos(){return this.pos0}get vel(){return this.vel0}get numVertices(){return null==this.pos0?0:this.pos0.shape.get(0)}updateTmpBuffers(){if(null==this.pos0)throw new Error("pos0 required");const e=this.numVertices,t=this.spaceDim,s=this.ten,r=s.zeros([e,t]);null!=this.posGrad&&this.posGrad.dispose(),this.posGrad=r;const i=s.zeros([e,t]);null!=this.posTmp&&this.posTmp.dispose(),this.posTmp=i}get wasmInstance(){return this.ten.wasmInstance}get memoryManager(){return this.ten.mgr}set(e){const t=this.ten,s=this.spaceDim;if(null==e)throw new Error("pos required");const r=e.length,i=t.tensor(e);null!=this.pos0&&this.pos0.dispose(),this.pos0=i;const n=t.zeros([r,s]);null!=this.pos1&&this.pos1.dispose(),this.pos1=n;const o=t.zeros([r,s]);null!=this.vel0&&this.vel0.dispose(),this.vel0=o;const l=t.zeros([r,s]);null!=this.vel1&&this.vel1.dispose(),this.vel1=l,this.updateTmpBuffers()}addVertex(e={}){const t=this.ten,s=this.numVertices,r=this.spaceDim,i=t.empty([s+1,r]),n=t.empty([s+1,r]),o=t.empty([s+1,r]),l=t.empty([s+1,r]);for(let e=0;e<s;e++)for(let t=0;t<r;t++)i.set([e,t],this.pos0.get([e,t])),n.set([e,t],this.vel0.get([e,t])),o.set([e,t],this.pos1.get([e,t])),l.set([e,t],this.vel1.get([e,t]));const h=e.pos??[0,0],a=e.vel??[0,0];for(let e=0;e<r;e++)i.set([s,e],h[e]),o.set([s,e],h[e]),n.set([s,e],a[e]),l.set([s,e],a[e]);null!=this.pos0&&this.pos0.dispose(),this.pos0=i,null!=this.vel0&&this.vel0.dispose(),this.vel0=n,null!=this.pos1&&this.pos1.dispose(),this.pos1=o,null!=this.vel1&&this.vel1.dispose(),this.vel1=l,this.updateTmpBuffers()}dispose(){null!=this.pos0&&(this.pos0.dispose(),this.pos0=null),null!=this.pos1&&(this.pos1.dispose(),this.pos1=null),null!=this.vel0&&(this.vel0.dispose(),this.vel0=null),null!=this.vel1&&(this.vel1.dispose(),this.vel1=null),null!=this.posGrad&&(this.posGrad.dispose(),this.posGrad=null),null!=this.posTmp&&(this.posTmp.dispose(),this.posTmp=null)}};const U=N,X=O,G=class{constructor(e={}){const t=e.ten;if(null==t)throw new Error("ten required");this.ten=t,this.indices=null,this.k=Math.fround(90),this.l0=null,this.a=null}get wasmInstance(){return this.ten.wasmInstance}get memoryManager(){return this.ten.mgr}get numMuscles(){return null==this.indices?0:this.indices.u32().length/2}set(e={}){if(null==e.indices)throw new Error("indices required");const t=e.indices,s=t.length,r=this.numMuscles,i=this.memoryManager,n=this.ten;null!=e.k&&(this.k=e.k);const o=i.malloc32(2*s);null!=this.indices&&this.indices.free(),this.indices=o;const l=o.u32();if(t.forEach(((e,t)=>{const s=2*t;l[s]=e[0],l[s+1]=e[1]})),null!=this.l0&&this.l0.dispose(),this.l0=null,0!=s){const t=n.zeros([s]);this.l0=t,null==e.l0?this.wasmInstance.exports.l0_of_pos(this.numVertices,e.pos.ptr,s,this.indices.ptr,this.l0.ptr):this.l0.set(e.l0)}const h=e.keepA??!1;if(s!=r){if(h)throw new Error(`keepA can only be true when the number of muscles is the same (${s} != ${r})`);if(null!=this.a&&(this.a.dispose(),this.a=null),0!=s){const e=n.zeros([s]);this.a=e,e.fill_(1)}}else 0==s?(null!=this.a&&this.a.dispose(),this.a=null):h||this.a.fill_(1)}toStepArgs(){const e=this.numMuscles;return[e,0==e?0:this.indices.ptr,this.k,0==e?0:this.a.ptr,0==e?0:this.l0.ptr]}dispose(){null!=this.indices&&(this.indices.free(),this.indices=null),null!=this.l0&&(this.l0.dispose(),this.l0=null),null!=this.a&&(this.a.dispose(),this.a=null)}};function Y(e){return[e[0],e[1]]}function Z(e,t){e[0]*=t,e[1]*=t}function K(e,t){const s=Y(e);return Z(s,t),s}function J(e){return e[0]*e[0]+e[1]*e[1]}function Q(e){return Math.sqrt(J(e))}var ee={clone:Y,add:function(e,t){return[e[0]+t[0],e[1]+t[1]]},add_:function(e,t){e[0]+=t[0],e[1]+=t[1]},mulScalar_:Z,mulScalar:K,sub:function(e,t){return[e[0]-t[0],e[1]-t[1]]},quadrance:J,norm:Q,normalize:function(e){return K(e,1/Q(e))},dot:function(e,t){return e[0]*t[0]+e[1]*t[1]}};class te{constructor(e,t,s,r){this.m00=e,this.m01=t,this.m10=s,this.m11=r}get(e,t){return this[`m${e}${t}`]}set(e,t,s,r){this.m00=e,this.m01=t,this.m10=s,this.m11=r}toArray(){return[[this.m00,this.m01],[this.m10,this.m11]]}negate(){return new te(-this.m00,-this.m01,-this.m10,-this.m11)}apply(e){return[this.m00*e[0]+this.m01*e[1],this.m10*e[0]+this.m11*e[1]]}det(){return this.m00*this.m11-this.m10*this.m01}inv(){const e=this.det();return new te(this.m11/e,-this.m01/e,-this.m10/e,this.m00/e)}mm(e){const t=this.m00,s=this.m01,r=this.m10,i=this.m11,n=e.m00,o=e.m01,l=e.m10,h=e.m11;return new te(t*n+s*l,t*o+s*h,r*n+i*l,r*o+i*h)}t(){return new te(this.m00,this.m10,this.m01,this.m11)}static fromArray(e){return new te(e[0][0],e[0][1],e[1][0],e[1][1])}}var se=te;const re=se,ie=ee;class ne{constructor(){this.translation=[0,0],this.linear=new re(1,0,0,1)}inferScale(){return this.linear.m00}apply(e){return ie.add(this.linear.apply(e),this.translation)}inv(){const e=new ne;return e.linear=this.linear.inv(),e.translation=e.linear.negate().apply(this.translation),e}toColumnMajorArray(){return[this.linear.get(0,0),this.linear.get(1,0),this.linear.get(0,1),this.linear.get(1,1),this.translation[0],this.translation[1]]}}var oe={Vec2:ee,Matrix2x2:se,Transform2d:ne,AABB:class{constructor(e={}){if(null==e.x0)throw new Error("x0 required");if(null==e.y0)throw new Error("y0 required");this._x0=e.x0,this._y0=e.y0;let t=null;if(null!=e.width)t=this._x0+e.width;else{if(null==e.x1)throw new Error("x1 required");t=e.x1}this._x1=t;let s=null;if(null!=e.height)s=this._y0+e.height;else{if(null==e.y1)throw new Error("y1 required");s=e.y1}this._y1=s}get x0(){return this._x0}get x1(){return this._x1}get y0(){return this._y0}get y1(){return this._y1}get width(){return this._x1-this._x0}get height(){return this._y1-this._y0}get center(){return[.5*(this.x0+this.x1),.5*(this.y0+this.y1)]}}};const le=oe;var he={PointShader:class{constructor(){}renderPoint(e={}){const t=e.ctx,s=e.p;t.beginPath(),t.arc(s[0],s[1],3,0,2*Math.PI),t.fill()}},LineShader:class{constructor(){}renderLine(e={}){const t=e.ctx,s=e.a,r=e.b;t.beginPath(),t.strokeStyle="red",t.lineWidth=5,t.moveTo(s[0],s[1]),t.lineTo(r[0],r[1]),t.closePath(),t.stroke()}},TriangleShader:class{constructor(){}renderTriangle(e={}){const t=e.ctx,s=e.a,r=e.b,i=e.c;t.save(),t.beginPath(),t.strokeStyle="black",t.moveTo(s[0],s[1]),t.lineTo(r[0],r[1]),t.lineTo(i[0],i[1]),t.closePath(),t.stroke(),t.restore()}}};const ae=oe,ce=he;var de=class{constructor(e={}){this.scene=e.scene,this.id=e.id,this.x=[],this.triangles=[],this.lines=[],this.pointShader=new ce.PointShader({}),this.lineShader=new ce.LineShader({}),this.triangleShader=new ce.TriangleShader({}),this.customAttributes={}}get pos(){return this.x}set pos(e){this.x=e}numVertices(){return this.pos.length}numTriangles(){return this.triangles.length}numLines(){return this.lines.length}setCustomAttribute(e,t){this.customAttributes[e]=t}getCustomAttribute(e){return this.customAttributes[e]}computeAABB(){let e=null,t=null,s=null,r=null;return this.pos.forEach((i=>{const n=i[0],o=i[1];(null==e||n<e)&&(e=n),(null==t||n>t)&&(t=n),(null==s||o<s)&&(s=o),(null==r||o>r)&&(r=o)})),new ae.AABB({x0:e,y0:s,x1:t,y1:r})}computeCenter(){const e=this.pos.length;if(0==e)throw new Error("no vertices to compute center");let t=[0,0];for(let s=0;s<e;s++){const e=this.pos[s];ae.Vec2.add_(t,e)}return ae.Vec2.mulScalar_(t,1/e),t}};const ue=de;const me=de;var pe={Camera:class{constructor(){this.transform=new le.Transform2d}domToWorldSpace(e){if(!Array.isArray(e))throw new Error("array expected, found "+typeof e);if(2!=e.length)throw new Error(`array with 2 elements expected, found ${e.length}`);return this.transform.inv().apply(e)}inferScale(){return this.transform.inferScale()}center(e={}){let t=e.viewportWidth,s=e.viewportHeight;const r=e.renderer;if((null==t||null==s)&&null==r)throw new Error("renderer required");if(null!=r&&(t=r.width,s=r.height),null==t)throw new Error("viewportWidth required");if(null==s)throw new Error("viewportHeight required");let i,n=e.zoom??1;if(null!=e.worldWidth&&(n=t/e.worldWidth),this.transform.linear=new le.Matrix2x2(n,0,0,-n),null!=e.worldCenter){const r=e.worldCenter;i=[.5*t-r[0]*n,.5*s+r[1]*n]}else i=[.5*t,.5*s];this.transform.translation=i}},Mesh:de,Renderer:class{constructor(e={}){const t=e.headless??!1;if(this.headless=t,!t){const e=document.createElement("canvas");this.domElement=e,this.ctx=e.getContext("2d")}this.setSize({width:200,height:200})}setSize(e){const t=e.width;if(null==t)throw new Error("width required to setSize");const s=e.height;if(null==s)throw new Error("height required to setSize");let r=e.viewportWidth;null==r&&(r=t);let i=e.viewportHeight;if(null==i&&(i=s),this.width=t,this.height=s,this.viewportWidth=r,this.viewportHeight=i,!this.headless){const e=this.domElement;e.width=r,e.height=i,e.style.width=`${t}px`,e.style.height=`${s}px`}}renderPoint(e,t,s,r,i){const n=this.ctx;let o;if(!(t instanceof ue))throw new Error("invalid mesh");o=t.pos[r];const l=s.transform.apply(o);n.save(),t.pointShader.renderPoint({ctx:n,renderer:e,mesh:t,camera:s,id:r,p:l,custom:i}),n.restore()}renderLine(e,t,s,r,i){const n=this.ctx,o=t.lines[r],l=s.transform.apply(t.pos[o[0]]),h=s.transform.apply(t.pos[o[1]]);n.save(),t.lineShader.renderLine({ctx:n,renderer:e,mesh:t,camera:s,id:r,a:l,b:h,custom:i}),n.restore()}renderTriangle(e,t,s,r,i){const n=this.ctx,o=t.triangles[r],l=o[0],h=o[1],a=o[2];let c,d,u;if(t.pos instanceof Float32Array){const e=2;c=[t.pos[l*e],t.pos[l*e+1]],d=[t.pos[h*e],t.pos[h*e+1]],u=[t.pos[a*e],t.pos[a*e+1]]}else c=t.pos[l],d=t.pos[h],u=t.pos[a];const m=s.transform.apply(c),p=s.transform.apply(d),f=s.transform.apply(u);n.save(),t.triangleShader.renderTriangle({ctx:n,renderer:e,mesh:t,camera:s,id:r,a:m,b:p,c:f,custom:i}),n.restore()}renderMesh(e,t,s,r={}){const i=t.sortedElements;if(null==i){for(let i=0;i<t.triangles.length;i++)this.renderTriangle(e,t,s,i,r);for(let i=0;i<t.lines.length;i++)this.renderLine(e,t,s,i,r);for(let i=0;i<t.pos.length;i++)this.renderPoint(e,t,s,i,r)}else i.forEach((i=>{if(null==i.order)throw new Error(`invalid element, order not defined ${i}`);if(1==i.order)this.renderPoint(e,t,s,i.id,r);else if(2==i.order)this.renderLine(e,t,s,i.id,r);else{if(3!=i.order)throw new Error(`invalid element ${i}`);this.renderTriangle(e,t,s,i.id,r)}}))}render(e,t,s={}){this.ctx.clearRect(0,0,this.viewportWidth,this.viewportHeight),e.meshes.forEach((e=>{this.renderMesh(this,e,t,s)}))}},Scene:class{constructor(){this.meshes=new Map}clean(){this.meshes=new Map}numMeshes(){return this.meshes.size}addMesh(){const e=this.meshes.size,t=new me({scene:this,id:e});return this.meshes.set(e,t),t}}},fe={computeDomCursor:function(e,t){let s,r;if(null==e.touches)s=e.clientX,r=e.clientY;else{if(0==e.touches.length)return null;const t=e.touches[0];s=t.clientX,r=t.clientY}let i=new DOMMatrix,n=t;for(;null!=n;){const e=window.getComputedStyle(n);i=new DOMMatrix(e.transform).multiply(i),n=n.parentElement}const o=i.inverse(),l=new DOMPointReadOnly(s,r).matrixTransform(o),h=t.getBoundingClientRect(),a=new DOMPointReadOnly(h.left,h.top).matrixTransform(o);return[l.x-a.x,l.y-a.y]}};const ge=fe;var ye={cursorUtils:fe,DragBehavior:class{constructor(e={}){this._dragging=!1,this.onDomCursorDown=e.onDomCursorDown,this.onDragProgress=e.onDragProgress,this.onDomCursorUp=e.onDomCursorUp,this.domElement=null}beginDrag(){this._dragging=!0}endDrag(){this._dragging=!1}dragging(){return this._dragging}domCursorDown(e,t){null!=this.onDomCursorDown&&this.onDomCursorDown(e,t)}domCursorMove(e,t){this.dragging()&&null!=this.onDragProgress&&this.onDragProgress(e,t)}domCursorUp(e,t){this.endDrag(),null!=this.onDomCursorUp&&this.onDomCursorUp(e,t)}linkToDom(e,t=null){if(null!=this.domElement)throw new Error("already linked to DOM");this.domElement=e;const s=t=>{t.preventDefault();const s=ge.computeDomCursor(t,e);this.domCursorDown(s,t)};e.addEventListener("mousedown",s,{passive:!1}),e.addEventListener("touchstart",s,{passive:!1});const r=t=>{const s=ge.computeDomCursor(t,e);this.domCursorMove(s,t)};null==t&&(t=e),t.addEventListener("mousemove",r,{passive:!1}),t.addEventListener("touchmove",r,{passive:!1});const i=t=>{const s=ge.computeDomCursor(t,e);this.domCursorUp(s,t)};window.addEventListener("mouseup",i),window.addEventListener("touchend",i),window.addEventListener("touchcancel",i)}}};class we{constructor(e={}){if(null==e.scene)throw new Error("scene required");const t=null==e.color?"rgba(0, 0, 0, 0.30)":e.color,s=this.mesh=e.scene.addMesh();this.set(e),s.setCustomAttribute("translation",[0,0]),s.pointShader.renderPoint=()=>{},s.lineShader.renderLine=we.makeGridLineShader({color:t})}get numVertices(){return this.mesh.x.length}get numLines(){return this.mesh.lines.length}set(e={}){const t=null==e.cellSize?1:e.cellSize,s=null==e.innerCells?3:e.innerCells,r=null==e.rows?3:e.rows,i=null==e.cols?4:e.cols,n=null==e.x0?-2:e.x0,o=null==e.y0?0:e.y0,l=null==e.primaryLineWidth?.03:e.primaryLineWidth,h=null==e.secondaryLineWidth?.008:e.secondaryLineWidth,a=this.mesh,{x:c,lineIndices:d,lineWidths:u}=function(e={}){const t=null==e.cellSize?1:e.cellSize,s=null==e.innerCells?3:e.innerCells,r=null==e.rows?3:e.rows,i=null==e.cols?4:e.cols,n=null==e.x0?-2:e.x0,o=null==e.y0?0:e.y0,l=null==e.primaryLineWidth?.022:e.primaryLineWidth,h=null==e.secondaryLineWidth?.008:e.secondaryLineWidth,a=[],c=[],d=[],u=o+r*t,m=n+i*t;function p(e,t){for(let r=0;r<e+1;r++){const i=r==e?1:s;for(let e=0;e<i;e++){const s=2*c.length;t(r,e,i,a),c.push([s,s+1]),0==e?d.push(l):d.push(h)}}}return p(r,((e,s,r,i)=>{const l=s/r,h=(o+e*t)*(1-l)+(o+(e+1)*t)*l;i.push([n,h]),i.push([m,h])})),p(i,((e,s,r,i)=>{const l=s/r,h=(n+e*t)*(1-l)+(n+(e+1)*t)*l;i.push([h,o]),i.push([h,u])})),{x:a,lineIndices:c,lineWidths:d}}({cellSize:t,innerCells:s,rows:r,cols:i,x0:n,y0:o,primaryLineWidth:l,secondaryLineWidth:h});a.pos=c,a.lines=d,a.setCustomAttribute("lineWidths",u)}static makeGridLineShader(e={}){const t=null==e.color?"black":e.color;return e=>{const s=e.ctx,r=e.a,i=e.b,n=e.camera,o=e.mesh,l=n.inferScale();s.beginPath(),s.strokeStyle=t;const h=o.getCustomAttribute("lineWidths");if(null==h)throw new Error("custom attribute lineWidths missing");const a=h[e.id],c=o.getCustomAttribute("translation"),d=[l*c[0],l*c[1]];s.lineWidth=a*l,s.moveTo(r[0]+d[0],r[1]+d[1]),s.lineTo(i[0]+d[0],i[1]+d[1]),s.closePath(),s.stroke()}}}var ve={Grid:we,Background:class{constructor(e={}){if(null==e.scene)throw new Error("scene required");const t=this.mesh=e.scene.addMesh();t.pos=[[0,0]];const s=null==e.color1?"#fcfcfc":e.color1,r=null==e.color2?"#d7d8d8":e.color2;t.pointShader.renderPoint=(e={})=>{const t=e.renderer.width,i=e.renderer.height,n=e.ctx,o=n.createRadialGradient(.5*t,.5*i,.05*t,.5*t,.5*i,.5*t);o.addColorStop(0,s),o.addColorStop(1,r),n.fillStyle=o,n.fillRect(0,0,t,i)}}}},xe=class{constructor(e,t){if(null==e)throw new Error("id required to create simplex");this.order=t.length,this.id=e,this.vertexIds=t}};const be=xe;function Ee(e){return e.sort(),e.join("_")}var Se=class{constructor(e={}){if(null==e.order)throw new Error("order required");this.order=e.order,this.simplicesByHash=new Map}forEach(e){this.simplicesByHash.forEach(e)}size(){return this.simplicesByHash.size}has(e){return this.simplicesByHash.has(Ee(e.vertexIds))}add(e,t){let s=null;if(Array.isArray(e)){if(null==t)throw new Error("id required");s=e,e=new be(t,s)}else{if(s=e.vertexIds,null==s)throw new Error(`vertexIds required ${e}`);t=e.id}if(s.length!=this.order)throw new Error(`expected ${this.order} vertices, found ${s.length}`);const r=Ee(s);return this.simplicesByHash.set(r,e),e}};const Ve=Se,Ie=Se;var Ce=class{constructor(e={}){this.vertices=new Map,this.edges=new Ie({order:2}),this.triangles=new Ie({order:3}),(e.edges??[]).forEach(((e,t)=>{this.addEdge(t,e)})),(e.triangles??[]).forEach(((e,t)=>{this.addTriangle(t,e)}))}numVertices(){return this.vertices.size}numEdges(){return this.edges.size()}numTriangles(){return this.triangles.size()}getVertexById(e,t=!1){let s=this.vertices.get(e);return null==s&&t&&(s=new class{constructor(e){this.id=e,this.edges=new Ve({order:2}),this.triangles=new Ve({order:3})}addTriangle(e,t){this.triangles.add(e,t)}addEdge(e,t){this.edges.add(e,t)}}(e),this.vertices.set(e,s)),s}addEdge(e,t){const s=this.edges.add(t,e);return t.forEach((e=>{this.getVertexById(e,!0).addEdge(s)})),s}addTriangle(e,t){const s=this.triangles.add(t,e);return t.forEach((e=>{this.getVertexById(e,!0).addTriangle(s)})),s}};const Ae=Ce,Le=Se;var Me={math:oe,ui:ye,shaders:he,background:ve,sorted:{makeSortedElements:function(e={}){if(null==e.sortedVertexIds)throw new Error("sortedVertexIds required");if(null==e.triangles)throw new Error("triangles required");if(null==e.edges)throw new Error("edges required");const t=e.sortedVertexIds,s=new Map;t.forEach(((e,t)=>{s.set(e,t)}));const r=new Ae({triangles:e.triangles}),i=new Ae({edges:e.edges}),n=[],o=new Le({order:3}),l=new Le({order:2});return t.forEach((e=>{const t=r.getVertexById(e,!0).triangles,h=i.getVertexById(e,!0).edges,a=[];t.forEach((e=>{a.push(e)})),h.forEach((e=>{a.push(e)})),a.sort(((e,t)=>{const r=e.vertexIds.map((e=>s.get(e))),i=t.vertexIds.map((e=>s.get(e))),n=Math.max(...r),o=Math.max(...i);return n<o?1:n==o?0:-1})),a.forEach((e=>{if(2==e.order){const t=e;l.has(t)||(n.push(t),l.add(t))}else{const t=e;o.has(t)||(n.push(t),o.add(t))}})),n.push({order:1,id:e})})),n},MeshTopology:Ce,Simplex:xe,Simplices:Se},core:pe,Renderer:pe.Renderer,Camera:pe.Camera,Scene:pe.Scene},Te=class{constructor(e={}){this.targetCenterX=null,this.currentCenterX=null,this.active=!0,this.visibleWorldWidth=e.visibleWorldWidth??3.8,this.targetCenterY=e.targetCenterY??1,this.offsetX=e.offsetX??0,this.fullGrid=!1,this.centeringSpeedFactor=.5}step(e={}){if(!this.active)return;const t=e.renderer,s=e.camera,r=e.mesh,i=e.floor,n=e.grid;let o=[0,0];r.pos.length>0&&(o=r.computeCenter());const l=o[0]+this.offsetX;isNaN(l)||(this.targetCenterX=l),null==this.currentCenterX?this.currentCenterX=this.targetCenterX:this.currentCenterX+=(this.targetCenterX-this.currentCenterX)*this.centeringSpeedFactor;const h=[this.currentCenterX,this.targetCenterY];s.center({worldCenter:h,worldWidth:this.visibleWorldWidth,viewportWidth:t.width,viewportHeight:t.height});const a=s.domToWorldSpace([t.width,0]),c=s.domToWorldSpace([0,t.height]),[d,u]=c,m=Math.floor(d)-1;let p=Math.floor(u);this.fullGrid||p<0&&(p=0);const[f,g]=a,y=f,w=y-m,v=g-p,x=Math.ceil(v)+1,b=Math.ceil(w)+1;n.set({x0:m,y0:p,rows:x,cols:b,innerCells:n.innerCells,primaryLineWidth:n.primaryLineWidth,secondaryLineWidth:n.secondaryLineWidth}),i.mesh.pos=[[m,0],[y,0]]}};class _e{constructor(e={}){if(null==e.scene)throw new Error("scene required");const t=this.scene=e.scene,s=this.mesh=t.addMesh();s.pos=[[-10,0],[10,0]],s.lines=[[0,1]],s.lineShader.renderLine=_e.makeFloorLineShaderFunction({width:e.width,color:e.color}),s.pointShader.renderPoint=()=>{},s.setCustomAttribute("translation",[0,0])}static makeFloorLineShaderFunction(e={}){const t=e.width??.055,s=e.color??"black";return e=>{const r=e.ctx,i=e.a,n=e.b,o=e.camera,l=e.mesh,h=o.inferScale(),a=l.getCustomAttribute("translation"),c=[h*a[0],h*a[1]];r.strokeStyle=s,r.lineWidth=h*t,r.beginPath(),r.moveTo(i[0]+c[0],i[1]+c[1]),r.lineTo(n[0]+c[0],n[1]+c[1]),r.stroke()}}}var ze=_e;const ke=Me;var De=class{constructor(e={}){this.system=e.system,this.renderVertexIds=e.renderVertexIds??!1,this.radius=e.radius??.028,this.borderColor=e.borderColor??"black",this.fillColor=e.fillColor??"white",this.borderWidth=e.borderWidth??.023}renderVertex(e={}){const t=this.radius,s=this.borderColor,r=this.fillColor,i=this.borderWidth,n=e.ctx,o=e.p,l=e.camera.inferScale();if(function(e,t,s,r,i,n,o){const l=(r+.5*i)*t;e.fillStyle=o,e.beginPath(),e.arc(s[0],s[1],l,0,2*Math.PI),e.fill(),e.lineWidth=i*t,e.strokeStyle=n,e.stroke()}(n,l,o,t,i,s,r),this.renderVertexIds){n.beginPath(),n.fillStyle="rgba(255, 255, 255, 0.8)",n.arc(o[0],o[1],.1*l,0,2*Math.PI),n.fill();const t=Math.floor(.15*l);n.font=`${t}px monospace`,n.fillStyle="black",n.textAlign="center",n.textBaseline="middle",n.fillText(e.id,o[0],o[1])}}getVertexPos(e){const t=this.system.pos.slot.f32(),s=e*this.system.spaceDim;return[t[s],t[s+1]]}get numVertices(){return this.system.numVertices}hitTest(e,t=.31){const s=this.numVertices;if(0==s)return null;let r=null,i=1/0;const n=t*t;for(let t=0;t<s;t++){const s=this.getVertexPos(t),o=ke.math.Vec2.sub(s,e),l=ke.math.Vec2.quadrance(o);l<n&&l<i&&(r=t,i=l)}return r}setVertexPos(e,t){if(null==e)throw new Error("vertex id required");const s=this.system.pos.slot.f32(),r=2*e;s[r]=t[0],s[r+1]=t[1]}setVertexVel(e,t){const s=this.system.vel.slot.f32(),r=2*e;s[r]=t[0],s[r+1]=t[1]}};const qe=Me,$e=Te,We=ze,Pe=De;function Fe(e){return e.sort(),e.join("_")}function je(e){if(7!=e.length)throw new Error(`invalid hex string ${e}`);if("#"!=e[0])throw new Error(`invalid hex string ${e}, expected #, found ${e[0]}`);return e=e.substring(1),[parseInt(e.substring(0,2),16),parseInt(e.substring(2,4),16),parseInt(e.substring(4,6),16)]}var Be={SystemViewport:class{constructor(e={}){if(null==e.system)throw new Error("system required");this.system=e.system;const t=e.sortedVertexIds;this.sortedVertexIds=t,null!=e.vertexDepths&&this.setSortedVertexIdsFromVertexDepths(e.vertexDepths);const s=e.headless??!1,r=e.borderColor??"black",i=r,n=e.fillColor??"white",o=e.gridColor??"#acadad";this.vertices=new Pe({system:this.system,renderVertexIds:e.renderVertexIds??!1,borderColor:r,fillColor:n}),this.lines=new class{constructor(e={}){this.system=e.system}makeLineShaderFunction(e={}){const t=e.activeMuscleColor??[255,0,0],s=e.inactiveMuscleColor??[0,0,255],r=e.borderColor??"black";return(e={})=>{const i=e.ctx,n=e.a,o=e.b,l=e.camera.inferScale(),h=e.mesh.getCustomAttribute("lineIdToMuscleId")[e.id];if(null==h)!function(e,t,s,r,i,n){e.beginPath(),e.lineJoin="round",e.lineCap="round",e.strokeStyle=n,e.lineWidth=.029*t,e.moveTo(s[0],s[1]),e.lineTo(r[0],r[1]),e.closePath(),e.stroke()}(i,l,n,o,0,r);else{const a=t,c=s,d=.065,u=.017,m="muscleIntensity",p=e.mesh.getCustomAttribute(m);if(null==p)throw new Error(`muscle intensity attribute (${m}) not found, call setCustomAttribute("${m}", value) before rendering.`);if(!Array.isArray(p))throw new Error("muscle intensity attribute must be an array with values for each fiber, found "+typeof p);!function(e,t,s,r,i,n,o,l,h,a){e.beginPath(),e.lineCap="butt",e.strokeStyle=l,e.lineWidth=(n+2*o)*t,e.moveTo(s[0],s[1]),e.lineTo(r[0],r[1]),e.stroke(),e.beginPath();const c=(1-i)*h[0]+i*a[0],d=(1-i)*h[1]+i*a[1],u=(1-i)*h[2]+i*a[2];e.strokeStyle=`rgb(${c}, ${d}, ${u})`,e.lineWidth=n*t,e.moveTo(s[0],s[1]),e.lineTo(r[0],r[1]),e.stroke()}(i,l,n,o,p[h],d,u,r,a,c)}}}}({system:this.system});const l=new qe.Renderer({headless:s});this.renderer=l,this.domElement=l.domElement,this.setSize({width:e.width??400,height:e.height??400});const h=new qe.Scene;this.scene=h;const a=new qe.Camera;this.camera=a;let c,d,u=e.activeMuscleColor??[255,0,0],m=e.inactiveMuscleColor??[250,190,190];"string"==typeof u&&(u=je(u)),"string"==typeof m&&(m=je(m)),null!=e.backgroundColor?(c=e.backgroundColor,d=e.backgroundColor):(c=e.backgroundCenterColor??"#fcfcfc",d=e.backgroundOuterColor??"#d7d8d8"),new qe.background.Background({scene:h,color1:c,color2:d});const p=this.grid=new qe.background.Grid({scene:h,x0:-3,y0:0,rows:4,cols:10,innerCells:2,primaryLineWidth:.022,secondaryLineWidth:.005,color:o});p.innerCells=2,p.primaryLineWidth=.022,p.secondaryLineWidth=.005,this.floor=new We({scene:h,color:i});const f=h.addMesh();if(this.mesh=f,f.pointShader.renderPoint=e=>{this.vertices.renderVertex(e)},f.triangleShader.renderTriangle=(e={})=>{const t=e.ctx,s=e.a,r=e.b,i=e.c;t.beginPath(),t.fillStyle=n,t.moveTo(...s),t.lineTo(...r),t.lineTo(...i),t.closePath(),t.fill()},f.lineShader.renderLine=this.lines.makeLineShaderFunction({activeMuscleColor:u,inactiveMuscleColor:m,borderColor:r}),e.draggable??1){const t=this.dragBehavior=new qe.ui.DragBehavior({onDomCursorDown:(e,s)=>{if("button"in s&&0!=s.button)return;const r=this.system,i=a.domToWorldSpace(e),n=this.hitTestVertex(i);null!=n&&(this.fixVertex(n),t.beginDrag(),this.setVertexPos(r.vertices.fixedVertexId,[i[0],Math.max(0,i[1])]))},onDragProgress:e=>{const t=this.system,s=a.domToWorldSpace(e);this.setVertexPos(t.vertices.fixedVertexId,[s[0],Math.max(0,s[1])])},onDomCursorUp:()=>{this.freeVertex()}});if(!s){const s=e.domElementForMoveEvents??null;t.linkToDom(l.domElement,s)}}this.tracker=new $e}setSortedVertexIdsFromVertexDepths(e){if(e.length!=this.system.numVertices)throw new Error(`invalid size for depths, found ${e.length}, expected ${this.system.numVertices}`);const t=e.map(((e,t)=>({depth:e,index:t})));t.sort(((e,t)=>t.depth-e.depth));const s=t.map((e=>e.index));this.sortedVertexIds=s}setSize(e={}){this.renderer.setSize({width:e.width,height:e.height})}render(){(null==this.needsMeshUpdate||this.needsMeshUpdate)&&(this._updateMesh({triangles:this.system.getTrianglesArray(),muscles:this.system.getMusclesArray()}),this.needsMeshUpdate=!1);const e=this.renderer,t=this.scene,s=this.camera,r=this.mesh;this._updateFromSystem(),null!=this.dragBehavior&&this.dragBehavior.dragging()||this.tracker.step({mesh:r,camera:s,floor:this.floor,grid:this.grid,renderer:this.renderer}),e.render(t,s)}_updateMesh(e){const t=this.mesh,s=this.system.numVertices;if(!Number.isInteger(s)||s<0)throw new Error(`invalid number of vertices ${s}`);null!=e.pos&&(t.pos=e.pos),t.triangles=e.triangles,t.lines=function(e){const t=new Map;function s(e,s){const r=Fe([e,s]);t.set(r,[e,s])}return e.forEach((e=>{s(e[0],e[1]),s(e[1],e[2]),s(e[0],e[2])})),Array.from(t.values())}(e.triangles),Array.prototype.push.apply(t.lines,e.muscles);const r=new Map;e.muscles.forEach(((e,t)=>{r.set(Fe(e),t)}));const i=[];t.setCustomAttribute("lineIdToMuscleId",i),t.lines.forEach((e=>{const t=Fe(e),s=r.get(t);i.push(s)}));let n=this.sortedVertexIds;if(null==n){n=[];for(let e=0;e<s;e++)n.push(e)}if(n.length!=s)throw new Error(`invalid size for sortedVertexIds, found ${n.length}, expected ${s}`);t.sortedElements=qe.sorted.makeSortedElements({sortedVertexIds:n,triangles:t.triangles,edges:t.lines});const o=[],l=this.system.numMuscles;for(let e=0;e<l;e++)o.push(1);t.setCustomAttribute("muscleIntensity",o)}_updateFromSystem(){this._updateVertexPositionsFromSystem(),this._updateMuscleIntensityFromSystem()}_updateVertexPositionsFromSystem(){const e=this.mesh,t=this.system;if(0==t.numVertices)e.pos=[];else{const s=t.pos.toArray();e.pos=s}}_updateMuscleIntensityFromSystem(){const e=this.mesh,t=this.system,s=t.numMuscles;if(!Number.isInteger(s)||s<0)throw new Error(`invalid number of muscles ${s}`);let r=[];if(s>0)if(t.a){const e=t.a.slot.f32();for(let t=0;t<s;t++)r.push(e[t])}else r=new Array(s).fill(1);e.setCustomAttribute("muscleIntensity",r)}hitTestVertex(e,t=.31){return this.vertices.hitTest(e,t)}setVertexPos(e,t){this.vertices.setVertexPos(e,t)}setVertexVel(e,t){this.vertices.setVertexVel(e,t)}fixVertex(e){const t=this.system;this.setVertexVel(e,[0,0]),null==e&&(e=-1),t.vertices.fixVertex(e)}freeVertex(){this.system.vertices.freeVertex()}},VertexRenderer:De,Tracker:Te},He=function(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}({System:class{constructor(e={}){let t;if(null==e.ten){if(null==e.wasmInstance)throw new Error("wasmInstance required");t=new U.Engine({wasmInstance:e.wasmInstance}),this.ten=t}else t=e.ten,this.ten=t;this.h=.033,this.g=9.8,this.spaceDim=e.spaceDim??2,this.vertices=new X({ten:this.ten,vertexMass:e.vertexMass,spaceDim:this.spaceDim}),this.muscles=new G({ten:this.ten}),this.triangles=new class{constructor(e={}){const t=e.ten;if(null==t)throw new Error("ten required");this.ten=t,this.simplexOrder=e.simplexOrder??3,this.indices=null,this.rsi=null,this.mu=null,this.lambda=null}get wasmInstance(){return this.ten.wasmInstance}get memoryManager(){return this.ten.mgr}get numElements(){return null==this.indices?0:this.indices.u32().length/this.simplexOrder}get numTriangles(){return this.numElements}toStepArgs(){const e=this.numElements;return[e,0==e?0:this.indices.ptr,0==e?0:this.rsi.ptr,0==e?0:this.mu.ptr,0==e?0:this.lambda.ptr]}set(e={}){const t=e.indices,s=e.rsi,r=t?t.length:this.numTriangles;if(null==t&&(!s||s.length!==r))throw new Error("rsi is not consistent with the number of indices");const i=this.memoryManager,n=this.ten,o=t?i.malloc32(r*this.simplexOrder):this.indices;if(t&&null!=this.indices&&this.indices.free(),this.indices=o,null!=t){const e=o.u32();t.forEach(((t,s)=>{const r=s*this.simplexOrder;for(let s=0;s<this.simplexOrder;s++)e[r+s]=t[s]}))}if(null!=this.rsi&&this.rsi.dispose(),this.rsi=n.zeros([r,this.simplexOrder-1,this.simplexOrder-1]),null==s){let t=null,s=!1;if(null!=e.pos)if(Array.isArray(e.pos))t=n.tensor(e.pos),s=!0;else if(t=e.pos,null==t.ptr)throw new Error("invalid pos");this.wasmInstance.exports.rsi_of_pos(this.numVertices,t.ptr,r,this.indices.ptr,this.rsi.ptr),s&&t.dispose()}else this.rsi.set(s);null!=this.mu&&this.mu.dispose(),this.mu=n.zeros([r]),this.mu.fill_(Math.fround(500)),null!=this.lambda&&this.lambda.dispose(),this.lambda=n.zeros([r]),this.lambda.fill_(Math.fround(50))}dispose(){null!=this.indices&&(this.indices.free(),this.indices=null),null!=this.rsi&&(this.rsi.dispose(),this.rsi=null),null!=this.mu&&(this.mu.dispose(),this.mu=null),null!=this.lambda&&(this.lambda.dispose(),this.lambda=null)}}({ten:this.ten,simplexOrder:this.spaceDim+1}),this.friction={k:Math.fround(300)}}set fixedVertexId(e){throw new Error("System.fixedVertexId setter is deprecated, use System.vertices.fixedVertexId instead")}get fixedVertexId(){throw new Error("System.fixedVertexId getter is deprecated, use System.vertices.fixedVertexId instead")}get wasmInstance(){return this.ten.wasmInstance}get memoryManager(){return this.ten.mgr}get vertexMass(){return this.vertices.vertexMass}get rsi(){return this.triangles.rsi}set rsi(e){this.triangles.rsi=e}get k(){return this.muscles.k}set k(e){this.muscles.k=e}get pos0(){return this.vertices.pos}get vel0(){return this.vertices.vel0}get pos(){return this.vertices.pos}get vel(){return this.vertices.vel}get numVertices(){return this.vertices.numVertices}get numTriangles(){return this.triangles.numTriangles}get numMuscles(){return this.muscles.numMuscles}get a(){return this.muscles.a}set a(e){this.muscles.a=e}get l0(){return this.muscles.l0}set l0(e){this.muscles.l0=e}setVertices(e){this.vertices.set(e)}setMuscles(e={}){this.muscles.set({...e,pos:e.pos??this.pos0})}setTriangles(e={}){this.triangles.set({...e,pos:e.pos??this.pos0})}getMusclesArray(){if(null==this.muscles)return[];const e=this.numMuscles,t=this.muscles.indices.u32(),s=[];for(let r=0;r<e;r++){const e=2*r;s.push([t[e],t[e+1]])}return s}getTrianglesArray(){if(null==this.triangles)return[];const e=this.numTriangles,t=this.triangles.indices.u32(),s=[];for(let r=0;r<e;r++){const e=3*r;s.push([t[e],t[e+1],t[e+2]])}return s}set(e){this.setVertices(e.pos),this.setMuscles({indices:e.muscles??[],l0:e.musclesL0,k:e.musclesK}),this.setTriangles({indices:e.triangles??[],rsi:e.trianglesRsi})}step(){const e=this.numVertices;this.numMuscles;const t=this.vertices._fixedVertexId,s=this.vertexMass;this.wasmInstance.exports.backward_euler_update(this.spaceDim,this.g,this.h,e,0==e?0:this.pos0.ptr,0==e?0:this.vel0.ptr,s,...this.muscles.toStepArgs(),...this.triangles.toStepArgs(),this.friction.k,t,0==e?0:this.vertices.pos1.ptr,0==e?0:this.vertices.posGrad.ptr,0==e?0:this.vertices.posTmp.ptr,0==e?0:this.vertices.vel1.ptr),0!=e&&(this.vertices.pos0.slot.f32().set(this.vertices.pos1.slot.f32()),this.vertices.vel0.slot.f32().set(this.vertices.vel1.slot.f32()))}dispose(){this.vertices.dispose(),this.muscles.dispose(),this.triangles.dispose()}},Vertices:O,mmgrten:N,SystemViewport:Be.SystemViewport,mm2d:Me,render:Be});function Re(e,t){const s=1-Math.random(),r=Math.random();return e+Math.sqrt(-2*Math.log(s))*Math.cos(2*Math.PI*r)*t}class Ne{constructor(e={}){if(null==e.system)throw new Error("system required to create policy");this.system=e.system,this.ten=this.system.ten,this.active=e.active??!1,this.stochastic=e.stochastic??!1,this.stdDev=e.stdDev??.05;const t=this.system,s=this.ten,r=t.numVertices,i=t.numMuscles,n=t.spaceDim;this.projectedPos=s.zeros([r,n]),this.projectedVel=s.zeros([r,n]);const o=r*n*2,l=i;this.input=s.zeros([o]);const h=s.nn;this.model=h.Sequential(h.Linear(o,32),h.ReLU(),h.Linear(32,l),h.Tanh())}step(){const e=this.system,t=this.ten.wasmInstance,s=e.numVertices;t.exports.make_neural_policy_input(s,e.pos.ptr,e.vel.ptr,this.centerVertexId,this.forwardVertexId,this.projectedPos.ptr,this.projectedVel.ptr,this.input.ptr);const r=this.model.forward(this.input),i=this.minA,n=this.maxAbsDa,o=this.system.a,l=r.slot.f32(),h=this.system.numMuscles;for(let e=0;e<h;e++){let t;this.active?(t=r.get([e]),this.stochastic&&(t+=Re(0,this.stdDev))):t=1,l[e]=t}r.clamp_({min:-n,max:n});const a=o.slot.f32();for(let e=0;e<h;e++)a[e]+=l[e];o.clamp_({min:i,max:1})}loadData(e){const t=this.model.layers[0];t.weight.set(e.fc1.weight),t.bias.set(e.fc1.bias);const s=this.model.layers[2];s.weight.set(e.fc2.weight),s.bias.set(e.fc2.bias),this.minA=e.min_a??(()=>{throw new Error("min_a required")})(),this.maxAbsDa=e.max_abs_da??(()=>{throw new Error("max_abs_da required")})(),this.centerVertexId=e.center_vertex_id??(()=>{throw new Error("center_vertex_id required")})(),this.forwardVertexId=e.forward_vertex_id??(()=>{throw new Error("forward_vertex_id required")})()}dispose(){null!=this.projectedPos&&this.projectedPos.dispose(),null!=this.projectedVel&&this.projectedVel.dispose(),null!=this.input&&this.input.dispose(),this.model.dispose()}}class Oe{constructor(e={}){const t=this.domElement=document.createElement("div");t.style.userSelect="none",t.style.webkitTapHighlightColor="transparent",t.style.padding="12px",t.style.boxSizing="content-box",t.style.cursor="pointer",t.style.borderRadius="50%",t.style.minHeight=t.style.height,t.style.margin="4px",t.style.display="flex",t.style.alignItems="center",t.style.justifyContent="center",t.style.boxShadow="0 0 8px rgba(0, 0, 0, 0.2)",t.style.padding="20px",t.style.overflow="hidden",this.initSvg(),this.setSize(40),this.setInactiveStyle()}setSize(e){const t=this.domElement;t.style.width=`${e}px`,t.style.height=`${e}px`,t.style.minHeight=`${e}px`}initSvg(){const e="white",t=document.createElementNS("http://www.w3.org/2000/svg","svg");this.svg=t,t.style.width="100%",t.setAttribute("width","198"),t.setAttribute("height","217"),t.setAttribute("viewBox","0 0 198 217"),t.setAttribute("fill","none");const s=document.createElementNS("http://www.w3.org/2000/svg","path");s.setAttribute("fill-rule","evenodd"),s.setAttribute("clip-rule","evenodd"),s.setAttribute("d","M156.5 186.309L173 178.837V161.992L152.888 150.729L130.5 162.127V194.062H120.5V155.996L148 141.996V121.915L173 109.915V86.0615H183V116.208L158 128.208V142.131L177.975 153.317L197.5 142.16V76.5834L179.133 63.0079L157 75.4829L156.5 102H146.5L147 75.4371L119.5 59.4371V22.5615H129.5V53.6859L152.039 66.7998L174.42 54.185L174.077 41.482L156.5 31.2553V48.5615H146.5V13.2817L125.974 0L105 13.3103V128.519L121 117.442V89.0615H131V122.681L105 140.681V204.221L125.975 216.725L146.5 204.249V169.562H156.5V186.309Z"),s.setAttribute("fill",e),t.appendChild(s);const r=document.createElementNS("http://www.w3.org/2000/svg","path");r.setAttribute("fill-rule","evenodd"),r.setAttribute("clip-rule","evenodd"),r.setAttribute("d","M41 30.4169L24.5 37.8885V54.7333L44.6122 65.9962L67 54.5988V22.664H77V60.7291L49.5 74.7291V94.8101L24.5 106.81V130.664H14.5V100.518L39.5 88.5178V74.5946L19.5249 63.4085L0 74.5656V140.142L18.3669 153.718L40.5 141.243L41 114.725H51L50.5 141.288L78 157.288V194.164H68V163.04L45.4606 149.926L23.0796 162.54L23.4229 175.243L41 185.47V168.164H51V203.444L71.5262 216.725L92.5 203.415V88.2068L76.5 99.2837V127.664H66.5V94.0442L92.5 76.0442V12.5043L71.525 -3.05176e-05L51 12.476V47.164H41V30.4169Z"),r.setAttribute("fill",e),t.appendChild(r),this.domElement.appendChild(t)}setActiveStyle(){this.domElement.style.backgroundColor="black"}setInactiveStyle(){this.domElement.style.backgroundColor="rgba(1, 1, 1, 0.2)"}}class Ue extends He.SystemViewport{constructor(e={}){super(e),this.setStyle()}setStyle(){this.domElement.style.borderRadius="10px",this.domElement.style.border="2px solid #c9c9c9",this.domElement.style.boxShadow="0 0 10px rgba(0, 0, 0, 0.1)";const e=window.matchMedia("(max-width: 410px)"),t=()=>{e.matches?this.setSize({width:300,height:350}):this.setSize({width:400,height:400})};e.addEventListener("change",(e=>{t()})),t()}}class Xe{constructor(e,t){this.domElement=document.createElement("div"),this.domElement.style.textAlign="left",this.domElement.style.color="#666",this.domElement.style.fontSize="14px",this.domElement.style.padding="22px",this.domElement.style.paddingRight="26px",this.domElement.style.paddingLeft="26px",this.domElement.style.paddingBottom="45px",this.domElement.style.width="100%",this.domElement.style.display="flex",this.domElement.style.justifyContent="center";const s=document.createElement("div");s.style.maxWidth="600px",this.domElement.appendChild(s);const r=document.createElement("h2");this.header=r,r.style.color="black",r.style.fontSize="25px",r.style.padding="10px",r.style.borderBottom="2px solid black",r.textContent=e;const i=document.createElement("div");i.innerHTML=t,s.appendChild(r),s.appendChild(i)}setStyle1(){this.domElement.style.backgroundColor="black",this.domElement.style.color="rgb(199, 199, 199)",this.domElement.style.boxShadow="rgba(0, 0, 0, 0.3) 0px 0px 10px",this.header.style.color="white",this.header.style.borderBottom="2px solid white"}}class Ge{constructor(){let e;this.domElement=document.createElement("div"),this.domElement.style.marginTop="16px",this.domElement.style.textAlign="left",this.domElement.style.color="#666",this.domElement.style.fontSize="14px",this.domElement.style.width="100%",this.domElement.style.display="flex",this.domElement.style.flexDirection="column",e=this.addSection("energy-based models for virtual creatures",'<div style="display: flex; flex-direction: column">\n<a href="https://direct.mit.edu/isal/proceedings/isal2024/36/30/123447" style="padding-top: 25px; display: flex; flex-direction: column; align-items: center">\n  <img src="icons/doc.svg" style="width: 30px"></img>\n  <div>paper [ALIFE 2024]</div>\n</a>\n<p>\nPotential energy minimization is one of the <a href="https://youtu.be/c8iFtaltX-s?si=MDUb20nFhumn1Q3n&t=3553">most basic forms of goal-directed behavior</a>.\nA deformable object that tends to recover its original shape can be understood as a system whose goal is to minimize its elastic potential energy.\nIn the context of <a href="https://youtu.be/MiqLoAZFRSE?t=2177">energy-based models</a>, &ldquo;energy&rdquo; is used to define implicit functions that capture dependencies between variables.\nThis more general notion of energy is consistent with potential energy, and is also useful to model inertia, friction, neuromuscular control and many other goal-directed behaviors that may or may not be conventionally considered <a href="https://youtu.be/lIHUWOv4nkE?t=629">&ldquo;just physics&rdquo;</a>.\n</p>\n</div>'),e.setStyle1(),e=this.addSection("no forces, just energy functions","<p>\nMuch like the loss function encapsulates in a single scalar value the objective of a neural network during training, potential energy functions offer a scalar representation of the objective of a mechanical system in a dissipative process.\nIn practice, just as we typically do not compute neural network gradients by hand, we can also avoid computing forces by hand if we use automatic differentiation.\nThe force is just the negative gradient of the potential energy.\nFor more general energy functions, which extend beyond potential energy, the negative gradient might not directly represent a force, but it is useful for gradient-based optimization.\n</p>"),e=this.addSection("six energy functions",'<p>\nThis implementation defines six energy functions. Some are plain potential energy functions, that is, functions of vertex positions <span class="code">E(pos)</span>. Actuation mechanisms are modeled with an action-dependent energy function <span class="code">E(pos, a)</span>. Other energy functions may also depend on the previous state, given by vertex positions and velocities <span class="code">(pos0, vel0)</span>.\n</p>\n\n<ul>\n<li>\n  <a href="https://github.com/juniorrojas/algovivo/blob/main/csrc/potential/gravity.h">gravity</a>\n  <span class="code">E(pos)</span>\n</li>\n<li>\n  <a href="https://github.com/juniorrojas/algovivo/blob/main/csrc/potential/collision.h">collision</a>\n  <span class="code">E(pos)</span>\n</li>\n<li>\n  <a href="https://github.com/juniorrojas/algovivo/blob/main/csrc/potential/muscles.h">muscles</a>\n  <span class="code">E(pos, a)</span>\n</li>\n<li>\n  <a href="https://github.com/juniorrojas/algovivo/blob/main/csrc/potential/triangles.h">triangles</a>\n  <span class="code">E(pos)</span>\n</li>\n<li>\n  <a href="https://github.com/juniorrojas/algovivo/blob/main/csrc/potential/friction.h">friction</a>\n  <span class="code">E(pos, pos0)</span>\n</li>\n<li>\n  <a href="https://github.com/juniorrojas/algovivo/blob/main/csrc/dynamics/inertia.h">inertia</a>\n  <span class="code">E(pos, pos0, vel0)</span>\n</li>\n</ul>'),e.setStyle1(),e=this.addSection("no differential equations, just energy minimization",'<p>\nThis implementation uses the backward Euler method, which is conventionally presented as an implicit <a class="a2" href="https://github.com/juniorrojas/springs-integration-pytorch">numerical integration</a> method, derived as a numerical solution to a differential equation like f = ma (Newtonian mechanics).\nHowever, what we actually implement in practice to solve the resulting non-linear root finding problem in a reliable manner is a gradient-based optimization method that finds a local minimum of a function that consists of the sum of the six energy functions mentioned before:\n</p>\n\n<span class="code2" style="white-space: normal">pos1 = argmin((pos) => E(pos, pos0, vel0, a))</span>\n\n<p>\nThe velocity is then updated with a simple update rule:\n</p>\n\n<span class="code2">vel1 = (pos1 - pos0) / dt</span>\n\n<p>\nMany other implicit numerical integration methods share a similar form, where the next state is found by minimizing an energy function.\nWhile the inertial energy term and velocity update rule may vary depending on the specific method used, energy minimization remains central to explaining state transitions.\nInstead of viewing these methods as numerical solutions to differential equations, we can view them as energy-based models that capture Newton\'s first law of motion in an inertial energy term.\n</p>'),e=this.addSection("no Lagrangians, no Hamiltonians, just energy",'<p>\nRecall that in this context &ldquo;energy&rdquo; is any <a href="https://youtu.be/MiqLoAZFRSE?t=2177">scalar-valued function that measures incompatibility between variables</a>.\nWhen we say inertial energy, we do not mean kinetic energy.\nWhen we say energy minimization, we do not mean Hamiltonian minimization.\nIt is actually possible to implement <a href="https://github.com/juniorrojas/springs-integration-pytorch?tab=readme-ov-file#total-energy-hamiltonian-conservation">Hamiltonian-preserving methods</a> by &ldquo;energy&rdquo; minimization.\nEnergy-based models can also easily describe dissipative systems.\n<a href="https://www.youtube.com/watch?v=7fRfxiyTKS0">Lagrangians and Hamiltonians cannot really describe dissipative systems</a>.\nWhen we say energy minimization, we mean something akin to the least action principle, except that &ldquo;action&rdquo; has a very specific definition in Lagrangian mechanics, and we are not using that definition here.\nWe also want to reserve the word &ldquo;action&rdquo; to refer to actuation mechanisms, such as muscle control, which are modeled as action-dependent energy functions.\nWhatever variable or function names you prefer to use in your code, the important thing is to have a <a href="https://github.com/juniorrojas/algovivo">working implementation</a> that goes beyond just words and mathematical formulas that may not even be computable.\n</p>'),e.setStyle1()}addSection(e,t){const s=new Xe(e,t);return this.domElement.appendChild(s.domElement),s}}class Ye{constructor(){const e=document.createElement("div");var t;this.domElement=e,(t=e.style).display="flex",t.flexDirection="column",t.alignItems="center",t.color="white",t.width="100%",t.backgroundColor="#000000",t.paddingTop="20px",t.paddingBottom="20px",t.paddingRight="50px",t.paddingLeft="50px",t.marginBottom="30px",t.boxShadow="0 0 10px rgba(0, 0, 0, 0.3)";const s=document.createElement("h1");s.textContent="algovivo",e.appendChild(s),(e=>{e.fontSize="33px",e.color="white"})(s.style);const r=document.createElement("h2");r.textContent="an energy-based formulation for soft-bodied virtual creatures",e.appendChild(r),(e=>{e.textAlign="center",e.fontSize="18px",e.color="#c7c7c7"})(r.style)}}const Ze="data";async function Ke(){const e=await fetch(`${Ze}/mesh.json`);return await e.json()}async function Je(){const e=await fetch(`${Ze}/policy.json`);return await e.json()}!async function(){document.body.style.background="rgb(248, 248, 248)",document.body.style.display="flex",document.body.style.flexDirection="column",function(){const e=document.createElement("a");document.body.appendChild(e),e.href="https://github.com/juniorrojas/algovivo",e.innerHTML='<svg style="cursor: pointer; position: absolute; top: 0; border: 0; right: 0; margin: 10px 7px;" viewBox="0 0 98 96" width="40" height="40" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M48.854 0C21.839 0 0 22 0 49.217c0 21.756 13.993 40.172 33.405 46.69 2.427.49 3.316-1.059 3.316-2.362 0-1.141-.08-5.052-.08-9.127-13.59 2.934-16.42-5.867-16.42-5.867-2.184-5.704-5.42-7.17-5.42-7.17-4.448-3.015.324-3.015.324-3.015 4.934.326 7.523 5.052 7.523 5.052 4.367 7.496 11.404 5.378 14.235 4.074.404-3.178 1.699-5.378 3.074-6.6-10.839-1.141-22.243-5.378-22.243-24.283 0-5.378 1.94-9.778 5.014-13.2-.485-1.222-2.184-6.275.486-13.038 0 0 4.125-1.304 13.426 5.052a46.97 46.97 0 0 1 12.214-1.63c4.125 0 8.33.571 12.213 1.63 9.302-6.356 13.427-5.052 13.427-5.052 2.67 6.763.97 11.816.485 13.038 3.155 3.422 5.015 7.822 5.015 13.2 0 18.905-11.404 23.06-22.324 24.283 1.78 1.548 3.316 4.481 3.316 9.126 0 6.6-.08 11.897-.08 13.526 0 1.304.89 2.853 3.316 2.364 19.412-6.52 33.405-24.935 33.405-46.691C97.707 22 75.788 0 48.854 0z" fill="#fff"/></svg>'}();const e=new Ye;document.body.appendChild(e.domElement);const t=document.createElement("div");t.style.display="flex",t.style.flexDirection="column",t.style.alignItems="center",t.style.width="100%",document.body.appendChild(t);const s=await async function(){const e=await fetch("algovivo.wasm");return(await WebAssembly.instantiateStreaming(e)).instance}(),r=new He.System({wasmInstance:s});document.documentElement.style.height="100%",document.body.style.height="100%",document.body.style.display="flex",document.body.style.margin=0,document.body.style.padding=0,document.body.style.alignItems="center";const[i,n]=await Promise.all([Ke,Je].map((e=>e())));r.set({pos:i.pos,muscles:i.muscles,musclesL0:i.l0,triangles:i.triangles,trianglesRsi:i.rsi});const o=new Ue({system:r,sortedVertexIds:i.sorted_vertex_ids,vertexDepths:i.depth});t.appendChild(o.domElement);const l=new Ne({system:r,stochastic:!0});l.loadData(n),window.togglePolicy=()=>{l.active=!l.active,l.active?h.setActiveStyle():h.setInactiveStyle()};const h=new Oe;h.domElement.style.marginTop="8px",h.domElement.style.marginBottom="16px",h.domElement.addEventListener("click",(()=>{togglePolicy()})),t.appendChild(h.domElement);const a=new Ge;t.appendChild(a.domElement),o.render(),setInterval((()=>{l.step(),r.step(),o.render()}),1e3/30),window.system=r}();
